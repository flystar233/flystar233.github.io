<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pandas]]></title>
    <url>%2F2018%2F09%2F05%2Fpandas%2F</url>
    <content type="text"><![CDATA[导入 pandas、numpy、matplotlib 12345In [1]: import pandas as pdIn [2]: import numpy as npIn [3]: import matplotlib.pyplot as plt 创造对象Series 是一个值的序列，它只有一个列，以及索引。下面的例子中，就用默认的整数索引 1234567891011In [4]: s = pd.Series([1,3,5,np.nan,6,8])In [5]: sOut[5]: 0 11 32 53 NaN4 65 8dtype: float64 DataFrame 是有多个列的数据表，每个列拥有一个 label，当然，DataFrame 也有索引 12345678910111213141516171819In [6]: dates = pd.date_range('20130101', periods=6)In [7]: datesOut[7]: DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D')In [8]: df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))In [9]: dfOut[9]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.0874012013-01-06 -0.673690 0.113648 -1.478427 0.524988 如果参数是一个 dict，每个 dict 的 value 会被转化成一个 Series 123456789101112131415In [10]: df2 = pd.DataFrame(&#123; 'A' : 1., ....: 'B' : pd.Timestamp('20130102'), ....: 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), ....: 'D' : np.array([3] * 4,dtype='int32'), ....: 'E' : pd.Categorical(["test","train","test","train"]), ....: 'F' : 'foo' &#125;) ....: In [11]: df2Out[11]: A B C D E F0 1 2013-01-02 1 3 test foo1 1 2013-01-02 1 3 train foo2 1 2013-01-02 1 3 test foo3 1 2013-01-02 1 3 train foo 每列的格式用 dtypes 查看 123456789In [12]: df2.dtypesOut[12]: A float64B datetime64[ns]C float32D int32E categoryF objectdtype: object 你可以认为，DataFrame 是由 Series 组成的 1234567In [13]: df2.AOut[13]: 0 11 12 13 1Name: A, dtype: float64 查看数据用 head 和 tail 查看顶端和底端的几列 123456789101112131415In [14]: df.head()Out[14]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.087401In [15]: df.tail(3)Out[15]: A B C D2013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-05 -0.424972 0.567020 0.276232 -1.0874012013-01-06 -0.673690 0.113648 -1.478427 0.524988 实际上，DataFrame 内部用 numpy 格式存储数据。你也可以单独查看 index 和 columns 1234567891011121314151617In [16]: df.indexOut[16]: DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D')In [17]: df.columnsOut[17]: Index(['A', 'B', 'C', 'D'], dtype='object')In [18]: df.valuesOut[18]: array([[ 0.4691, -0.2829, -1.5091, -1.1356], [ 1.2121, -0.1732, 0.1192, -1.0442], [-0.8618, -2.1046, -0.4949, 1.0718], [ 0.7216, -0.7068, -1.0396, 0.2719], [-0.425 , 0.567 , 0.2762, -1.0874], [-0.6737, 0.1136, -1.4784, 0.525 ]]) describe() 显示数据的概要。 1234567891011In [19]: df.describe()Out[19]: A B C Dcount 6.000000 6.000000 6.000000 6.000000mean 0.073711 -0.431125 -0.687758 -0.233103std 0.843157 0.922818 0.779887 0.973118min -0.861849 -2.104569 -1.509059 -1.13563225% -0.611510 -0.600794 -1.368714 -1.07661050% 0.022070 -0.228039 -0.767252 -0.38618875% 0.658444 0.041933 -0.034326 0.461706max 1.212112 0.567020 0.276232 1.071804 和 numpy 一样，可以方便的得到转置 1234567In [20]: df.TOut[20]: 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06A 0.469112 1.212112 -0.861849 0.721555 -0.424972 -0.673690B -0.282863 -0.173215 -2.104569 -0.706771 0.567020 0.113648C -1.509059 0.119209 -0.494929 -1.039575 0.276232 -1.478427D -1.135632 -1.044236 1.071804 0.271860 -1.087401 0.524988 对 axis 按照 index 排序（axis=1 是指第二个维度，即：列，axis=0 是指第一个维度，即：行） 123456789In [21]: df.sort_index(axis=1, ascending=False) #ascending=False 默认为True，升序Out[21]: D C B A2013-01-01 -1.135632 -1.509059 -0.282863 0.4691122013-01-02 -1.044236 0.119209 -0.173215 1.2121122013-01-03 1.071804 -0.494929 -2.104569 -0.8618492013-01-04 0.271860 -1.039575 -0.706771 0.7215552013-01-05 -1.087401 0.276232 0.567020 -0.4249722013-01-06 0.524988 -1.478427 0.113648 -0.673690 按值排序 123456789In [22]: df.sort_values(by='B')Out[22]: A B C D2013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.2718602013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-06 -0.673690 0.113648 -1.478427 0.5249882013-01-05 -0.424972 0.567020 0.276232 -1.087401 选择 注意，以下这些对交互式环境很友好，但是作为 production code 请用优化过的 .at, .iat, .loc, .iloc 和 .ix 获取行/列从 DataFrame 选择一个列，就得到了 Series 123456789In [23]: df['A']Out[23]: 2013-01-01 0.4691122013-01-02 1.2121122013-01-03 -0.8618492013-01-04 0.7215552013-01-05 -0.4249722013-01-06 -0.673690Freq: D, Name: A, dtype: float64 和 numpy 类似，这里也能用 []选择行 12345678910111213In [24]: df[0:3]Out[24]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.071804In [25]: df['20130102':'20130104']Out[25]: A B C D2013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-03 -0.861849 -2.104569 -0.494929 1.0718042013-01-04 0.721555 -0.706771 -1.039575 0.271860 通过 label 选择还可以多选 123456789In [27]: df.loc[:,['A','B']] #所有行，AB列Out[27]: A B2013-01-01 0.469112 -0.2828632013-01-02 1.212112 -0.1732152013-01-03 -0.861849 -2.1045692013-01-04 0.721555 -0.7067712013-01-05 -0.424972 0.5670202013-01-06 -0.673690 0.113648 注意那个冒号，用法和 MATLAB 或 NumPy 是一样的！所以也可以这样 123456In [28]: df.loc['20130102':'20130104',['A','B']] Out[28]: A B2013-01-02 1.212112 -0.1732152013-01-03 -0.861849 -2.1045692013-01-04 0.721555 -0.706771 12345In [29]: df.loc['20130102',['A','B']]Out[29]: A 1.212112B -0.173215Name: 2013-01-02 00:00:00, dtype: float64 如果对所有的维度都写了标量，不就是选出一个元素吗？ 如果对所有的维度都写了标量，不就是选出一个元素吗？ 12In [30]: df.loc[dates[0],'A']Out[30]: 0.46911229990718628 这种情况通常用 at ，速度更快 12In [31]: df.at[dates[0],'A']Out[31]: 0.46911229990718628 通过整数下标选择这个就和数组类似啦，直接看例子。选出第3行： 1234567In [32]: df.iloc[3]Out[32]: A 0.721555B -0.706771C -1.039575D 0.271860Name: 2013-01-04 00:00:00, dtype: float64 选出3~4行，0~1列： 12345In [33]: df.iloc[3:5,0:2] #注意 3:5 是第3行到第4行（有第0行）Out[33]: A B2013-01-04 0.721555 -0.7067712013-01-05 -0.424972 0.567020 也能用 list 选择 123456In [34]: df.iloc[[1,2,4],[0,2]]Out[34]: A C2013-01-02 1.212112 0.1192092013-01-03 -0.861849 -0.4949292013-01-05 -0.424972 0.276232 对应单个元素 1234In [37]: df.iloc[1,1]Out[37]: -0.17321464905330858In [38]: df.iat[1,1]Out[38]: -0.17321464905330858 总结：df.icol 是按下标选择，df.col是按标签选择。 通过布尔值下标基本用法 123456In [39]: df[df.A &gt; 0]Out[39]: A B C D2013-01-01 0.469112 -0.282863 -1.509059 -1.1356322013-01-02 1.212112 -0.173215 0.119209 -1.0442362013-01-04 0.721555 -0.706771 -1.039575 0.271860 不满足条件的填充为： NaN 123456789In [40]: df[df &gt; 0]Out[40]: A B C D2013-01-01 0.469112 NaN NaN NaN2013-01-02 1.212112 NaN 0.119209 NaN2013-01-03 NaN NaN NaN 1.0718042013-01-04 0.721555 NaN NaN 0.2718602013-01-05 NaN 0.567020 0.276232 NaN2013-01-06 NaN 0.113648 NaN 0.524988 isin() 函数：是否在集合中 12345678910111213141516171819In [41]: df2 = df.copy()In [42]: df2['E'] = ['one', 'one','two','three','four','three']In [43]: df2Out[43]: A B C D E2013-01-01 0.469112 -0.282863 -1.509059 -1.135632 one2013-01-02 1.212112 -0.173215 0.119209 -1.044236 one2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two2013-01-04 0.721555 -0.706771 -1.039575 0.271860 three2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four2013-01-06 -0.673690 0.113648 -1.478427 0.524988 threeIn [44]: df2[df2['E'].isin(['two','four'])]Out[44]: A B C D E2013-01-03 -0.861849 -2.104569 -0.494929 1.071804 two2013-01-05 -0.424972 0.567020 0.276232 -1.087401 four 读取、写入数据CSV写入 1In [136]: df.to_csv('foo.csv') 读取 1234567In [137]: pd.read_csv('foo.csv')In [137]: pd.read_csv(StringIO(data), names=['foo', 'bar', 'baz'], header=None) # 自定义表头，当name设定的时候，header必须显式None，因为默认为0 foo bar baz0 a b c1 1 2 32 4 5 63 7 8 9 table读取 1data = pd.read_table('example.txt',sep='\t',header=0) # 指定分隔符和表头，默认header=0，把第一行作为表头。分割符默认制表符'/t'，'/s+'，可以匹配任何空格。 excel写入 1In [140]: df.to_excel('foo.xlsx', sheet_name='Sheet1') 读取 1In [141]: pd.read_excel('foo.xlsx', sheet_name='Sheet1', index_col=None, na_values=['NA']) #index_col 行名，na_values 缺失值的形式]]></content>
      <categories>
        <category>代码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[next主题设置]]></title>
    <url>%2F2018%2F09%2F01%2Fnext-theme%2F</url>
    <content type="text"><![CDATA[主题风格通过修改next主题下的_config.yml的scheme字段，配置不同的风格。 12345# Schemes#scheme: Musescheme: Mist #推荐#scheme: Pisces#scheme: Gemini 菜单通过修改next主题下的_config.yml的menu字段，选定显示的菜单项。 可自己修改字段和目录名，||之后为配套的小图标。我添加了links字段，但是当前语言是简体中文，页面上无法给我翻译出来，去添加language/zh-CN.yml里的对应字段即可。 1234567menu: home: /home/ || home about: /about/ || user #tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive links: /links/ || calendar 头像在主题下的source/images/下替换原有的头像文件avatar.gif，并在_config.yml中查找Sidebar Avatar字段，添加url字段内容： /images/avatar.gif 头像旋转找到位于 source/css/_common/components/sidebar/sidebar-author.syl 模板文件里侧边栏头像的样式 .site-author-image 将内容修改为 123456.site-author-image &#123; border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; transition: 1.4s all;&#125; 然后添加 .site-author-image:hover 样式，由 rotate() 方法实现，旋转 360° 123456.site-author-image:hover &#123; -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg);&#125; 文章代码主题Next主题总共支持5种主题，默认主题是白色的normal。通过修改next主题下的_config.yml的highlight字段，来设置代码主题。 推荐 night 。 标签、分类在存在标签页、分类页的情况下，在写文章的时候，在文章头部添加 tags、categories 字段。 12tags: [npm, hexo, github]categories: 搭建博客 搜索功能安装 hexo-generator-searchdb 1$ npm install hexo-generator-searchdb --save 在站点myBlog/_config.yml中添加search字段，如下 12345search:path: search.xmlfield: postformat: htmllimit: 10000 修改next主题下的_config.yml的Local search字段 1enable: true hexo博客底部页脚找到/themes/next/layout/_partials/footer.swig文件 内容如下 1234567891011121314151617181920&lt;div class="copyright" &gt; &#123;% set current = date(Date.now(), "YYYY") %&#125; © &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop="copyrightYear"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class="with-love"&gt; &lt;i class="fa fa-heart"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class="powered-by"&gt; &#123;&#123; __('footer.powered', '&lt;a class="theme-link" href="https://hexo.io"&gt;Hexo&lt;/a&gt;') &#125;&#125;&lt;/div&gt;&lt;div class="theme-info"&gt; &#123;&#123; __('footer.theme') &#125;&#125; - &lt;a class="theme-link" href="https://github.com/iissnan/hexo-theme-next"&gt; NexT.&#123;&#123; theme.scheme &#125;&#125; &lt;/a&gt;&lt;/div&gt; 删除class 为powered-by的div和theme-info的div。 github标识在网站上选择一个喜欢的标识类型，复制粘贴代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为个人github地址 。 首页隐藏指定文章有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。 自定义front-matter的参数例如，自定义添加一个notshow参数，值为true，用来提供判断 123tags: [npm, hexo, github]categories: 搭建博客notshow: true 修改主题的themes/next/layout/index.swig文件,将 123456789&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock % 添加过滤条件 1234567891011&#123;% block content %&#125; &lt;section id="posts" class="posts-expand"&gt; &#123;% for post in page.posts %&#125; &#123;% if post.notshow != true %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125; &#123;% endfor %&#125; &lt;/section&gt; &#123;% include '_partials/pagination.swig' %&#125;&#123;% endblock %&#125;]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python-copy]]></title>
    <url>%2F2018%2F08%2F27%2Fpython-copy%2F</url>
    <content type="text"><![CDATA[赋值（assignment）在Python中，用一个变量给另一个变量赋值，其实就是给当前内存中的对象增加一个“标签”而已。 12345&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = a&gt;&gt;&gt; print(id(a), id(b), sep='\n') #a和b都只是[1,2,3]的一个标签139701469405552139701469405552 浅拷贝（shallow copy）注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。 所谓“浅拷贝”，是指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象） 常见的浅拷贝有：切片操作、工厂函数（如list()，dict()等）、对象的copy()方法、copy模块中的copy函数。 12345678910&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = list(a)&gt;&gt;&gt; print(id(a), id(b)) # a和b身份不同140601785066200 140601784764968&gt;&gt;&gt; for x, y in zip(a, b): # 但它们包含的子对象身份相同... print(id(x), id(y))... 140601911441984 140601911441984140601911442016 140601911442016140601911442048 140601911442048 从上面可以明显的看出来，a 浅拷贝得到 b，a 和 b 指向内存中不同的 list 对象，但它们的元素却指向相同的 int 对象。这就是浅拷贝！ 1234567&gt;&gt;&gt; a = [1, 2, 3，[4,5]]&gt;&gt;&gt; b = list(a)&gt;&gt;&gt; a[-1].append(6)&gt;&gt;&gt; print(a)[1, 2, 3，[4,5,6]]&gt;&gt;&gt; print(b) #当a的子对象发生改变时，b也发生了改变[1, 2, 3，[4,5,6]] 深拷贝（deep copy）所谓“深拷贝”，是指创建一个新的对象，然后递归的拷贝原对象所包含的子对象。深拷贝出来的对象与原对象没有任何关联。 深拷贝只有一种方式：copy模块中的deepcopy函数。 12345678&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1, 2, 3，[4,5]]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; a[-1].append(6)&gt;&gt;&gt; print(a)[1, 2, 3，[4,5,6]]&gt;&gt;&gt; print(b) #当a的子对象发生改变时，b不发生改变[1, 2, 3，[4,5]] 1234567891011&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; b = copy.deepcopy(a)&gt;&gt;&gt; print(id(a), id(b))140601785065840 140601785066200&gt;&gt;&gt; for x, y in zip(a, b):... print(id(x), id(y))... 140601911441984 140601911441984140601911442016 140601911442016140601911442048 140601911442048 看了上面的例子，有人可能会疑惑： 为什么使用了深拷贝，a和b中元素的id还是一样呢？ 答：这是因为对于不可变对象，当需要一个新的对象时，python可能会返回已经存在的某个类型和值都一致的对象的引用。而且这种机制并不会影响 a 和 b 的相互独立性，因为当两个元素指向同一个不可变对象时，对其中一个赋值不会影响另外一个。 我们可以用一个包含可变对象的列表来确切地展示“浅拷贝”与“深拷贝”的区别： 1234567891011121314151617181920&gt;&gt;&gt; import copy&gt;&gt;&gt; a = [[1, 2],[5, 6], [8, 9]]&gt;&gt;&gt; b = copy.copy(a) # 浅拷贝得到b&gt;&gt;&gt; c = copy.deepcopy(a) # 深拷贝得到c&gt;&gt;&gt; print(id(a), id(b)) # a 和 b 不同139832578518984 139832578335520&gt;&gt;&gt; for x, y in zip(a, b): # a 和 b 的子对象相同... print(id(x), id(y))... 139832578622816 139832578622816139832578622672 139832578622672139832578623104 139832578623104&gt;&gt;&gt; print(id(a), id(c)) # a 和 c 不同139832578518984 139832578622456&gt;&gt;&gt; for x, y in zip(a, c): # a 和 c 的子对象也不同... print(id(x), id(y))... 139832578622816 139832578621520139832578622672 139832578518912139832578623104 139832578623392 总结：1、赋值：简单地拷贝对象的引用，两个对象的id相同。2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。 浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串(如a=1)以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。]]></content>
      <categories>
        <category>代码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ruby-re]]></title>
    <url>%2F2018%2F08%2F21%2Fruby-re%2F</url>
    <content type="text"><![CDATA[Ruby中正则表达式的写法主要有三种 在//之间，要进行转义 在%r{}内，不用进行转义 Regexp.new()内，不用进行转义 匹配的两种方法 =~肯定匹配, !~否定匹配。=~表达式返回匹配到的位置索引，失败返回nil，符号左右内容可交换 regexp#match(str)，返回MatchData，一个数组，从0开始，还有match.pre_match返回匹配前内容，match.post_match返回匹配后内容 1234/cat/ =~ "dog and cat" #返回8# 类似python可以将正则放入一个变量，如re = Regexp.new(/cat/)，在后续匹配时直接使用remt = /cat/.match("bigcatcomes") # mt = re.match("bigcatcomes")"#&#123;mt.pre_match&#125;-&gt;#&#123;mt[0]&#125;&lt;-#&#123;mt.post_match&#125;" #返回big-&gt;cat&lt;-comes 替换很多时候匹配是为了替换，Ruby中进行正则替换非常简单，两个方法即可搞定，sub()+gsub()。sub只替换第一次匹配，gsub（g:global）会替换所有的匹配，没有匹配到返回原字符串的copy 123str = "ABDADA"new_str = str.sub(/A/, "a") #返回"aBDADA"new_str2 = str.gsub(/A/, "a") #返回"aBDaDa" 分组匹配Ruby的分组匹配与其它语言差别不大，分组匹配表达式是对要进行分组的内容加()。对于匹配到的结果，可以用系统变量$1，$2…索引，也可用matchData数组来索引 123md = /(\d\d):(\d\d)(..)/.match("12:50am") # md为一个MatchData对象puts "Hour is #&#123;$1&#125;, minute #&#123;$2&#125;"puts "Hour is #&#123;md[1]&#125;, minute #&#123;md[2]&#125;" 匹配所有regexp#match()只能匹配一次，如果想匹配所有要用regexp#scan()用法示例： 1"abcabcqwe".scan(%r&#123;abc&#125;).each &#123;|x| puts x&#125; # 输出2行abc]]></content>
      <categories>
        <category>代码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建博客]]></title>
    <url>%2F2018%2F08%2F09%2Fhexo%2Bgithub%2F</url>
    <content type="text"><![CDATA[准备node.js和git node.js : 直接官网下载 git : 直接官网下载 验证安装结果 : 1234$ node -v$ npm -v#npm是随同NodeJS一起安装的包管理工具,类似python的pip$ git --version Github账户注册和新建项目项目必须要遵守格式：uername.github.io，如下： 安装Hexo Hexo 是一个快速、简洁且高效的博客框架。 12345$ mkdir blog &amp;&amp; cd - #创建个人目录$ npm install -g hexo-cli #安装hexo$ hexo -v #检查hexo$ hexo init #初始化hexo$ npm install #安装所需包 Hexo与Github page关联 设置Git的user name和email（如果是第一次的话） 12git config --global user.name "xxx" git用户名git config --global user.email "xxx@xx.com" git邮箱 生成密钥、公钥 1234$ ssh-add -D$ rm -r ~/.ssh #删除存在的密钥、公钥$ ssh-keygen -t rsa -C "xxx@xx.com" #生成新密钥、公钥对应git邮箱$ cat ~/.ssh/id_rsa.pub #查看公钥内容 添加公钥到github 登陆github帐户，点击头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key。然后复制上面的公钥内容，粘贴进“Key”文本域内。 title随便起个名字，点击 Add key完成。 确认成功 1234$ ssh -T xxx@github.com$ git remote -vorigin https://github.com/someaccount/someproject.git (fetch)origin https://github.com/someaccount/someproject.git (push) git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦。 SSH地址 HTTPS地址 在_config.yml 进行基础配置回到创建hexo的文件夹找到_config.yml，并编辑最后的信息: 12345deploy： type： git repository ：git@github.com:flystar233/flystar233.github.io.git #发布不再需要密码 repository ：https://github.com/flystar233/flystar233.github.io.git #发布需要密码 branch ：master 让博客能加载图片12post_asset_folder: true #在_config.yml中将false改为true$ npm install hexo-asset-image --save #在命令行中执行 这样之后，在运行hexo n &quot;xxxx&quot;来生成md博客时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹。将博客所需图片放入此文件夹中，在md文件中（博客内容）插入图片时，使用命令![](xxxx/pic.png)#md插入图片公式 来插入图片，xxxx是文件夹的名字，路径不可有中文。 发布博客在生成以及部署文章之前，需要安装一个扩展： 1$ npm install hexo-deployer-git --save 发布相关命令 123456$ hexo clean # 清除全部文章$ hexo generate == hexo g #生成静态文件$ hexo deploy == hexo d #部署文件到github$ hexo new "文件名" #创建新文章$ hexo new page "页面名" #创建新页面$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server） 查看博客 部署成功后访问博客地址，如：flystar233.github.io]]></content>
      <categories>
        <category>折腾</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[awk]]></title>
    <url>%2F2018%2F08%2F08%2Fawk%2F</url>
    <content type="text"><![CDATA[使用awk 取文件第一列是以数字开头的数据： 1awk '$1~/^[0-9]+/ &#123;print $0&#125;' infile &gt; outfile 使用awk 取文件第一列包含chr或者包含sca： 1awk '$1~/chr|sca/ &#123;print $0&#125;' infile &gt; outfile 使用awk 取文件第一列大于0.1且小于0.5的数据： 1awk '$1&gt;0.1 &amp;&amp; $1&lt;0.5 &#123;print $0&#125;' infile &gt; outfile 使用awk 取文件第一列是chr： 12awk '$1~/^chr$/ &#123;print $0&#125;' infile &gt; outfileawk '$1=="chr" &#123;print $0&#125;' infile &gt; outfile]]></content>
      <categories>
        <category>代码</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[world]]></title>
    <url>%2F2018%2F08%2F07%2Fworld%2F</url>
    <content type="text"><![CDATA[要了解世界的概念就要不断的减少个体的差异性。 我们知道人生而不同，但是要在脑海中形成对世界的认识，就要减少对相同类不同个体的存在，然后逐渐逼近对世界的正确认识。 世界是人在运行的么？不是。人只是世界很小的一个产物，人的主观能动性使人类科技，社会发展，那么人已经拥有可以控制世界的能力了么？小点说，人类已经拥有可以控制地球的能力了么？没有。人类在不断的进步中，还是在顺应自然的变化。 世界是太阳运行的么？不是。太阳为地球所有的生物提供了生存的条件：能量，万物生长，在地球上形成自然环境。那么，太阳会消失么？会的，太阳不断地核聚变产生能量，也在不断的泯灭，终有一天，太阳不在发出光芒，如果人类没有最终造出太阳的替代品，那么地球也将会消失。那么世界不再运行了么？没有。太阳系在已知宇宙中小的就像沧海一粟，一块皮肤老了，掉了也无所谓。 世界是光运行的么？只能说，光是一个必要不充分条件。没有光，世界万物无法生长，世界没有生机，没有了活力，没有了发展的动力。然而，没有光世界还在运行，宇宙深处没有光线，只有天体，他们依然按照旋转规律不停地运动，如果你觉得没有光，怎么知道有天体在动，那你可以做个小小的实验：找一个不透光的长盒子，两端开口，把一个小球扔进去，那么一定会在另一端小球出来。你看见小球在里边的运动了么？没有。你知道小球在动么？知道。 世界根本没有事物在操纵运行，完全是按照无序的规律自我运行的么？不知道，最起码现在不知道。我们不能把一切无法了解的事物归于神。神是什么？在外人解释来说，神就是唯心主义，是精神。谁也没见过神，是神造人？还是人造神？…]]></content>
      <categories>
        <category>文字</category>
      </categories>
  </entry>
</search>
