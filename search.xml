<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>csvtk处理csv和tsv文件</title>
      <link href="/2019/04/16/csvtk/"/>
      <url>/2019/04/16/csvtk/</url>
      
        <content type="html"><![CDATA[<p>处理csv (tsv) 的工具已经见过不少，如csvkit，xsv。而csvtk这个工具的一些子命令却能解决一些前者无法解决的痛点，这些痛点可能需要你自己写脚本。</p><p>软件版本：0.17.0</p><p>地址：<a href="https://github.com/shenwei356/csvtk" target="_blank" rel="noopener">https://github.com/shenwei356/csvtk</a></p><h2 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk headers test.txt  <span class="comment">#显示文件打印标题行，-t参数可设定制表符分割，默认逗号分割</span></span><br></pre></td></tr></table></figure><h2 id="pretty-csv2tab-tab2csv-space2tab-transpose-csv2md"><a href="#pretty-csv2tab-tab2csv-space2tab-transpose-csv2md" class="headerlink" title="pretty csv2tab tab2csv space2tab transpose csv2md"></a>pretty csv2tab tab2csv space2tab transpose csv2md</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk pretty test.txt  <span class="comment">#对csv更友好的展示</span></span><br><span class="line">$ csvtk csv2tab test.txt <span class="comment">#转换csv格式到tab</span></span><br><span class="line">$ csvtk tab2csv test.txt <span class="comment">#转换tab格式到csv</span></span><br><span class="line">$ csvtk space2tab test.txt <span class="comment">#转换空格分割格式到tab</span></span><br><span class="line">$ csvtk transpose test.txt <span class="comment">#转置csv/tsv **</span></span><br><span class="line">$ csvtk csv2md test.txt <span class="comment">#转csv/tsv为makrdown格式</span></span><br></pre></td></tr></table></figure><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk cut -f 1,3-4,7-8 test.txt <span class="comment">#选取1,3到4,7到8列</span></span><br><span class="line">$ csvtk cut -F -f <span class="string">'*.id,name'</span> test.txt <span class="comment"># -F开启模糊搜索</span></span><br><span class="line">$ csvtk cut -f -2,-3 test.txt <span class="comment">#选取第2,3列之外的列</span></span><br></pre></td></tr></table></figure><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk uniq -f 1 test.txt <span class="comment">#最解决痛点的子命令，指定列进行删除重复数据，会保留第一个发现的数据</span></span><br><span class="line"><span class="comment">#linux 自带的uniq会认定整行为一个判断单位，当blast比对中会有很多序列比对到一个序列，而我们只想保留</span></span><br><span class="line"><span class="comment">#第一列的一个字段就好了，这时csvtk uniq 可以轻松处理这个问题。</span></span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk grep -f 1 -p <span class="string">'name'</span> test.txt  <span class="comment">#同uniq一样，grep也可以指定列去搜索（精确搜索）</span></span><br><span class="line">$ csvtk grep -f 1 -p <span class="string">'name'</span> -r test.txt <span class="comment"># -r 开启正则（模糊搜索）</span></span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk join -f <span class="string">'1;1'</span>  test1.csv test2.csv <span class="comment">#按照2个文件的第一列合并文件，等于-f '1'</span></span><br><span class="line">$ csvtk join -f <span class="string">'1;2'</span> test1.csv test2.csv <span class="comment">#按照2个文件的第一列和第二列合并文件</span></span><br><span class="line">csvtk join -f <span class="string">'1;2'</span> --keep-unmatched test1.csv test2.csv <span class="comment">#保留第一个文件中未匹配的行</span></span><br></pre></td></tr></table></figure><h2 id="fliter-filter2"><a href="#fliter-filter2" class="headerlink" title="fliter filter2"></a>fliter filter2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk filter -f <span class="string">'9&gt;1000'</span> test.txt  <span class="comment">#过滤选择第9列大于1000的行</span></span><br><span class="line">$ csvtk filter2 -f <span class="string">'$7 &gt; $8'</span> test.txt <span class="comment">#类似awk过滤</span></span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk replace -f id -p <span class="string">'(\d+)'</span> -r <span class="string">'ID: $1'</span> <span class="comment">#将id列数据(\d+)换为'ID: \d+'</span></span><br><span class="line"></span><br><span class="line">$ cat data.csv</span><br><span class="line"></span><br><span class="line">name    id</span><br><span class="line">A       ID001</span><br><span class="line">B       ID002</span><br><span class="line">C       ID004</span><br><span class="line"></span><br><span class="line">$ cat alias.csv</span><br><span class="line"></span><br><span class="line">001     Tom</span><br><span class="line">002     Bob</span><br><span class="line">003     Jim</span><br><span class="line"></span><br><span class="line">$ csvtk replace  -f 2 -p <span class="string">"ID(.+)"</span> -r <span class="string">"N: &#123;nr&#125;, alias: &#123;kv&#125;"</span> -K -k alias.csv data.csv</span><br><span class="line"></span><br><span class="line">name    id</span><br><span class="line">A       N: 1, <span class="built_in">alias</span>: Tom</span><br><span class="line">B       N: 2, <span class="built_in">alias</span>: Bob</span><br><span class="line">C       N: 3, <span class="built_in">alias</span>: 004</span><br><span class="line"><span class="comment">#使用alias.csv中的键值对进行替换，&#123;nr&#125;代表计数，&#123;kv&#125;代表值，-K代表当键值对中找不到对应的键时使用原文件中的键。-k代表键值对文件</span></span><br></pre></td></tr></table></figure><h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csvtk rename -f 1,2 -n id1,id2 test.txt <span class="comment">#将第1,2列的标题改为id1和id2</span></span><br></pre></td></tr></table></figure><h2 id="mutate2"><a href="#mutate2" class="headerlink" title="mutate2"></a>mutate2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk mutate2  -n <span class="built_in">test</span> -e <span class="string">'$1+$2'</span>  test.txt <span class="comment">#添加新列，-n 新列标题，-e 处理方式（awk模式）</span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ csvtk sort -k 2:n test.txt <span class="comment">#-k 制定排序规则，2:n意义为按第二行排序，并认为数据为数字</span></span><br><span class="line">$ csvtk sort -k 1:N test.txt <span class="comment">#-k 制定排序规则，1:N意义为按第一行排序，并认为数据为字符串与数字混合</span></span><br><span class="line">$ csvtk sort -k 3:n,4:n  test.txt <span class="comment">#按照第三四行排序</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>比对格式问题</title>
      <link href="/2019/04/11/ka-ks/"/>
      <url>/2019/04/11/ka-ks/</url>
      
        <content type="html"><![CDATA[<h2 id="Phylip-格式"><a href="#Phylip-格式" class="headerlink" title="Phylip 格式"></a>Phylip 格式</h2><p>在使 pamlX 的 CodeML 进行 Ka/Ks 计算时，蛋白比对序列需要不含终止密码子且格式为 phylip 格式。如今 phylip 有两种格式：第一种为 Phylip3.2，第二种为 Phylip4。这两种格式具有明显的差别，图示如下：</p><img src="/2019/04/11/ka-ks/p3-p4.png"><p>其中，第一行 Phylip4 是没有 I 标识的，且 Phylip4 格式中是把所有序列的第一行集中起来放置的。在 CodeML 使用中发现只有 Phylip4 可以使用，但是会报错，原因不清楚，但是在 Phylip4 格式文件中第一行也加上 I 标识就可以正常使用了。</p><h2 id="格式转换工具"><a href="#格式转换工具" class="headerlink" title="格式转换工具"></a>格式转换工具</h2><p>序列比对一般有两种方式：在线版和离线版，现在我通常用 <strong>mafft</strong>，mafft 比对完后会默认输出 CLUSTAL 的格式。好用的是他提供了 Reformat 来进行格式转换，基本包含了常用的所有格式。离线的一个 python 包工具为 <strong>seqmagick</strong>，可以进行 fasta 和 phylip，fasta 和 fastq 格式的转换，他还可以使用一个已经比对好的蛋白序列来进行蛋白的 DNA 序列的回比对（具体什么专业名字不清楚），也非常方便。</p>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>shinyCircos使用方法</title>
      <link href="/2019/03/19/shinyCircos/"/>
      <url>/2019/03/19/shinyCircos/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/venyao/shinyCircos" target="_blank" rel="noopener">https://github.com/venyao/shinyCircos</a></p><p>用perl写的circos的学习成本太高了，想看看两个基因组之间的差异（装个逼）怎么还得学习一周？现在我们用shinyCircos解决这个烦恼。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>shinyCircos是个用shiny部署的R应用，所以使用RStudio安装就好了。</p><p>首先先把这些包安装：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"shiny"</span>)  </span><br><span class="line">install.packages(<span class="string">"circlize"</span>)  </span><br><span class="line">install.packages(<span class="string">"RColorBrewer"</span>)</span><br><span class="line">install.packages(<span class="string">"data.table"</span>)</span><br><span class="line">install.packages(<span class="string">"RLumShiny"</span>)  </span><br><span class="line"><span class="comment"># try http:// if https:// URLs are not supported   </span></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)  </span><br><span class="line">biocLite(<span class="string">"GenomicRanges"</span>)</span><br></pre></td></tr></table></figure><p>然后进入项目主页，把整个项目下载下来放在自己硬盘的某个文件夹下并解压（解压后文件名为：shinyCircos-master）。</p><p>回到RStudio，并输入下面的命令，则会自动打开shinyCircos的程序网页。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(shiny)</span><br><span class="line">runApp(<span class="string">"your_dir/shinyCircos-master"</span>, launch.browser = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><img src="/2019/03/19/shinyCircos/shiny.jpg"><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>主页给出了所有文件的示例文件，下载下来对比自己的文件就可以知道需要做出什么改变。</p><h3 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h3><p>主文件包含3列：chr    start    end</p><p>如果是单基因组chr列按照普通染色体命名即可，如果要做多基因组之间的关系，染色体命名要区分开。</p><h3 id="tracks"><a href="#tracks" class="headerlink" title="tracks"></a>tracks</h3><p>tracks文件可以有任意多个，包含有散点图，条形图，折线图，热图等等。</p><p>散点图、折线图、条形图包含4列：chr    start    end    value1</p><p>热图包含：chr start end    value1    value2    value3 ……   valuen</p><h3 id="links-data"><a href="#links-data" class="headerlink" title="links data"></a>links data</h3><p>link data旨在描述染色体位点之间的关系。</p><p>数据包含6列或者7列：chr    start    end    chr    start    end    （color）</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>点击页面的 data upload，在Upload chromosome data下选择本地的染色体文件上传。然后，在Upload data for inner tracks下选择本地的track文件上传，点击后可以选择图的类型（散点，条形等）。最后在Upload data to create links下选择本地的连锁文件上传。点击左下角的Go！即可展示、检查全部上传的文件。</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>点击页面的 Circos viasualization进入画图界面。在Plot options下勾选你所上传的所有文件的名字。选择后会有各种细微的操作调整图画。最后点击左下角的Go！即可展示所做circos图，同时支持PDF,SVG和作图所用R脚本的下载。</p><p>具体实践需要理解各种文件的内容和所做出来的图的外观，相信你在不断的操作中会摸索到其中的方法的。毕竟一个可视化的界面比一个脚本界面舒服的多。</p>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>plink-vcftools</title>
      <link href="/2019/03/01/plink-vcftools/"/>
      <url>/2019/03/01/plink-vcftools/</url>
      
        <content type="html"><![CDATA[<h1 id="bcftools"><a href="#bcftools" class="headerlink" title="bcftools"></a>bcftools</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bgzip view.vcf  <span class="comment">#bgzip压缩</span></span><br><span class="line"></span><br><span class="line">bcftools index view.vcf.gz  <span class="comment">#建立索引</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcftools view view.vcf.gz -s NA00001,NA00002  -o subset.vcf  <span class="comment">#筛选样本</span></span><br><span class="line">bcftools view view.vcf.gz -s ^NA00001,NA00002 -o subset.vcf  <span class="comment"># ^去除样本</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools sort view.vcf.gz -o sort.view.vcf  <span class="comment">#排序vcf</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bcftools reheader -s trans.file sample.vcf -o new.sample.vcf  <span class="comment">#更改vcf文件中样本名</span></span><br><span class="line"></span><br><span class="line">cat trans.file</span><br><span class="line">    NA00001 NA1</span><br><span class="line">    NA00002 NA2</span><br><span class="line">    NA00003 NA3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools concat chr1.vcf.gz chr2.vcf.gz -o concat.vcf  <span class="comment">#合并vcf文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools merge merge.a.vcf.gz merge.b.vcf.gz -o merge.vcf  <span class="comment">#合并vcf文件（单样本多vcf文件）</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcftools stats view.vcf &gt;  view.stats  <span class="comment">#统计vcf文件</span></span><br><span class="line">bcftools filter view.vcf.gz --regions chr16:17052042-17594883 &gt; filter.vcf  <span class="comment">#选择固定区域SNP</span></span><br></pre></td></tr></table></figure><h1 id="vcftools"><a href="#vcftools" class="headerlink" title="vcftools"></a>vcftools</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf myvcf.vcf --plink --out myplink  <span class="comment">#vcf2ped</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf final.vcf --min-alleles 2.0 --max-alleles 2.0 --max-missing 0.95 --non-ref-af 0.05 --max-non-ref-af 0.95 --recode -c &gt;filter.vcf  <span class="comment">#vcf过滤</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf filter.vcf --thin  1000 --recode -c &gt;thin.vcf  <span class="comment">#按snp间隔过滤vcf</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --gzvcf file.vcf.gz --positions specific_position.txt --recode --out specific_position.vcf  <span class="comment">#选择指定SNP</span></span><br></pre></td></tr></table></figure><h1 id="plink"><a href="#plink" class="headerlink" title="plink"></a>plink</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --vcf myvcf.vcf --recode --out myplink  <span class="comment">#vcf2ped</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --file FILENAME --make-bed --out FILENAME  <span class="comment">#ped2bed</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plink --bfile FILENAME --indep-pairwise 50 5 0.5  <span class="comment">#LD-pruning</span></span><br><span class="line">plink --bfile FILENAME --extract plink.prune.in --make-bed --out data_pruned</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink -file FILENAME --recodeHV --out recode  <span class="comment">#haploview</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>gwas</title>
      <link href="/2019/01/04/gwas/"/>
      <url>/2019/01/04/gwas/</url>
      
        <content type="html"><![CDATA[<img src="/2019/01/04/gwas/gwas.jpg"><h2 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h2><p>质量控制是为了去掉在测序过程中低质量的、没有测到的和测序的接头序列。质控软件大同小异，在去除低质量碱基时，最好使用的方法应该是滑动窗口。</p><blockquote><p>因为根据目前的测序原理，read的错误率会明显富集于末端区域，而前半部分的质量都会比较高，这种计算(SOAPnuke按照低质量碱基比例去除序列)比例的方法并不能很好地反映这一现象。</p></blockquote><p>质控同时要注意测序下机数据 fq 文件的质量值格式是Phred33还是Phred64。</p><h2 id="数据比对"><a href="#数据比对" class="headerlink" title="数据比对"></a>数据比对</h2><p>数据比对软件还是最常用的 bwa ，在构建参考序列索引时，is 算法最快(基因组小于1G常用)，而 bwtsw 用于大基因组。</p><p>在 bwa mem算法比对时，<code>-R &#39;@RG\tID:foo_lane\tPL:illumina\tLB:library\tSM:sample_name&#39;</code>  -R参数中的@RG信息要给出，如果没有给出，仍然可以使用 picard 中 AddOrReplaceReadGroups 对 sam 或 bam 文件进行加头处理。这个信息对于我们后续对比对数据进行错误率分析和Mark duplicate时非常重要 。</p><p>另外，samtools 可以利用参考基因组为 sam 或者 bam 文件加上 header 中的 @SQ 信息。</p><h2 id="变异检测"><a href="#变异检测" class="headerlink" title="变异检测"></a>变异检测</h2><p>变异检测核心是使用 GATK 中的HaplotypeCaller 组件进行 snp calling 。而决定变异检测最终结果的好坏则是<strong>Variant quality score recalibration（VQSR）</strong>，其中VQSR中使用VariantFiltration进行硬过滤时，我的参数为：<code>--filterExpression &quot;QD &lt; 2.0 || MQ &lt; 40.0 || ReadPosRankSum &lt; -8.0 || FS &gt; 60.0|| HaplotypeScore &gt; 13.0 || MQRankSum &lt; -12.5&quot;</code></p><p>在获得变异 vcf 文件后将其转为基因型文件后，常常发现有些个体在某些位点上是没有基因型的，这个时候就需要Beagle软件将这些空缺的位点补齐，形成一份完整的变异文件。</p><p>vcf 文件也可以 使用SnpEff， Annovar 这个2个软件进行变异注释，得出每一个变异位点的确切功能。</p><h2 id="个性化分析"><a href="#个性化分析" class="headerlink" title="个性化分析"></a>个性化分析</h2><p>个性化是变异文件内容充分挖掘的过程，是从几百万 snp 位点中挑选出和表型具有显著联系的几个或几十个位点的过程。如果群体结构简单，是单一种群使用简单线性模型(GLM)即可得出良好的结果，如果测序的包含多个群体，或者单群体经过群体结构分析(PCA分析、structrue分析)分群严重，则可以使用混合线性模型(MLM)进行分析，MLM 需要亲缘矩阵(K)和群体结构矩阵(Q)作为协变量建模计算。</p><p>建模计算出结果后便可以使用结果中的P值画曼哈顿图和QQ图，QQ图用来检测结果的正态性，曼哈顿图中阈值一直在讨论和研究中，包括且不限于(Bonferroni校正，sampleM，Keff，SLIDE)方法来确定阈值，一般简单的，使用0.05/snp数作为阈值，如果结果有点差，可以做出图后确定阈值后在阈值上留下1-100个点为好。</p><p>在选出显著性位点后，查看注释文件确定位点的位置、变异、功能等，处于编码区还是非编码区，是否改变氨基酸等。接下来就是找出这些点所处的基因或基因的上下游什么位置。一般以位点的上下游500Kb搜寻，严格的可以以上下游100Kb。</p><p>经过资料、文献的确认接下来就要准确确认基因的信息(所选基因很可能是某个亚家族的一个分支)，方法可以是进化树、domain 分析。</p><h2 id="推荐文献"><a href="#推荐文献" class="headerlink" title="推荐文献"></a>推荐文献</h2><p>质控：</p><p>Sickle: A sliding-window, adaptive, quality-based trimming tool for FastQ files<br>Cutadapt removes adapter sequences from high-throughput sequencing reads</p><p>比对：</p><p>Fast and accurate short read alignment with Burrows–Wheeler transform</p><p>变异检测</p><p>Performance benchmarking of GATK3.8 and GATK4</p><p>A One-Penny Imputed Genome from Next-Generation Reference Panels</p><p>Genotype imputation for genome-wide association studies</p><p>Non-Synonymous and Synonymous Coding SNPs Show Similar Likelihood and Effect Size of Human Disease Association</p><p>个性化分析</p><p>Mixed linear model approach adapted for genome-wide association studies</p><p>The importance of cohort studies in the post-GWAS era</p><p>From genome- wide associations to candidate causal variants by statistical fine- mapping</p>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 工具替换</title>
      <link href="/2019/01/04/linux-tools/"/>
      <url>/2019/01/04/linux-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h2><p>用来代替linux中的grep，使用方法：</p><p><a href="https://github.com/beyondgrep/ack2" target="_blank" rel="noopener">https://github.com/beyondgrep/ack2</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ack text ./ <span class="comment">#在当前目录下所有文件中寻找text存在的行</span></span><br><span class="line">ack text test.py <span class="comment">#在test.py 文件中寻找text存在的行</span></span><br><span class="line">ack -i text test.py <span class="comment">#忽略大小写</span></span><br><span class="line">ack -v text test.py <span class="comment">#寻找没有text存在的行</span></span><br><span class="line">ack -w text test.py <span class="comment">#text必须是一个单词</span></span><br><span class="line">ack -H text test.py <span class="comment">#同时输出文件名和行号</span></span><br><span class="line">ack -m 2 text test.py <span class="comment">#最多输出2个匹配</span></span><br><span class="line">ack -g work <span class="comment">#通过正则表达寻找文件</span></span><br></pre></td></tr></table></figure><img src="/2019/01/04/linux-tools/ack.png"><h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h2><p>fzf 用来进行模糊匹配，超级强大。使用Ctrl+r 反向查看命令历史然后进行模糊搜索快速定位。less |fzf 可以快速查找需要内容。</p><p><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p><p><code>less work1.1.1.py |fzf</code></p><img src="/2019/01/04/linux-tools/fzf.png"><p><code>Ctrl + r</code></p><img src="/2019/01/04/linux-tools/fzf2.png"><h2 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h2><p>progress可以显示系统绝大多数命令的进程。使用 -w 参数预估进程速度和剩余时间。</p><p><a href="https://github.com/Xfennec/progress" target="_blank" rel="noopener">https://github.com/Xfennec/progress</a></p><img src="/2019/01/04/linux-tools/progress.png"><h2 id="ccat"><a href="#ccat" class="headerlink" title="ccat"></a>ccat</h2><p>用来代替系统的cat命令（代码高亮）</p><p><a href="https://github.com/jingweno/ccat" target="_blank" rel="noopener">https://github.com/jingweno/ccat</a></p><img src="/2019/01/04/linux-tools/ccat.png"><h2 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h2><p>ncdu用来代替系统的du命令，使用友好的界面展示储存使用情况。</p><p><a href="https://github.com/rofl0r/ncdu" target="_blank" rel="noopener">https://github.com/rofl0r/ncdu</a></p><p><code>ncdu</code></p><img src="/2019/01/04/linux-tools/ncdu.png"><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>tldr用来代替系统的man命令，相比man是给出一个命令的详细解释，tldr是给出一个命令的常用示例。</p><p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p><img src="/2019/01/04/linux-tools/tldr.png">]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sam文件header全面解析</title>
      <link href="/2018/11/20/sam-header/"/>
      <url>/2018/11/20/sam-header/</url>
      
        <content type="html"><![CDATA[<p>众说周知，最常用的比对软件 bwa 产生的结果文件是 sam 格式，具体格式可以参考 <a href="http://samtools.github.io/hts-specs/SAMv1.pdf" target="_blank" rel="noopener">sam</a> 。</p><p>其中文件的主体便是比对的结果，而头文件往往是我们最容易忽视的地方，尤其踩过太多的坑，特来解释和记录其 header。</p><p>header 中最常见的有3个：@SQ  @RG  @PG  ，@SQ 用来记录参考序列的信息，@RG 用来记录样本的信息，@PG 用来记录 bwa 程序信息。</p><p>@SQ 和 @PG 在 bwa 比对之后就会在 sam 文件中存在。而 @RG 则需要自己在 bwa mem 比对的命令中使用 -R 参数来添加。@RG 这个信息对于我们后续对比对数据进行错误率分析和Mark duplicate时非常重要 。</p><p>如果在 bwa 比对期间没有选择 -R 参数，可以 picard 中 AddOrReplaceReadGroups 对 sam 或bam 文件进行加头处理。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-R '@RG\tID:sample\tLB:sample\tSM:sample\tPL:ILLUMINA'   #bwa mem @RG头格式</span><br><span class="line"></span><br><span class="line">java -jar picard.jar AddOrReplaceReadGroups \   #sam或bam文件（picard ）</span><br><span class="line">      I = input.bam \ </span><br><span class="line">      O = output.bam \ </span><br><span class="line">      RGID = 4 \ </span><br><span class="line">      RGLB = lib1 \ </span><br><span class="line">      RGPL = illumina \ </span><br><span class="line">      RGPU = unit1 \ </span><br><span class="line">      RGSM = 20</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bwa mem -t 4 genome.fa ./samples/A.fastq &gt;A.sam   <span class="comment">#非常普通的SE数据bwa比对</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -n 3 A.sam</span></span><br><span class="line">@SQ     SN:I    LN:230218</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.17-r1188 CL:bwa mem -t 4 genome.fa -R </span><br><span class="line">SRR800764.1     4       *       0       0       *       *       0       0       CATCTTTGGAGTAACTATTATTTCGCCCCTTTTGTTTGCTGCATATCGCCCCGCTCTCTGCATACACGATTGGATAATGACCAAAGCAAGGTTTAATACGC…………   #关键看头文件，后面比对信息省略</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -Sb A.sam &gt; A.bam   <span class="comment">#转为bam文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools sort  A.bam &gt; A_sort.bam   <span class="comment">#排序</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -h A_sort.bam &gt; A_sort.sam   <span class="comment">#再转回来sam文件，一定要加-h参数，默认是不输出header的。如果没有-h参数，是无法对sam文件进行转换和排序的。如下：</span></span></span><br><span class="line">[E::sam_parse1] missing SAM header</span><br><span class="line">[W::sam_read1] parse error at line 1</span><br><span class="line">[main_samview] truncated file.</span><br></pre></td></tr></table></figure><p>上面提到在缺少头文件的前提下是无法将 sam 转为 bam 的，更加无进行 bam 文件排序。但是如果我们使用 picard 这个问题就可以解决了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx5g -Djava.io.tmpdir=./tmp -jar ../picard-tools-1.117/SortSam.jar INPUT=A_sort.sam OUTPUT=A_sort.bam SORT_ORDER=coordinate VALIDATION_STRINGENCY=SILENT</span><br></pre></td></tr></table></figure><p>picard 的 SortSam.jar 可以直接对没有 header 的 sam 文件排序并转为 bam 文件。</p><p>另外，samtools 可以为sam或者bam文件加上 header 中的 @SQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samtools view -Sb -T genome.fa sample_no_header.sam &gt;sample_with_header.bam  #使用 -T 参考序列加header（@SQ）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水产育种中的基因组选择（翻译）(二)</title>
      <link href="/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/"/>
      <url>/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/</url>
      
        <content type="html"><![CDATA[<h2 id="一个实现基因组预测的实例"><a href="#一个实现基因组预测的实例" class="headerlink" title="一个实现基因组预测的实例"></a>一个实现基因组预测的实例</h2><p>如上一节所述，许多方法已被用于基因组预测。这里，将使用R包<code>rrBLUP</code>展示实现基因组预测的示例 (Endelman, 2011)。在演示中，将使用另一个R包<code>BLR</code>中的599个小麦品系的数据集，这些小麦系在1279个DArT标记上进行基因分型。如果你是语言新手，有许多在线资源可用于获取R的基本介绍 (Torfs &amp; Brauer, 2014; Venables, Smith &amp; R Development Core Team, 2016)。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">'rrBLUP'</span>)</span><br><span class="line">install.packages(<span class="string">'BLR'</span>)</span><br><span class="line"><span class="keyword">library</span>(BLR)</span><br><span class="line"><span class="keyword">library</span>(rrBLUP)</span><br><span class="line"></span><br><span class="line">rm(list=ls())</span><br><span class="line">set.seed(<span class="number">99</span>)  <span class="comment">#设置随机数</span></span><br><span class="line">data(wheat)  <span class="comment">#载入小麦数据</span></span><br><span class="line"><span class="comment">############################################### marker-based</span></span><br><span class="line">M &lt;- <span class="number">2</span>∗X-<span class="number">1</span>  <span class="comment">#将标记转换为&#123;−1，1&#125;</span></span><br><span class="line">pheno &lt;-Y[,<span class="number">1</span>]  <span class="comment">#取第一列表型数据</span></span><br><span class="line">geno &lt;- M   <span class="comment">#取基因型数据</span></span><br><span class="line">whichTest&lt;-sample(<span class="number">1</span>:length(pheno),<span class="number">100</span>)   <span class="comment">#随机取出100个样本表型数据的编号</span></span><br><span class="line">phenoTrain &lt;- pheno[-whichTest]   <span class="comment">#取出训练集表型数据</span></span><br><span class="line">phenoTest &lt;- pheno[whichTest]     <span class="comment">#取出测试集表型数据</span></span><br><span class="line">GenoTrain &lt;- as.matrix(geno[-whichTest, ])   <span class="comment">#取出训练集基因型数据</span></span><br><span class="line">genoTest &lt;- as.matrix(geno[whichTest, ])     <span class="comment">##取出测试集基因型数据</span></span><br><span class="line">markerEffects &lt;- mixed.solve(y=phenoTrain, Z=GenoTrain)$u   <span class="comment">#计算位点效应</span></span><br><span class="line">predictedGBV &lt;- genoTest%∗%markerEffects    <span class="comment">#计算育种值</span></span><br><span class="line">(predictionAcc &lt;- cor(predictedGBV, phenoTest))   <span class="comment">#计算育种精确度</span></span><br><span class="line"><span class="comment"># 0.5370625</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################### kinship-based</span></span><br><span class="line">A1 &lt;-A.mat(M)   <span class="comment">#计算基因组关联矩阵</span></span><br><span class="line">rownames(A1) &lt;- <span class="number">1</span>:length(pheno)   <span class="comment">#替换A1矩阵行名</span></span><br><span class="line">yNA=pheno   <span class="comment">#取出表型</span></span><br><span class="line">yNA[whichTest] &lt;- <span class="literal">NA</span>   <span class="comment">#将测试集表型删除</span></span><br><span class="line">data1 &lt;-data.frame(y=yNA,gid=<span class="number">1</span>:length(pheno))   <span class="comment">#构建列表</span></span><br><span class="line">ans1 &lt;- kin.blup(data1,K=A1,geno=<span class="string">"gid"</span>,pheno=<span class="string">"y"</span>)   <span class="comment">#计算育种结果</span></span><br><span class="line">(cor(ans1$g[whichTest],Y[whichTest,<span class="number">1</span>]))   <span class="comment">#计算育种精确度</span></span><br><span class="line"><span class="comment"># 0.5370625</span></span><br></pre></td></tr></table></figure><h2 id="GS的几个重要考虑"><a href="#GS的几个重要考虑" class="headerlink" title="GS的几个重要考虑"></a>GS的几个重要考虑</h2><h3 id="需要多少动物进行基因分型？"><a href="#需要多少动物进行基因分型？" class="headerlink" title="需要多少动物进行基因分型？"></a>需要多少动物进行基因分型？</h3><p>GS 的准确性对与育种成功至关重要，它本身就是动植物育种的一个重要研究领域。除了选择统计模型外，GS 的准确性还取决于许多相互关联的因素，即基因组大小，标记密度，标记与 QTL之间的 LD，QTL 效应的数量和大小，有效群体大小，训练集的大小，训练与测试集动物的关系和性状遗传力。为了达到所需的精确度，训练集的动物数量主要取决于性状的遗传力估计和种群的有效规模。 (Ne) (Figure 2)。较低的遗传力估计将需要一个更大的训练集，同时，较大的Ne也需要相应的更大的训练样本。通常，更多的训练样本将为候选样本提供更准确的预测。例如， 荷斯坦奶牛需要有基因型和表型记录的3000-10000头公牛参考种群才能有0.7的基因组选择精确度。</p><img src="/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/number.png"><p>​        <strong>Figure 2</strong> 参考种群中所需的动物数量，以便为估计的GBV精确性达到0.7(Goddard &amp; Hayes, 2009)</p><h3 id="多少SNP位点才足够？"><a href="#多少SNP位点才足够？" class="headerlink" title="多少SNP位点才足够？"></a>多少SNP位点才足够？</h3><p>snp位点应该覆盖整个基因组，并且要有足够的密度以确保大多数QTL都在LD中，需要至少有一个标记在LD区间，因此，对标记效应的估计可以捕捉到最大的遗传变异。所需SNP的总数主要取决于基因组大小和基因组的LD范围。通常，相邻SNP标记之间的LD的 <code>r2 &gt;0.2</code> ，那SNP将会足够(Calus et al., 2008)。</p><p>在实践中，50 K SNP 为奶牛品种提供了较好的预测精度。将密度从50 K进一步增加到800 K，只会略微增加预测精度 (Khatkar et al., 2012)。然而，如果训练集和测试集动物是相关的，基因组关联矩阵（GRM）可用于使用 gBLUP 预测 GBV。GRM 可以用一个很小的 SNP 集精确地计算出来。</p><p>用中等密度 SNP 芯片进行基因分型的成本(例如，牛的50 K SNP芯片)大约是每一个 DNA 样本40到100美元。基因分型和测序的成本正在迅速下降，使这项技术应用于更多物种，成本效益更高。此外，基因型估算可以有效地提高基因型数据的密度，降低成本。基因型估算包括用高密度 SNP 集对一小部分群体进行基因分型，并用低成本、低密度 SNP 位点预测其他群体的高密度基因型，这些经过计算模拟的基因型虽然不是太准确，但是还可以用于 GS (Khatkar et al., 2012)。</p><h3 id="对基因组预测来说，最重要的因素是样本数还是SNPs数？"><a href="#对基因组预测来说，最重要的因素是样本数还是SNPs数？" class="headerlink" title="对基因组预测来说，最重要的因素是样本数还是SNPs数？"></a>对基因组预测来说，最重要的因素是样本数还是SNPs数？</h3><p>更多的记录和更紧密的标记间距提高了准确性。但是，当 SNP 的密度很小时（小于1000个SNPs），在训练集中增加更多的动物对于提高基因组预测的准确性变得更加重要。</p><h3 id="是否有可能预测不同品种-群体？"><a href="#是否有可能预测不同品种-群体？" class="headerlink" title="是否有可能预测不同品种/群体？"></a>是否有可能预测不同品种/群体？</h3><p>是否有可能预测不同品种/群体—也就是说，使用一个品种的训练动物为另一个品种做预测。GS已成功地应用于群体内育种值的预测。然而，GS 在杂交预测中的成功是有限的。例如，当计算不属于训练组的品种的基因组预测时，精确度接近于零，或非常低 (Kachman et al., 2013)。在这种情况下，使用几个具有中/大效应的 SNP 并采用贝叶斯方法可能会有帮助，因为这可能只包括那些跨品系/品种分离的 QTL。</p><h3 id="我们需要有关基因和基因功能的知识吗？"><a href="#我们需要有关基因和基因功能的知识吗？" class="headerlink" title="我们需要有关基因和基因功能的知识吗？"></a>我们需要有关基因和基因功能的知识吗？</h3><p>在实践中，大多数GS方法主要使用(非线性)线性模型估计的 SNP 效应，或者仅仅使用 GRM，因此它们没有利用基因、基因功能的特定知识，甚至没有基因组中的SNPs的精确定位。</p><h3 id="准确性会随着世代下降吗？"><a href="#准确性会随着世代下降吗？" class="headerlink" title="准确性会随着世代下降吗？"></a>准确性会随着世代下降吗？</h3><p>一般，基因组选择中GBVs的预测是利用标记与数量性状位点（QTL）之间的 LD 来实现的。然而，在实践中，尤其是在种内预测，基因组预测的可靠性取决于候选/测试中动物与训练/参考动物之间遗传关系的强弱。因此，当应用于下一代时，来自固定训练集的预测方程的精度会迅速下降。这通常意味着预测方程需要通过添加来自更近几代的动物来更新。</p><h3 id="使用GS会增加近亲繁殖吗？"><a href="#使用GS会增加近亲繁殖吗？" class="headerlink" title="使用GS会增加近亲繁殖吗？"></a>使用GS会增加近亲繁殖吗？</h3><p>较短的世代间隔和较高的选择强度将使近交系的年率提高。特别是在选择的标记附近近亲繁殖。这将需要在管理种群近亲繁殖方面给予更多的关注。利用基因组关系信息进行仔细的交配选择，如最小同祖先交配和最优贡献选择，可以控制近交系。</p><h2 id="水产养殖中的基因组选择"><a href="#水产养殖中的基因组选择" class="headerlink" title="水产养殖中的基因组选择"></a>水产养殖中的基因组选择</h2><p>水产养殖物种繁多，由于生命周期、繁殖力、有效种群规模和育种目标的不同，GS 在水产养殖中的潜力将因品种不同而有所不同。目前，以水产养殖品种最多的传统养殖项目主要采用群体选择和家系选择两种方式。同胞系测试是针对那些不能直接在候选样本上测量的性状进行的(例如，在生命后期或屠宰时记录到的性状、抗病性)。以家系为基础的选择只使用了一小部分(一半)的遗传变异，并导致近亲育种的增加。GS 还可以预测家族内部的遗传差异，因此可以利用所有的遗传变异。由于只使用很少的动物/家系而导致近亲繁殖的增加是水产养殖中的一个主要问题。此外，在传统的选择方案中，个体的标记、谱系的记录和单独家系的饲养也是困难和昂贵的。遗传标记的信息可以帮助应对其中的一些挑战。随着测序和基因分型成本的降低，遗传标记和 GS 在水产养殖中的应用越来越受到人们的重视。然而，SNP 集的开发和基因组资源的应用直到最近才在几个水产养殖物种中进行，以此，在实际 GS 实施结果的信息是不全面的。已发表的报告主要是基于 GS 使用模拟数据的效率。所有的模拟研究表明，使用 GS 来进行水产养殖育种可以提高在生产(连续型)和疾病(二分型)位点的选择和遗传增益的准确性。(Sonesson &amp; Meuwissen, 2009)；(Nielsen, Sonesson &amp; Meuwissen, 2011)； (Lillehammer,Meuwissen &amp; Sonesson, 2013)，与传统的同胞系检测相比，近亲繁殖减少了81%(Sonesson &amp; Meuwissen, 2009)。通过结合传统的 BLUP 家系育种值和基于低密度基因分型而不影响遗传增益的家系内育种值，也可以降低基因分型的成本(Lillehammer et al., 2013)。</p><p>尽管基因分型和测序成本下降，由于大量样本的养殖和基因分型，基因组选择策略仍然需要很多的成本。然而，部分额外成本可以从增加的遗传收益中弥补而且与传统的选择方案相比，对同胞系样本测试的依赖更少。大多数水产养殖物种中个体动物的价值一般较低（与牛相比）。然而，由于大多数水产养殖物种的繁殖力很高，遗传增益的影响因遗传收益从繁殖核心立即转移到商业池塘而扩大。然而，利用GS优化育种方案还需要进一步的研究，比如在训练和选择中确定最佳的动物数量，标记密度，最小化近亲繁殖最大化长期遗传收益，与传统方案的比较的经济分析。GS 除了用于性状外，遗传标记在水产养殖中还可以提供比传统方法更多的优势，例如，性别相关标记的使用可以生产单性别的后代(Robinson et al., 2014)；基因渗入可以用来在种群中引入理想的基因，例如，通过反复回交和标记辅助选择，将对特定疾病的抗性从本地菌株转移到商品菌株(Odegard et al., 2009)；标记可用于监测和繁殖来自群体的任何有害突变；遗传物质的可操纵性来保护育种者。</p><p>总之，随着基因组技术的快速发展和基因组信息获取成本的不断降低，全基因组选择在提高盈利能力和在个体数增加依旧保持遗传变异性的同时，对提高水产养殖品种的食品生产水平具有很大的潜力。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>十分感谢 Dr. Gerhard Moser 对此手稿的建议。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Calus, M.P., Meuwissen, T.H., de Roos, A.P. and Veerkamp, R.F. (2008) Accuracy of genomic selection using different methods to define haplotypes. Genetics, 178,553–561.<br>de Los Campos, G., Hickey, J.M., Pong-Wong, R. et al. (2013) Whole-genome regression and prediction methods applied to plant and animal breeding. Genetics, 193, 327–345.<br>de Los Campos, G., Naya, H., Gianola, D. et al. (2009) Predicting quantitative traits with regression models for dense molecular markers and pedigree. Genetics, 182, 375–385.<br>Endelman, J.B. (2011) Ridge regression and other kernels for genomic selection with R package rrBLUP. Plant Genome, 4, 250–255.<br>Erbe, M., Hayes, B.J., Matukumalli, L.K. et al. (2012) Improving accuracy of genomic predictions within and between dairy cattle breeds with imputed high-density single<br>nucleotide polymorphism panels. Journal of Dairy Science, 95, 4114–4129.<br>Falconer, D.S. and Mackay, T.F.C. (1996) Introduction to quantitative genetics, 4th edn, Longman, Essex, UK.<br>Gianola, D. and van Kaam, J.B. (2008) Reproducing kernel Hilbert spaces regression methods for genomic assisted prediction of quantitative traits. Genetics, 178,2289–2303.<br>Goddard, M.E. and Hayes, B.J. (2009) Mapping genes for complex traits in domestic animals and their use in breeding programmes. Nature Reviews Genetics, 10, 381–391.<br>Gonzalez-Camacho, J.M., de Los Campos, G., Perez, P. et al. (2012) Genome-enabled prediction of genetic values using radial basis function neural networks. Theoretical and Applied Genetics, 125, 759–771.<br>Gonzalez-Recio, O., Weigel, K.A., Gianola, D. et al. (2010) L2-Boosting algorithm applied to high-dimensional problems in genomic selection. Genetics Research (Cambridge), 92,227–237.<br>Habier, D., Fernando, R.L. and Dekkers, J.C. (2007) The impact of genetic relationship information on genome-assisted breeding values. Genetics, 177, 2389–2397</p><p>Habier, D., Fernando, R.L., Kizilkaya, K. and Garrick, D.J. (2011) Extension of the Bayesian alphabet for genomic selection. BMC Bioinformatics, 12, 186.</p><p>Heslot, N., Yang, H.P., Sorrells, M.E. and Jannink, J.L. (2012) Genomic selection in plant breeding: a comparison of models. Crop Science, 52 (1), 146–160.</p><p>Jannink, J.L., Lorenz, A.J. and Iwata, H. (2010) Genomic selection in plant breeding: from theory to practice. Briefings in Functional Genomics, 9, 166–177.<br>Kachman, S.D., Spangler, M.L., Bennett, G.L. et al. (2013) Comparison of molecular breeding values based on within- and across-breed training in beef cattle. Genetics Selection Evolution, 45, 30.<br>Khatkar, M.S., Moser, G., Hayes, B.J. and Raadsma, H.W. (2012) Strategies and utility of imputed SNP genotypes for genomic analysis in dairy cattle. BMC Genomics, 13, 538.<br>Khatkar, M.S., Zenger, K.R., Hobbs, M. et al. (2007) A primary assembly of a bovine haplotype block map based on a 15,036-single-nucleotide polymorphism panel genotyped in Holstein-Friesian cattle. Genetics, 176, 763–772.<br>Lillehammer, M., Meuwissen, T.H. and Sonesson, A.K. (2013) A low-marker density implementation of genomic selection in aquaculture using within-family genomic breeding values. Genetics Selection Evolution, 45, 39.<br>Maenhout, S., De Baets, B. and Haesaert, G. (2010) Prediction of maize single-cross hybrid performance: support vector machine regression versus best linear prediction. Theoretical and Applied Genetics, 120, 415–427.<br>Meuwissen, T.H., Hayes, B.J. and Goddard, M.E. (2001) Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157, 1819–1829.<br>Moser, G., Tier, B., Crump, R.E. et al. (2009) A comparison of five methods to predictgenomic breeding values of dairy bulls from genome-wide SNP markers. Genetics Selection Evolution, 41, 56.<br>Nejati-Javaremi, A., Smith, C. and Gibson, J.P. (1997) Effect of total allelic relationship on accuracy of evaluation and response to selection. Journal of Animal Science, 75,1738–1745.<br>Nielsen, H.M., Sonesson, A.K. and Meuwissen, T.H. (2011) Optimum contribution selection using traditional best linear unbiased prediction and genomic breeding values in aquaculture breeding schemes. Journal of Animal Science, 89, 630–638.<br>Odegard, J., Yazdi, M.H., Sonesson, A.K. and Meuwissen, T.H. (2009) Incorporating desirable genetic characteristics from an inferior into a superior population using genomic selection. Genetics, 181, 737–745.<br>Ogutu, J.O., Piepho, H.P. and Schulz-Streeck, T. (2011) A comparison of random forests, boosting and support vector machines for genomic selection. BMC Proceedings, 5 (3), S11.<br>Pryce, J.E., Goddard, M.E., Raadsma, H.W. and Hayes, B.J. (2010) Deterministic models of breeding scheme designs that incorporate genomic selection. Journal of Dairy Science,93, 5455–5466.<br>Robinson, N.A., Gopikrishna, G., Baranski, M. et al. (2014) QTL for white spot syndrome virus resistance and the sex-determining locus in the Indian black tiger shrimp (Penaeus monodon). BMC Genomics, 15, 731.<br>Schaeffer, L.R. (2006) Strategy for applying genome-wide selection in dairy cattle. Journal of Animal Breeding and Genetics, 123, 218–223.<br>Sonesson, A.K. and Meuwissen, T.H.E. (2009) Testing strategies for genomic selection in aquaculture breeding programs. Genetics Selection Evolution, 41, 1.</p><p>Torfs, P. and Brauer, C. (2014). “A (very) short introduction to R,” Hydrology and Quantitative Water Management Group, Wageningen University, The Netherlands,available at <a href="https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf" target="_blank" rel="noopener">https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf</a></p><p>Tsai, H.Y., Hamilton, A., Tinch, A.E. et al. (2015) Genome wide association and genomic prediction for growth traits in juvenile farmed Atlantic salmon using a high density SNP array. BMC Genomics, 16, 969.<br>VanRaden, P.M. (2008) Efficient methods to compute genomic predictions. Journal of Dairy Science, 91，4414–4423.<br>VanRaden, P.M., Van Tassell, C.P., Wiggans, G.R. et al. (2009) Invited review: reliability of genomic predictions for North American Holstein bulls. Journal of Dairy Science, 92,16–24.<br>Vazquez, A.I., de los Campos, G., Klimentidis, Y.C. et al. (2012) A comprehensive genetic approach for improving prediction of skin cancer risk in humans. Genetics, 192,1493–1502.<br>Venables, W.N., Smith, D.M. and the R Core Team. (2016). An introduction to R.<br>Notes on R: A programming environment for data analysis and graphics. Version 3.2.4 (2016-03-10) Available: <a href="https://cran.r-project.org/doc/manuals/R-intro.pdf" target="_blank" rel="noopener">https://cran.r-project.org/doc/manuals/R-intro.pdf</a>. Accessed 15 April 2016.</p>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水产育种中的基因组选择（翻译）(一)</title>
      <link href="/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/"/>
      <url>/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/</url>
      
        <content type="html"><![CDATA[<p>​                                                                                                                                                 作者：Mehar S. Khatkar </p><p>​                                                                                                                                                 翻译：轩暮</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>基因组选择最初在2001年被提出，如今已经在家畜中广泛应用。但是迄今为止在水产物种中的应用却十分受限。在这一章我们介绍了基因组选择的基本原理，并给出如何进行基因组选择的示例，在结尾提出了一些对水产物种的看法。</p><p>最新研究的分子技术为获得成千上万的遗传标记提供了可能（典型的标记 SNPs），即使在没有基因组组装或遗传图谱的物种中也是如此。基因分型和测序的成本不断下降，使得在许多水产物种中使用这些工具成为可能。来自家系或非家系群体的基因型数据可以提供对种群结构、基因关联和选择育种信息的见解。事实上，随着分子数据的容易获得性，就不再需要记录家系信息，这可以大大简化育种计划，特别是在水产物种中。本章首先介绍了基因组选择的概念，即遗传标记在选择育种中的应用，然后介绍了遗传标记在水产育种中的应用前景。</p><h2 id="基因组选择"><a href="#基因组选择" class="headerlink" title="基因组选择"></a>基因组选择</h2><p>分子标记在动物育种中的应用已经有很长一段时间了。然而，直到近些年可以大量地获得全基因组的分子标记，才使得使用DNA检测来直接预测动物的育种特性成为可能。通过模拟， Meuwissen,Hayes, and Goddard (2001)表明动物的遗传值可以不使用其表型或家系信息，只使用在染色体上高密度标记的基因型被准确地估计出来。在这种方法中，最著名的就是基因组选择（genomic selection，GS）或称为全基因组选择（whole genome selection），选择决定是根据基因组育种值(GBVs)作出的，基因组育种值一般使用高密度标记（SNPs）计算得出。基因组选择依赖于如下假设：全基因组标记的密度足够高、至少一个数量性状位点处于高度连锁不平衡区间。整个基因组标记效应的估计将为某一个性状的遗传价值提供准确的预测。</p><p>基因组选择的实现非常简单。它使用“训练群体”（多个个体样本）来建立预测方程，该群体既有基因型也有表型。然后，将此方程应用于“测试群体”（另外多个个体样本）的基因型，以计算分子或基因组的育种值(GBVs)。使用育种值排序和选择样本来作为下一代的父母本。（Figure 1）如果需要，可以再使用传统的估计育种值(EBVs)来生成基因组估计育种值(GEBV)。</p><img src="/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/GS.png"><p>​                                          <strong>Figure 1</strong> 基因组选择概述（改编自Goddard &amp; Hayes, 2009）</p><p>与传统育种方案相比，基因组选择可以提高遗传增益率，因为它可以大幅缩短世代间隔和增加选择强度(Schaeffer, 2006)。例如，绵羊和奶牛的遗传改良率分别提高了25%和100%。基因组选择对于昂贵且难以测定表型的性状尤其有吸引力，这些性状仅以是否死亡来衡量，或在生命后期表达出来(Pryce et al., 2010)。基因组选择可能会增加难以记录性状的遗传增益，例如水产养殖和家禽品种的抗病性，猪的肉质和绵羊一生的羊毛产量及抗虫性。基因组选择技术被认为是动植物育种计划中的一个巨大里程碑。在家畜中，SNP 芯片首次应用在牛中(Khatkar et al., 2007)，这使得基因组选择首次成功地应用于奶牛(Moser et al., 2009)；(VanRaden et al., 2009)。基因组选择已经取代了许多国家的后裔测定方法，或者正应用于后裔测定的幼年公牛预选。目前，基因组选择正被应用于许多其他动植物物种中(Goddard &amp; Hayes,2009)，都具有不同程度的成功。基因组预测的原理甚至在人类研究中得到了应用，特别是对于高危人群的识别进行了最佳干预和个性化治疗。例如，一种基因组预测方法被用来预测人类患皮肤癌的可能性，并取得了很好的结果(Vazquez et al., 2012)。然而，应该注意到在使用“基因组选择”和“基因组预测”这两个术语方面的区别。“基因组选择”已被用于动物育种计划，这包括通过基因组预测鉴定遗传优越的动物选择和选择动物交配以生产下一代。相比之下，“基因组预测”只涉及从基因组信息中预测个体的遗传值，并且更适合于人类研究。</p><h2 id="基因组选择的步骤"><a href="#基因组选择的步骤" class="headerlink" title="基因组选择的步骤"></a>基因组选择的步骤</h2><p>图 1 已经概述了基因组选择，包括以下主要步骤。</p><h3 id="参考群体的准备"><a href="#参考群体的准备" class="headerlink" title="参考群体的准备"></a>参考群体的准备</h3><p>构建参考种群需要大量的动物样本。这些动物被用来测定所感兴趣的性状，并对基因组范围的标记进行基因分型，通常使用 snp 芯片来获得大量的 snp 标记。为了进行统计分析，SNP 基因型通常编码为数值变量，取值为0、1或2，分别对应于一个纯合子、杂合子、另一个纯合子。参考群体通常分为训练集和验证集。</p><h3 id="预测方程"><a href="#预测方程" class="headerlink" title="预测方程"></a>预测方程</h3><p>每个 SNP 标记（编码为0，1和2，一个等位基因的数目或拷贝）效果估计(W)的训练结果统计分析以及所有标记的基因型效应联合生成一个预测方程来估计每种动物的育种值。</p><p>​                    <strong>GBV = w1∗ SNP1 + w2∗ SNP2 + w3∗ SNP3 +…+ Wn∗ SNPn</strong></p><p>w是偏回归系数或称为某个SNP的效应值大小，SNP是基因型（数值型）的载体。</p><p>下节提到的许多分析方法的其中一种可以用来建立这样的方程。</p><h3 id="预测方程的验证"><a href="#预测方程的验证" class="headerlink" title="预测方程的验证"></a>预测方程的验证</h3><p>验证集中的动物也有基因型和表型的数据。将上述预测方程应用于验证集动物的基因型，用以估计 GBVs。预测方程的准确性是通过将估计的 GBVs 值与实际的表型信息进行比较来评估的。连续性状的预测精度可以用性状的预测值和实际值的方差或相关系数来衡量。此步骤是可选的，但提供了关于基因组选择准确性的重要信息，因此建议进行。</p><h3 id="测试集个体育种值的计算"><a href="#测试集个体育种值的计算" class="headerlink" title="测试集个体育种值的计算"></a>测试集个体育种值的计算</h3><p>测试集个体只需有基因型，不需要表型信息。将预测方程应用于这些动物的基因型计算中。</p><h3 id="选择与交配"><a href="#选择与交配" class="headerlink" title="选择与交配"></a>选择与交配</h3><p>测试集个体根据GBVs进行排序，而排在顶端的动物则被挑选和交配来生产下一代。</p><h2 id="基因组预测模型"><a href="#基因组预测模型" class="headerlink" title="基因组预测模型"></a>基因组预测模型</h2><p>几种分析方法已被应用于全基因组的遗传优势预测。可大致分为三大类：</p><ol><li>回归方法：基因组选择最简单的形式就是估计每个标记或者数量性状位点（QTL）的效应，然后对每个个体在基因组中的所有位点进行总结。这必须假定有效应的标记处于 LD 区间或者他们本身就是 QTL 位点，而且大部分的遗传变异都是可加的。然而，在使用高密度 SNP 集情况下，标记的数量（p）远大于在训练集中做训练的动物数量（n）。这使得使用简单回归模型估计所有标记的效应具有挑战性。为了解决这个大 p 与小 n 回归问题，提出几种变量选择和收缩估计方法来解决具表型的全基因组预测。Meuwissen et al. (2001)提出三种方法：<code>BLUP (rrBLUP)</code>，<code>Bayes A</code> 和 <code>Bayes B</code> 可以在预测模型中容纳大量的遗传标记。这些方法和其他后续贝叶斯方法：<code>Bayes C𝜋</code> (Habier et al.， 2011)，<code>Bayesian LASSO</code> (de Los Campos et al.， 2009)， <code>Bayes-R</code> (Erbe et al.，2012) 的不同之处在于SNP/QTL效应的先验分布的定义。关于这些办法的详细介绍和比较，请看 de Los Campos et al. (2013)。偏最小二乘回归 (PLSR) 和主成分回归（PC）通过计算隐变量来降维从而进行预测。(Jannink,，Lorenz &amp; Iwata，2010；Moser et al.，2009)。</li><li>基因组关系法：基因组关系法也被称为“gBLUP”。在此方法中，需要计算个体间的基因组关系矩阵(GRM)。然后使用 GRM 计算所有动物的育种值。这种方法与传统的“动物模型”是等价的，主要的区别在于用 GRM 替换基于家系的关系矩阵。同样的模型可以用来估计方差分量和遗传参数。这个框架可以很容易地扩展到多重性状的分析中。这在水产养殖中的应用是非常具有吸引力的，因为水产养殖记录家系信息是非常困难和昂贵的，而 gBLUP 不需要记录谱系信息直接应用于育种。GRM 是基于实际的基因组相似性估计实际亲缘关系。因此，与基于家系的预期关系相比它更准确。比如，减数分裂时染色体的随机分离会导致全同胞家系样本间实际基因组相似性的变化 (Nejati-Javaremi, Smith &amp; Gibson, 1997)。GRM 可以从标记的基因型矩阵构建。VanRaden (2008) 描述了3种构建 GRM 的方法并评价了它们的实际表现。</li><li>半参数和机器学习方法：在大多数实践应用中，GBVs只包括加性效应(传递给下一代遗传优势)。然而，在一些育种计划中，发掘显性基因和上位效应会是可取的。例如，通过选配和杂种优势生产具有最高遗传价值的(杂交)后代 (Falconer &amp; Mackay, 1996)。Gianola and van Kaam (2008) 提出非参数方法可以在不显式建模的情况下解释复杂的上位性效应。基因组选择的半参数和非参数程序，如再生核希尔伯特空间 (Gianola &amp; van Kaam, 2008)，径向基函数神经网络(Gonzalez-Camacho et al., 2012)，支持向量机(SVM) (Maenhout,DeBaets &amp; Haesaert, 2010; Moser et al., 2009)，惩罚支持向量机 ，随机森林(Ogutu, Piepho &amp; Schulz-Streeck, 2011)，boosting (Gonzalez-Recio et al.,2010)可以潜在地利用数千个标记之间的交互作用。 Heslot et al. (2012) 在植物基因组选择中比较了包括机器学习在内的10种不同的方法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>biopython NCBI</title>
      <link href="/2018/11/08/biopython-NCBI/"/>
      <url>/2018/11/08/biopython-NCBI/</url>
      
        <content type="html"><![CDATA[<h1 id="访问NCBI-Entrez数据库"><a href="#访问NCBI-Entrez数据库" class="headerlink" title="访问NCBI Entrez数据库"></a>访问NCBI Entrez数据库</h1><p>Entrez (<a href="http://www.ncbi.nlm.nih.gov/Entrez" target="_blank" rel="noopener">http://www.ncbi.nlm.nih.gov/Entrez</a>) 是一个给客户提供 NCBI 各个数据库（如PubMed, GeneBank, GEO等等）访问的检索系统。 用户可以通过浏览器手动输入查询条目访问Entrez，也可以使用 Biopython 的 <code>Bio.Entrez</code> 模块以编程方式访问来访问 Entrez。 如果使用第二种方法，用户用一个 Python 脚本就可以实现在PubMed 里面搜索或者从 GenBank 下载数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; pip install Bio  <span class="comment">#安装模块</span></span><br></pre></td></tr></table></figure><h2 id="ESearch-搜索Entrez数据库"><a href="#ESearch-搜索Entrez数据库" class="headerlink" title="ESearch: 搜索Entrez数据库"></a>ESearch: 搜索Entrez数据库</h2><p>esearch 会根据参数得出所需文献、序列等的 ID 号。</p><p>检索文献：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>  <span class="comment">#Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"pubmed"</span>, term=<span class="string">"biopython"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"IdList"</span>]</span><br><span class="line">[<span class="string">'19304878'</span>, <span class="string">'18606172'</span>, <span class="string">'16403221'</span>, <span class="string">'16377612'</span>, <span class="string">'14871861'</span>, <span class="string">'14630660'</span>, <span class="string">'12230038'</span>]</span><br></pre></td></tr></table></figure><p>检索序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"nucleotide"</span>,term=<span class="string">"Cypripedioideae[Orgn] AND matK[Gene]"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"Count"</span>]</span><br><span class="line"><span class="string">'25'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"IdList"</span>]</span><br><span class="line">[<span class="string">'126789333'</span>, <span class="string">'37222967'</span>, <span class="string">'37222966'</span>, <span class="string">'37222965'</span>, ..., <span class="string">'61585492'</span>]</span><br></pre></td></tr></table></figure><p>常用db参数：<code>pubmed</code> <code>nucleotide</code> <code>protein</code> <code>gene</code> <code>snp</code> <code>unigene</code> ，默认为<code>pubmed</code></p><p>term参数：在检索文献时，term 就是关键词。在检索序列时，ncbi 自己有一套规则，如<code>Cypripedioideae[Orgn] AND matK[Gene]</code>的意思是 拖鞋兰物种中的 matK 基因序列</p><p><code>biomol_mrna[properties] AND Osteichthyes[organism]</code>  只要 mRNA 序列在硬骨鱼纲中</p><p>其他关键词还有：<strong>OR</strong> <strong>NOT</strong></p><h2 id="EFetch-从Entrez下载数据"><a href="#EFetch-从Entrez下载数据" class="headerlink" title="EFetch: 从Entrez下载数据"></a>EFetch: 从Entrez下载数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=<span class="string">"186972394"</span>, rettype=<span class="string">"fasta"</span>, retmode=<span class="string">"text"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (handle.read())</span><br><span class="line">&gt;EU490707<span class="number">.1</span> Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast</span><br><span class="line">ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTACTTGTGAAACGTTTAA</span><br><span class="line">TTACTCGAATGTATCAACAGAATTTTTTGATTTCTTCGGTTAATGATTCTAACCAAAAAGGATTTTGGGG</span><br><span class="line">GCACAAGCATTTTTTTTCTTCTCATTTTTCTTCTCAAATGGTATCAGAAGGTTTTGGAGTCATTCTGGAA</span><br><span class="line">ATTCCATTCTCGTCGCAATTAGTATCTTCTCTTGAAGAAAAAAAAATACCAAAATATCAGAATTTACGAT</span><br><span class="line">CTATTCATTCAATATTTCCCTTTTTAGAAGACAAATTTTTACATTTGAATTATGTGTCAGATCTACTAAT</span><br><span class="line">ACCCCATCCCATCCATCTGGAAATCTTGGTTCAAATCCTTCAATGCCGGATCAAGGATGTTCCTTCTTTG</span><br><span class="line">………………</span><br></pre></td></tr></table></figure><p>id 参数 ：ncbi 为每一条序列标识的ID号，可以使用 Entrez.esearch 获得。</p><p>rettype 参数：常用的有 <code>fasta</code> <code>gb</code></p><p>retmode 参数：数据的组织形式有 <code>text</code>  <code>xml</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez, SeqIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=<span class="string">"186972394"</span>,rettype=<span class="string">"gb"</span>, retmode=<span class="string">"text"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = SeqIO.read(handle, <span class="string">"genbank"</span>)  <span class="comment">#使用SeqIO 读入genbank序列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (record)</span><br><span class="line">ID: EU490707<span class="number">.1</span></span><br><span class="line">Name: EU490707</span><br><span class="line">Description: Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast.</span><br><span class="line">Number of features: <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Seq(<span class="string">'ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTA...GAA'</span>, IUPACAmbiguousDNA())</span><br></pre></td></tr></table></figure><h2 id="EGQuery-全局搜索-统计搜索的条目"><a href="#EGQuery-全局搜索-统计搜索的条目" class="headerlink" title="EGQuery: 全局搜索- 统计搜索的条目"></a>EGQuery: 全局搜索- 统计搜索的条目</h2><p>EGQuery提供搜索字段在每个Entrez数据库中的数目。当我们只需要知道在每个数据库中能找到的条目的个数， 而不需要知道具体搜索结果的时候，这个非常的有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.egquery(term=<span class="string">"biopython"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> record[<span class="string">"eGQueryResult"</span>]: <span class="keyword">print</span> row[<span class="string">"DbName"</span>], row[<span class="string">"Count"</span>]</span><br><span class="line">...</span><br><span class="line">pubmed <span class="number">6</span></span><br><span class="line">pmc <span class="number">62</span></span><br><span class="line">journals <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="搜索，下载，和解析Entrez核酸记录"><a href="#搜索，下载，和解析Entrez核酸记录" class="headerlink" title="搜索，下载，和解析Entrez核酸记录"></a>搜索，下载，和解析Entrez核酸记录</h2><p>获取 Cypripedioideae 在 gene 库的条目数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"A.N.Other@example.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.egquery(term=<span class="string">"Cypripedioideae"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> record[<span class="string">"eGQueryResult"</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> row[<span class="string">"DbName"</span>]==<span class="string">"gene"</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> row[<span class="string">"Count"</span>]</span><br><span class="line"><span class="number">376</span></span><br></pre></td></tr></table></figure><p>获得这376条数据的ID：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"nucleotide"</span>, term=<span class="string">"Cypripedioideae"</span>, retmax=<span class="number">376</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br></pre></td></tr></table></figure><p>使用 <code>efetch</code> 来下载这些结果的前5条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>idlist = <span class="string">","</span>.join(record[<span class="string">"IdList"</span>][:<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (idlist)</span><br><span class="line"><span class="number">187237168</span>,<span class="number">187372713</span>,<span class="number">187372690</span>,<span class="number">187372688</span>,<span class="number">187372686</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=idlist, retmode=<span class="string">"xml"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>records = Entrez.read(handle)  <span class="comment">#解析xml文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (len(records))</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python和R中的数据合并</title>
      <link href="/2018/10/31/merge-in-python-and-R/"/>
      <url>/2018/10/31/merge-in-python-and-R/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas（python）"><a href="#pandas（python）" class="headerlink" title="pandas（python）"></a>pandas（python）</h2><p><code>pandas.merge</code>可根据一个或多个键将不同 DataFrame 中的行连接起来。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">df1</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br><span class="line"></span><br><span class="line">df2</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   d</span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意，我并没有指明要用哪个列进行连接。如果没有指定，merge就会将重叠列的列名当做键。不过，最好明确指定一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: pd.merge(df1, df2, on=<span class="string">'key'</span>)</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果两个对象的列名不同，也可以分别进行指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df3 = pd.DataFrame(&#123;<span class="string">'lkey'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">   ....:                     <span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df4 = pd.DataFrame(&#123;<span class="string">'rkey'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],</span><br><span class="line">   ....:                     <span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>    a      <span class="number">0</span>    a</span><br></pre></td></tr></table></figure><p>结果里面c和d以及与之相关的数据消失了。默认情况下，merge做的是“内连接”<code>how=&#39;outer&#39;</code>；结果中的键是交集。其他方式还有”left”、”right”以及”outer”。</p><img src="/2018/10/31/merge-in-python-and-R/merge.png"><p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">   ....:                      <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">   ....:                      <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],</span><br><span class="line">   ....:                       <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">   ....:                       <span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line"><span class="number">0</span>  foo  one   <span class="number">1.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one   <span class="number">1.0</span>   <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two   <span class="number">2.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  bar  one   <span class="number">3.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two   NaN   <span class="number">7.0</span></span><br></pre></td></tr></table></figure><h2 id="dplyr（R）"><a href="#dplyr（R）" class="headerlink" title="dplyr（R）"></a>dplyr（R）</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innner_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#内连接</span></span><br><span class="line">left_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#左连接</span></span><br><span class="line">right_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#右连接</span></span><br><span class="line">full_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#全连接</span></span><br><span class="line">innner_join(x, y, by = c(<span class="string">"q"</span>,<span class="string">"j"</span>))  <span class="comment">#按多键连接</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SNP位点对基因的影响</title>
      <link href="/2018/10/30/The-effect-of-snp-on-genes/"/>
      <url>/2018/10/30/The-effect-of-snp-on-genes/</url>
      
        <content type="html"><![CDATA[<p>snp 是 single-nucleotide polymorphism 的简称，中文为单核苷酸多态性。snp 是如今遗传研究中最热门的一个研究对象，第一是因为他在生物中大量存在，分布广泛。第二他是引起人类（也包含其他生物）疾病的重要原因。</p><p>简单来说，snp 就是一个碱基发生了改变。snp 导致基因的转录、翻译受到影响，蛋白质序列、结构的变化使其无法实行原来特定的功能，人因此患上了某一种疾病。那么 snp 有哪些种类？是否所有的 snp 都能够造成基因的变异呢？</p><h2 id="snp-的种类"><a href="#snp-的种类" class="headerlink" title="snp 的种类"></a>snp 的种类</h2><ul><li>非同义编码 SNP（non-synonymous coding SNPs，nscSNPs） </li><li>同义编码 SNP（synonymous coding SNPs，scSNPs） </li><li>内含子区 SNP </li><li>基因调控区域 SNP </li></ul><img src="/2018/10/30/The-effect-of-snp-on-genes/Gene_structure.png"><h2 id="不同snp对基因的影响"><a href="#不同snp对基因的影响" class="headerlink" title="不同snp对基因的影响"></a>不同snp对基因的影响</h2><p>非同义编码 SNP，顾名思义就是碱基的改变导致翻译出的蛋白质和原来不同，他会直接改变基因编码蛋白的氨基酸组成，其功能影响取决于变异氨基酸位点是否对蛋白结构或功能起到至关重要的作用。 </p><p>同义编码 SNP，本身并不改变蛋白质序列，但由于蛋白质翻译存在密码子偏好性，从常用的密码子转到发生多态性之后的不常用密码子，这个过程会导致核糖体通过 SNP 周围 mRNA 片段时速度发生改变，而细胞内的蛋白质折叠过程一般被认为是与翻译过程同步进行的，因此这些 scSNP 会影响 P-gp 折叠和其转移到细胞膜的时间，因此会改变底物和抑制物的作用位点的结构  。</p><p>内含子区 SNP，内含子在真核生物基因组中占有很大比重，因此分布在内含子区域的 SNP 也很多， 但分析表明内含子区域的 SNP 的致病风险明显低于编码区和基因调控区，但位于第一个内含子的 SNP 比其他内含子中 SNP 有更大的致病风险 。与内含子相关的大多数引起疾病的突变集中在内含子—外显子连接处（GU或AG）。每个外显子和内含子连接区具有高度保守和一致的序列，即大多数内含子5’末端以GT开始，大多数内含子3’末端与AG开始，称为GT-AG规则。</p><p>基因调控区域 SNP ，基因的调控区域主要包括启动子、5’UTR 和 3’UTR，这些区域有很多基因表达调控序列元件，如转录因子结合位点（Transcription factor binding site, TFBS）、 miRNA 结合位点等。这些序列元件与调控因子（转录因子、miRNA 等）的结合都需要特定的序列组成，这些位点发生的 SNP 可能会导致调控因子的结合能力发生改变，从 而影响正常的基因表达调控事件。 </p><img src="/2018/10/30/The-effect-of-snp-on-genes/snp.png"><h2 id="深入基因调控区域的snp"><a href="#深入基因调控区域的snp" class="headerlink" title="深入基因调控区域的snp"></a>深入基因调控区域的snp</h2><p>在 GWAS 研究中会发现绝大多数的 snp 位点都定位到了非编码区。编码区的snp位点很好理解：哪个基因编码发生改变，那对应的蛋白也不会行使正常的功能。而基因调控区的snp位点要明白到底如何影响基因功能需要花上不少精力。</p><p>上面已经说过，基因调控区域 SNP会影响转录因子结合位点、miRNA 结合位点等。基因表达模式主要是靠各种启动子和增强子来决定的，这些调控元件将各种信号因子和转录因子信息整合起来对基因表达进行调控。 转录因子通过结合在DNA的增强子或启动子区域上调节相应基因，提高或降低基因的转录水平。，如果基因上游调控区发生变异就可能影响基因的转录激活。 </p><p>为了得到确切的结果，我们可以将 snp 集进行注释，注释工具主流的有 snpEFF，Annovar。最终会得到每一个 snp 的变异类型和影响区域。</p><p>如果一个 snp 对基因的表达产生了影响，那么这个 snp 可称为 eQTL位点（expression Quantitative Trait Loci,eQTL ）。可以提取样本的 RNA 进行 qRT-PCR 得到某几个候选基因的表达量作为表型，snp 集作为基因型进行 GWAS 分析。最终得到显著 snp 位点，如果显著 snp 位点恰好在候选基因周围的调控区域，那么这个 snp 位点就是一个 cis-eQTL （顺式eQTL），不在候选基因周围的调控区域，就要进一步研究是否对候选基因有作用，如果成立，那这个 snp 位点就是一个 trans-eQTL （反式eQTL）。研究发现顺式 eQTL 的数量要远多于反式 eQTL。</p><img src="/2018/10/30/The-effect-of-snp-on-genes/eqtl.png"><p>现在对于非编码区的碱基效应研究还没有编码区那么明了，但是以后一定会将整个基因组研究透彻。总之，一个碱基或者多个碱基的改变会从不同层面，不同量级去影响基因的表达。就像是蝴蝶效应：一个小小的改变终将会影响这个世界，条件只是时间在时间轴的运行的时间。</p><p>参考文献</p><p>[1] 许超. SNP对基因表达影响的生物信息学模型[D]. 苏州大学, 2012. </p><p>[2] 卢坤, 曲存民, 李莎,等. 甘蓝型油菜BnTT3基因的表达与eQTL定位分析[J]. 作物学报, 2015, 41(11):1758-1766. </p><p>[3] Chen R, Davydov E V, Sirota M, et al. Non-Synonymous and Synonymous Coding SNPs Show Similar Likelihood and Effect Size of Human Disease Association[J]. Plos One, 2010, 5(10):e13574. </p><p>[4] Westra H J, Franke L. From genome to function by studying eQTLs.[J]. BBA - Molecular Basis of Disease, 2014, 1842(10):1896-1902. </p>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R 字符串处理</title>
      <link href="/2018/10/18/R-stringr/"/>
      <url>/2018/10/18/R-stringr/</url>
      
        <content type="html"><![CDATA[<p>使用R包stringr进行R语言的字符串处理。</p><h3 id="str-count"><a href="#str-count" class="headerlink" title="str_count()"></a>str_count()</h3><p>计算字符串中字符个数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(stringr)</span><br><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pineapple"</span>)</span><br><span class="line">&gt; str_count(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] 1 3 1 1</span></span><br></pre></td></tr></table></figure><h3 id="str-detect"><a href="#str-detect" class="headerlink" title="str_detect()"></a>str_detect()</h3><p>检查字符是否在字符串中。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pinapple"</span>)</span><br><span class="line">&gt; str_detect(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] TRUE TRUE TRUE TRUE</span></span><br><span class="line">&gt; str_detect(fruit, <span class="string">"^a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1]  TRUE FALSE FALSE FALSE</span></span><br></pre></td></tr></table></figure><h3 id="str-extract"><a href="#str-extract" class="headerlink" title="str_extract()"></a>str_extract()</h3><p>模式匹配。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; shopping_list &lt;- c(<span class="string">"apples x4"</span>, <span class="string">"bag of flour"</span>, <span class="string">"bag of sugar"</span>, <span class="string">"milk x2"</span>)</span><br><span class="line">&gt; str_extract_all(shopping_list, <span class="string">"[a-z]+\\b"</span>, simplify = <span class="literal">TRUE</span>)  <span class="comment">#simplify = TRUE 以矩阵的方式展示结果</span></span><br><span class="line"><span class="comment">#&gt;      [,1]     [,2] [,3]   </span></span><br><span class="line"><span class="comment">#&gt; [1,] "apples" ""   ""     </span></span><br><span class="line"><span class="comment">#&gt; [2,] "bag"    "of" "flour"</span></span><br><span class="line"><span class="comment">#&gt; [3,] "bag"    "of" "sugar"</span></span><br><span class="line"><span class="comment">#&gt; [4,] "milk"   ""   ""     </span></span><br><span class="line">&gt; str_extract(shopping_list, <span class="string">"[a-z]+\\b"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"apples"</span> <span class="string">"bag"</span>    <span class="string">"bag"</span>    <span class="string">"milk"</span></span><br></pre></td></tr></table></figure><h3 id="str-match"><a href="#str-match" class="headerlink" title="str_match ()"></a>str_match ()</h3><p>模式匹配，进行分组匹配。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple12345679!123"</span>)</span><br><span class="line">&gt; str_match_all(fruit,<span class="string">"([a-z]+).*?(!)"</span>)   <span class="comment">#分2个组，结果第一个为全部匹配的结果</span></span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">     [,<span class="number">1</span>]             [,<span class="number">2</span>]    [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,] <span class="string">"apple12345679!"</span> <span class="string">"apple"</span> <span class="string">"!"</span></span><br></pre></td></tr></table></figure><h3 id="str-locate"><a href="#str-locate" class="headerlink" title="str_locate()"></a>str_locate()</h3><p>模式匹配位置。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pineapple"</span>) </span><br><span class="line">&gt; str_locate(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt;      start end</span></span><br><span class="line"><span class="comment">#&gt; [1,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [2,]     2   2</span></span><br><span class="line"><span class="comment">#&gt; [3,]     3   3</span></span><br><span class="line"><span class="comment">#&gt; [4,]     5   5</span></span><br><span class="line">&gt; str_locate(fruit, c(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"p"</span>, <span class="string">"p"</span>))</span><br><span class="line"><span class="comment">#&gt;      start end</span></span><br><span class="line"><span class="comment">#&gt; [1,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [2,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [3,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [4,]     1   1</span></span><br><span class="line">&gt; str_locate_all(fruit, <span class="string">"a"</span>)</span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,]     <span class="number">4</span>   <span class="number">4</span></span><br><span class="line">[<span class="number">3</span>,]     <span class="number">6</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">5</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="str-subset"><a href="#str-subset" class="headerlink" title="str_subset()"></a>str_subset()</h3><p>功能如 linux下grep。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pinapple"</span>)</span><br><span class="line">&gt; str_subset(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"    "banana"   "pear"     "pinapple"</span></span><br><span class="line">&gt; str_subset(fruit, <span class="string">"^a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"</span></span><br><span class="line">&gt; str_subset(fruit, <span class="string">"[aeiou]"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"    "banana"   "pear"     "pinapple"</span></span><br></pre></td></tr></table></figure><h3 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace()"></a>str_replace()</h3><p>替换字符。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruits &lt;- c(<span class="string">"one apple"</span>, <span class="string">"two pears"</span>, <span class="string">"three bananas"</span>)</span><br><span class="line">&gt; str_replace(fruits, <span class="string">"[aeiou]"</span>, <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "-ne apple"     "tw- pears"     "thr-e bananas"</span></span><br><span class="line">&gt; str_replace_all(fruits, <span class="string">"[aeiou]"</span>, <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "-n- -ppl-"     "tw- p--rs"     "thr-- b-n-n-s"</span></span><br></pre></td></tr></table></figure><h3 id="str-split"><a href="#str-split" class="headerlink" title="str_split()"></a>str_split()</h3><p>分割字符串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruits &lt;- c(</span><br><span class="line">  <span class="string">"apples and oranges and pears and bananas"</span>,</span><br><span class="line">  <span class="string">"pineapples and mangos and guavas"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>)</span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "apples"  "oranges" "pears"   "bananas" </span></span><br><span class="line"><span class="comment">#&gt; [[2]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "pineapples" "mangos"     "guavas"    </span></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>, simplify = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#&gt;      [,1]         [,2]      [,3]     [,4]     </span></span><br><span class="line"><span class="comment">#&gt; [1,] "apples"     "oranges" "pears"  "bananas"</span></span><br><span class="line"><span class="comment">#&gt; [2,] "pineapples" "mangos"  "guavas" ""     </span></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>, n = <span class="number">3</span>)</span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "apples"            "oranges"           "pears and bananas" </span></span><br><span class="line"><span class="comment">#&gt; [[2]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "pineapples" "mangos"     "guavas"</span></span><br></pre></td></tr></table></figure><h3 id="str-sort"><a href="#str-sort" class="headerlink" title="str_sort()"></a>str_sort()</h3><p>字符串排序。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; letter&lt;-c(<span class="string">'an apple'</span>,<span class="string">'two oranges'</span>,<span class="string">'three bananas'</span>,<span class="string">'four tomatoes'</span>)</span><br><span class="line">&gt; str_sort(letter)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"an apple"</span>      <span class="string">"four tomatoes"</span> <span class="string">"three bananas"</span> <span class="string">"two oranges"</span></span><br><span class="line">&gt; str_sort(letter,decreasing = <span class="literal">TRUE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"two oranges"</span>   <span class="string">"three bananas"</span> <span class="string">"four tomatoes"</span> <span class="string">"an apple"</span></span><br><span class="line">x &lt;- c(<span class="string">"100a10"</span>, <span class="string">"100a5"</span>, <span class="string">"2b"</span>, <span class="string">"2a"</span>)</span><br><span class="line">str_sort(x)</span><br><span class="line"><span class="comment">#&gt; [1] "100a10" "100a5"  "2a"     "2b"    </span></span><br><span class="line">str_sort(x, numeric = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "2a"     "2b"     "100a5"  "100a10"</span></span><br></pre></td></tr></table></figure><h3 id="str-to-upper-str-to-lower-str-to-title"><a href="#str-to-upper-str-to-lower-str-to-title" class="headerlink" title="str_to_upper()    str_to_lower()     str_to_title()"></a>str_to_upper()    str_to_lower()     str_to_title()</h3><p>改变字符大小写。</p><h3 id="str-length"><a href="#str-length" class="headerlink" title="str_length()"></a>str_length()</h3><p>字符串长度。</p><h3 id="str-c"><a href="#str-c" class="headerlink" title="str_c()"></a>str_c()</h3><p>拼接字符串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str_c(<span class="string">'I have'</span>,letter,sep = <span class="string">' '</span>)  <span class="comment">#单字符串加字符</span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"I have an apple"</span>      <span class="string">"I have two oranges"</span>   <span class="string">"I have three bananas"</span> <span class="string">"I have four tomatoes"</span></span><br><span class="line">&gt; str_c(letter,collapse = <span class="string">','</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"an apple,two oranges,three bananas,four tomatoes"</span>  <span class="comment">#拼接所有字符串</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R 数据处理</title>
      <link href="/2018/10/02/R-data-progress/"/>
      <url>/2018/10/02/R-data-progress/</url>
      
        <content type="html"><![CDATA[<p>本节函数都来自于dplyr包，都可以和<code>group_by</code>函数联合起来处理复杂的数据。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code>函数用来根据列的具体数据选择行。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(dplyr)</span><br><span class="line">&gt; names(mpg)</span><br><span class="line">  <span class="string">"manufacturer"</span> <span class="string">"model"</span> <span class="string">"displ"</span> <span class="string">"year"</span> <span class="string">"cyl"</span> <span class="string">"trans"</span> <span class="string">"drv"</span> <span class="string">"cty"</span> <span class="string">"hwy"</span> <span class="string">"fl"</span> <span class="string">"class"</span></span><br><span class="line">&gt; filter(mpg,year==<span class="number">1999</span>)  <span class="comment">#选择year==1999的数据</span></span><br><span class="line"><span class="comment"># A tibble: 117 x 11</span></span><br><span class="line">   manufacturer model              displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> audi         a4                  <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact</span><br><span class="line"> <span class="number">2</span> audi         a4                  <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact</span><br><span class="line"> <span class="number">3</span> audi         a4                  <span class="number">2.80</span>  <span class="number">1999</span>     <span class="number">6</span> auto(l5)   f        <span class="number">16</span>    <span class="number">26</span> p     compact</span><br><span class="line">&gt; filter(mpg,year==<span class="number">1999</span>,displ&gt;<span class="number">5</span>)  <span class="comment">#选择year==1999且displ&gt;5的数据</span></span><br><span class="line"><span class="comment"># A tibble: 16 x 11</span></span><br><span class="line">   manufacturer model               displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> chevrolet    c1500 suburban 2wd   <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   r        <span class="number">13</span>    <span class="number">17</span> r     suv    </span><br><span class="line"> <span class="number">2</span> chevrolet    corvette             <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> manual(m6) r        <span class="number">16</span>    <span class="number">26</span> p     2seater</span><br><span class="line"> <span class="number">3</span> chevrolet    corvette             <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   r        <span class="number">15</span>    <span class="number">23</span> p     2seater</span><br><span class="line"> <span class="number">4</span> chevrolet    k1500 tahoe 4wd      <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv    </span><br><span class="line"> <span class="number">5</span> chevrolet    k1500 tahoe 4wd      <span class="number">6.50</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   <span class="number">4</span>        <span class="number">14</span>    <span class="number">17</span> d     suv</span><br></pre></td></tr></table></figure><h2 id="arrange"><a href="#arrange" class="headerlink" title="arrange"></a>arrange</h2><p><code>arrange()</code>函数用来排列行的顺序。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; arrange(mpg,year,cty, hwy)  <span class="comment">#根据year,cty, hwy进行行排序</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 11</span></span><br><span class="line">   manufacturer model                  displ  year   cyl trans    drv     cty   hwy fl    class </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;                  &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; </span><br><span class="line"> <span class="number">1</span> chevrolet    k1500 tahoe 4wd         <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv   </span><br><span class="line"> <span class="number">2</span> dodge        dakota pickup 4wd       <span class="number">5.20</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     pickup</span><br><span class="line"> <span class="number">3</span> dodge        durango 4wd             <span class="number">5.90</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv </span><br><span class="line">&gt; arrange(mpg,year,cty, hwy)  <span class="comment">#根据year,cty, hwy进行行排序</span></span><br><span class="line">&gt; arrange(mpg,desc(year))   <span class="comment">#根据year进行行降序排序</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 11</span></span><br><span class="line">   manufacturer model              displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> audi         a4                  <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact</span><br><span class="line"> <span class="number">2</span> audi         a4                  <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> auto(av)   f        <span class="number">21</span>    <span class="number">30</span> p     compact</span><br><span class="line"> <span class="number">3</span> audi         a4                  <span class="number">3.10</span>  <span class="number">2008</span>     <span class="number">6</span> auto(av)   f        <span class="number">18</span>    <span class="number">27</span> p     compact</span><br><span class="line"> <span class="number">4</span> audi         a4 quattro          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) <span class="number">4</span>        <span class="number">20</span>    <span class="number">28</span> p     compact</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select()</code>函数用来选择列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; select(mpg,year,cty, hwy)  <span class="comment">#只显示year,cty, hwy三列</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 3</span></span><br><span class="line">    year   cty   hwy</span><br><span class="line">   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span><br><span class="line"> <span class="number">1</span>  <span class="number">1999</span>    <span class="number">18</span>    <span class="number">29</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1999</span>    <span class="number">21</span>    <span class="number">29</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">2008</span>    <span class="number">20</span>    <span class="number">31</span></span><br></pre></td></tr></table></figure><p><code>select()</code>函数的辅助函数：</p><ul><li><code>start_with(&quot;abc&quot;)</code> ：匹配以 “abc” 开头的变量名。</li><li><code>ends_with(&quot;xyz&quot;)</code> ：以 “xyz” 结尾。</li><li><code>contains(&quot;ijk&quot;)</code> ：包含 “ijk”。</li><li><code>match(&quot;(.)\\\1&quot;)</code> ：正则匹配重复字符。</li><li><code>num_range(&quot;x&quot;,1:3)</code> ：匹配x1，x2和x3。</li></ul><h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p><code>rename()</code>用来改变变量名。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rename(mpg,YEAR=year)  <span class="comment">#将year重命名YEAR</span></span><br></pre></td></tr></table></figure><h2 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h2><p><code>mutate()</code>函数用来对数据进行增加新列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; mutate(mpg,cty2=cty*<span class="number">2</span>)  <span class="comment">#数值型</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 12</span></span><br><span class="line">   manufacturer model      displ  year   cyl trans      drv     cty   hwy fl    class    cty2</span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;</span><br><span class="line"> <span class="number">1</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact   <span class="number">36.</span></span><br><span class="line"> <span class="number">2</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact   <span class="number">42.</span></span><br><span class="line"> <span class="number">3</span> audi         a4          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact   <span class="number">40.</span></span><br><span class="line">&gt; mutate(mpg,cty2=paste(drv,cty,sep = <span class="string">""</span>))  <span class="comment">#字符型</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 12</span></span><br><span class="line">   manufacturer model      displ  year   cyl trans      drv     cty   hwy fl    class   cty2 </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;</span><br><span class="line"> <span class="number">1</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact f18  </span><br><span class="line"> <span class="number">2</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact f21  </span><br><span class="line"> <span class="number">3</span> audi         a4          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact f20</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R 分面</title>
      <link href="/2018/10/02/R-facet/"/>
      <url>/2018/10/02/R-facet/</url>
      
        <content type="html"><![CDATA[<p>有时候会有需求需要把一个数据框的数据作图，再按照不同的分类将图形分开绘制。或者，只是需要把2个或者多个图简单地放在一个画布上，R图的分面将会作用与此。</p><h2 id="facet-grid"><a href="#facet-grid" class="headerlink" title="facet_grid"></a>facet_grid</h2><p>ggplot2的<code>facet_grid()</code>函数按分类条件将图形在行或者列上分面绘图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mpg, aes(displ, cty)) + geom_point()</span><br><span class="line">&gt; p + facet_grid(rows = vars(drv))  <span class="comment">#按行分面</span></span><br><span class="line">&gt; p + facet_grid(cols = vars(cyl))  <span class="comment">#按列分面</span></span><br><span class="line">&gt; p + facet_grid(vars(drv), vars(cyl))  <span class="comment">#使用2个变量同时在行列分面</span></span><br><span class="line"></span><br><span class="line">&gt; mt &lt;- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +geom_point()  <span class="comment">#按cyl填充颜色</span></span><br><span class="line">&gt; mt + facet_grid(cols = vars(cyl), scales = <span class="string">"free"</span>)  <span class="comment">#scales = "free"刻度在在分面上可自适应</span></span><br></pre></td></tr></table></figure><h2 id="facet-wrap"><a href="#facet-wrap" class="headerlink" title="facet_wrap"></a>facet_wrap</h2><p>ggplot2的<code>facet_wrap()</code>函数按分类条件将图形2d(默认n x n)形式的铺在画布上。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p + facet_wrap(vars(class))  <span class="comment">#按class分面</span></span><br><span class="line">&gt; p + facet_wrap(vars(class), nrow = <span class="number">4</span>)  <span class="comment">#强制分为4行</span></span><br><span class="line">&gt; p + facet_wrap(vars(class), ncol = <span class="number">4</span>)  <span class="comment">#强制分为4列</span></span><br><span class="line">&gt; p + facet_wrap(vars(cyl, drv))  <span class="comment">#使用2个变量进行分类</span></span><br><span class="line">&gt; p + facet_wrap(c(<span class="string">"cyl"</span>, <span class="string">"drv"</span>), labeller = <span class="string">"label_both"</span>)  <span class="comment">#友好的显示分类变量名</span></span><br></pre></td></tr></table></figure><h2 id="grid-arrange"><a href="#grid-arrange" class="headerlink" title="grid.arrange"></a>grid.arrange</h2><p><code>grid.arrange()</code>是gridExtra包的一个函数，可以将多个图放入一个画布中。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">"gridExtra"</span>)</span><br><span class="line">&gt; <span class="keyword">library</span>(gridExtra)</span><br><span class="line">&gt; p1&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p2&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p3&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; grid.arrange(p1,p2,p3, nrow=<span class="number">2</span>)  <span class="comment">#设定为2行图形</span></span><br><span class="line">&gt; grid.arrange(p1,p2,p3, nrow=<span class="number">2</span>,top = textGrob(<span class="string">"xxx"</span>,gp=gpar(col=<span class="string">"red"</span>,fontsize=<span class="number">20</span>，font=<span class="number">2</span>)))</span><br><span class="line">  <span class="comment">#设置总标题，并修改颜色大小，字体</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R 回归分析</title>
      <link href="/2018/09/29/R-regression-analysis/"/>
      <url>/2018/09/29/R-regression-analysis/</url>
      
        <content type="html"><![CDATA[<h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>逐步回归分析是以AIC信息统计量为准则，通过选择最小的AIC信息统计量，来达到删除或增加变量的目的。</p><p>AIC : 赤池信息准则(Akaike Information Criterion) ,k是模型中估计参数的数量。L是模型的似然函数的最大值。</p><img src="/2018/09/29/R-regression-analysis/AIC.svg"><p>AICc：当样本量很小时，AIC很可能会选择具有太多参数的模型，即AIC会过度拟合。为了解决这种潜在的过度拟合问题，AICc可以对小样本进行校正。其中<em>n</em>表示样本大小，<em>k</em>表示参数的数量。 </p><img src="/2018/09/29/R-regression-analysis/Akaike-Information-Criterion.svg"><h3 id="向前逐步回归"><a href="#向前逐步回归" class="headerlink" title="向前逐步回归"></a>向前逐步回归</h3><p>首先模型中只有一个单独解释因变量变异最大的自变量，之后尝试将加入另一自变量，看加入后整个模型所能解释的因变量变异是否显著增加（这里需要进行检验，可以用 F-test， t-test 等等）。这一过程反复迭代，直到没有自变量再符合加入模型的条件。 </p><p>MASS包中的<code>stepAIC()</code>函数给予AIC准则实现了逐步回归模型（向前、向后和双向）。 </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"forward"</span>)</span><br></pre></td></tr></table></figure><h3 id="向后逐步回归"><a href="#向后逐步回归" class="headerlink" title="向后逐步回归"></a>向后逐步回归</h3><p>向后逐步回归与向前逐步回归相反，此时，所有变量均放入模型，之后尝试将其中一个自变量从模型中剔除，看整个模型解释因变量的变异是否有显著变化，之后将使解释量减少最少的变量剔除；此过程不断迭代，直到没有自变量符合剔除的条件。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"backward"</span>)</span><br></pre></td></tr></table></figure><h3 id="向前向后逐步回归"><a href="#向前向后逐步回归" class="headerlink" title="向前向后逐步回归"></a>向前向后逐步回归</h3><p>向前向后逐步回归，这种方法相当于将前两种结合起来。可以想象，如果采用第一种方法，每加入一个自变量，可能会使已存在于模型中的变量单独对因变量的解释度减小，当其的作用很小（不显著）时，则可将其从模型中剔除。而第三种方法就做了这么一件事，不是一味的增加变量，而是增加一个后，对整个模型中的所有变量进行检验，剔除作用不显著的变量。最终尽可能得到一个最优的变量组合。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"both"</span>)</span><br></pre></td></tr></table></figure><p>Forward、Backward、Stepwise的侧重点有所不同，三种方法的选择取决于你的研究目的，如果是进行预测，在预测效果差不多的情况下，一般选择自变量最少的方法。当自变量间不存在多重共线性时，三种方法的计算结果基本一致。当自变量间存在多重共线性时，Forward侧重于引入单独作用较强的变量，Backward侧重于引入联合作用较强的变量，Stepwise介于两者之间。</p><h2 id="全子集回归"><a href="#全子集回归" class="headerlink" title="全子集回归"></a>全子集回归</h2><p>全子集回归克服了逐步回归的缺点，即所有可能的模型都会被检验，评判准则可以是R平方、修正R平方、BIC或者Mallows Cp统计量。 </p><p>R平方：</p><img src="/2018/09/29/R-regression-analysis/r2.svg"><p>修正R平方 : </p><p>我们知道在其他变量不变的情况下，引入新的变量，总能提高模型的R2。修正R2就是相当于给变量的个数加惩罚项。换句话说，如果两个模型，样本数一样，R2一样，那么从修正R2的角度看，使用变量个数少的那个模型更优。其中n是样本数量，p是模型中变量的个数。 当p/n值很小时，如小于0.05，修正R平方将失去修正作用。</p><img src="/2018/09/29/R-regression-analysis/adjr2.svg"><p>BIC：贝叶斯信息准则 ，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。 </p><img src="/2018/09/29/R-regression-analysis/BIC.svg"><p>Mallows Cp：马洛斯的Cp值 与AIC等效。</p><p>以下为R中<code>ISLR</code>包的<code>Hitters</code>数据集为例，构建棒球运动员的多元线性模型 。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(ISLR)</span><br><span class="line">&gt; <span class="keyword">library</span>(leaps)  <span class="comment">#使用leaps做全子集回归</span></span><br><span class="line">&gt; Hitters &lt;- na.omit(Hitters)</span><br><span class="line">&gt; dim(Hitters)  <span class="comment">#除去Salary做为因变量，还剩下19个特征</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">263</span>  <span class="number">20</span></span><br><span class="line">&gt; regfit.full = regsubsets(Salary~.,Hitters,nvmax = <span class="number">19</span>)  <span class="comment">#选择最大19个特征的全子集选择模型</span></span><br><span class="line">&gt; reg.summary = summary(regfit.full) <span class="comment"># 可看到不同数量下的特征选择</span></span><br><span class="line">&gt; plot(reg.summary$adjr2,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"Adjusted R2"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.max(reg.summary$adjr2),reg.summary$adjr2[<span class="number">11</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>)  <span class="comment">#11个特征时，Adjusted R2最大</span></span><br><span class="line"></span><br><span class="line">&gt; plot(reg.summary$cp,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"Cp"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.min(reg.summary$cp),reg.summary$cp[<span class="number">10</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>) <span class="comment"># 10个特征时，Cp最小</span></span><br><span class="line"></span><br><span class="line">&gt; plot(reg.summary$bic,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"BIC"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.min(reg.summary$bic),reg.summary$bic[<span class="number">6</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>) <span class="comment"># 6个特征时，BIC最小</span></span><br><span class="line"></span><br><span class="line">&gt; plot(regfit.full,scale = <span class="string">"r2"</span>) <span class="comment">#特征越多，R2越大，这不意外，默认scale是bic。</span></span><br><span class="line">&gt; plot(regfit.full,scale = <span class="string">"adjr2"</span>)  <span class="comment">#下图</span></span><br><span class="line">&gt; coef(regfit.full,<span class="number">11</span>)  <span class="comment">#查看模型的系数</span></span><br><span class="line"> (Intercept)        AtBat         Hits        Walks       CAtBat </span><br><span class="line"> <span class="number">135.7512195</span>   -<span class="number">2.1277482</span>    <span class="number">6.9236994</span>    <span class="number">5.6202755</span>   -<span class="number">0.1389914</span> </span><br><span class="line">       CRuns         CRBI       CWalks      LeagueN    DivisionW </span><br><span class="line">   <span class="number">1.4553310</span>    <span class="number">0.7852528</span>   -<span class="number">0.8228559</span>   <span class="number">43.1116152</span> -<span class="number">111.1460252</span> </span><br><span class="line">     PutOuts      Assists </span><br><span class="line">   <span class="number">0.2894087</span>    <span class="number">0.2688277</span></span><br></pre></td></tr></table></figure><img src="/2018/09/29/R-regression-analysis/adjr2_plot2.png"><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>交叉验证是在机器学习建立模型和验证模型参数时常用的办法，一般被用于评估一个机器学习模型的表现。更多的情况下，也用交叉验证来进行模型选择(model selection)。 </p><p>k重交叉验证中，样本被分为k个子样本，轮流将k-1个子样本组合作为训练集，另外1个子样本作为测试集，这样会获得k个预测方程，记录k个测试样本的预测表现结果，然后求其平均值。测试集的目的简单来说就相当于一个游戏的内测，内部评估。进行交叉验证后得到了分数来评估你建模的准确率是高是低。最后的目的是为了哪天来了新的数据，你也可以用你的模型去预测他，相当于游戏公测。 </p><p>bootstrap包中的<code>crossval()</code> 函数可实现k重交叉验证 ：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">"bootstrap"</span>)  </span><br><span class="line">&gt; <span class="keyword">library</span>(bootstrap)  </span><br><span class="line">&gt; shrinkage&lt;-<span class="keyword">function</span>(fit,k=<span class="number">10</span>)&#123;  </span><br><span class="line">  <span class="keyword">require</span>(bootstrap)  </span><br><span class="line">  theta.fit&lt;-<span class="keyword">function</span>(x,y)&#123;lsfit(x,y)&#125;  </span><br><span class="line">  theta.predict&lt;-<span class="keyword">function</span>(fit,x)&#123;cbind(<span class="number">1</span>,x)%*%fit$coef&#125;  </span><br><span class="line">  x&lt;-fit$model[,<span class="number">2</span>:ncol(fit$model)]  </span><br><span class="line">  y&lt;-fit$model[,<span class="number">1</span>]  </span><br><span class="line">  results&lt;-crossval(x,y,theta.fit,theta.predict,ngroup=k)  </span><br><span class="line">  r2&lt;-cor(y,fit$fitted.values)^<span class="number">2</span>  </span><br><span class="line">  r2cv&lt;-cor(y,results$cv.fit)^<span class="number">2</span>  </span><br><span class="line">  cat(<span class="string">"Original R-square="</span>,r2,<span class="string">"n"</span>)  </span><br><span class="line">  cat(k,<span class="string">"Fold Cross-Validated R-square="</span>,r2cv,<span class="string">"n"</span>)  </span><br><span class="line">  cat(<span class="string">"Change="</span>,r2-r2cv,<span class="string">"n"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&gt; fit&lt;-lm(Murder ~ Population+Income+Illiteracy+Frost,data=states)  </span><br><span class="line">&gt; shrinkage(fit)  </span><br><span class="line">&gt; fit2&lt;-lm(Murder ~ Population+Illiteracy,data=states)  </span><br><span class="line">&gt; shrinkage(fit2)  </span><br><span class="line">Original R-square=<span class="number">0.5668327</span></span><br><span class="line"><span class="number">10</span> Fold Cross-Validated R-square=<span class="number">0.5193801</span></span><br><span class="line">Change=<span class="number">0.04745256</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R 数据预处理</title>
      <link href="/2018/09/28/deal-with-r-data/"/>
      <url>/2018/09/28/deal-with-r-data/</url>
      
        <content type="html"><![CDATA[<h3 id="将若干向量组合为数据框"><a href="#将若干向量组合为数据框" class="headerlink" title="将若干向量组合为数据框"></a>将若干向量组合为数据框</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- c(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">&gt; x &lt;- <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">&gt; data &lt;- data.frame(g,x)</span><br><span class="line">&gt; data</span><br><span class="line">  g x</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="从数据框中提取摘要信息"><a href="#从数据框中提取摘要信息" class="headerlink" title="从数据框中提取摘要信息"></a>从数据框中提取摘要信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str(data)</span><br><span class="line"><span class="string">'data.frame'</span>:<span class="number">3</span> obs. of  <span class="number">2</span> variables:</span><br><span class="line"> $ g: Factor w/ <span class="number">3</span> levels <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"> $ x: int  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="向数据框添加列"><a href="#向数据框添加列" class="headerlink" title="向数据框添加列"></a>向数据框添加列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data$new &lt;- data$x * <span class="number">2</span></span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="从数据框删除列"><a href="#从数据框删除列" class="headerlink" title="从数据框删除列"></a>从数据框删除列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data &lt;- subset(data,select = c(-x,-new))</span><br><span class="line">  g</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure><h3 id="重排序列"><a href="#重排序列" class="headerlink" title="重排序列"></a>重排序列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data2 &lt;-data[c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)]</span><br><span class="line">  g new x</span><br><span class="line"><span class="number">1</span> a   <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b   <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c   <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="选取某几列"><a href="#选取某几列" class="headerlink" title="选取某几列"></a>选取某几列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data3 &lt;-data[c(<span class="string">"x"</span>,<span class="string">"new"</span>)]</span><br><span class="line">  x new</span><br><span class="line"><span class="number">1</span> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="选取某几行"><a href="#选取某几行" class="headerlink" title="选取某几行"></a>选取某几行</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; data3 &lt;-data[c(<span class="number">1</span>,<span class="number">2</span>),]</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>  unite <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="连续变量转换为分类变量"><a href="#连续变量转换为分类变量" class="headerlink" title="连续变量转换为分类变量"></a>连续变量转换为分类变量</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data$class &lt;- cut(data$new,breaks=c(<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="literal">Inf</span>))</span><br><span class="line">  g x new class</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span> (<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span> (<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span> (<span class="number">4</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="宽数据《-》长数据"><a href="#宽数据《-》长数据" class="headerlink" title="宽数据《=》长数据"></a>宽数据《=》长数据</h3><p>长数据有一列数据是变量的类型，有一列是变量的值，但不一定只有两列。<code>ggplot2</code>需要长类型的数据，<code>dplyr</code>也需要长类型的数据，大多数的模型(比如<code>lm()</code>, <code>glm()</code>以及<code>gam()</code>)也需要长数据。 </p><p>使用<code>tidyr</code> 包的<code>gather()</code>函数转换到长数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(tidyr)</span><br><span class="line">&gt; data</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">&gt; data2&lt;-gather(data,key=<span class="string">'new_one'</span>,value =<span class="string">'count'</span>,x,new,-g)</span><br><span class="line">&gt; data2</span><br><span class="line">  g new_one count</span><br><span class="line"><span class="number">1</span> a       x     <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b       x     <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c       x     <span class="number">3</span></span><br><span class="line"><span class="number">4</span> a     new     <span class="number">2</span></span><br><span class="line"><span class="number">5</span> b     new     <span class="number">4</span></span><br><span class="line"><span class="number">6</span> c     new     <span class="number">6</span></span><br></pre></td></tr></table></figure><p>使用<code>tidyr</code> 包的<code>spread()</code>函数转换到宽数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; spread(data2,key=<span class="string">'new_one'</span>,value=<span class="string">'count'</span>)</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="多列《-》一列"><a href="#多列《-》一列" class="headerlink" title="多列《=》一列"></a>多列《=》一列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; data</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">&gt; data3&lt;-unite(data,x_new,x,new,sep = <span class="string">'_'</span>)</span><br><span class="line">&gt; data3</span><br><span class="line">  g x_new</span><br><span class="line"><span class="number">1</span> a   1_<span class="number">2</span></span><br><span class="line"><span class="number">2</span> b   2_<span class="number">4</span></span><br><span class="line"><span class="number">3</span> c   3_<span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt; data4&lt;- separate(data3,x_new,c(<span class="string">'x'</span>,<span class="string">'new'</span>),sep = <span class="string">'_'</span>)</span><br><span class="line">&gt; data4</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python Type Hint</title>
      <link href="/2018/09/19/python-Type-Hint/"/>
      <url>/2018/09/19/python-Type-Hint/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    在C语言中每使用一个变量前要先将其声明，如 <code>int a =1</code>,<code>float b =3.14</code>。这么做的好处有2个，一是在之后代码中无需“猜测”变量到底是什么类型，声明是什么就是什么，这就是静态变量。二是少了“猜测”这一步，代码执行效率会有所提升。python默认所有的变量都是动态的，所以你无需提前声明类型，写出了一个变量a，赋值给他一个常数、列表、字典等等都可以。当然动态所带来的问题就是，在代码执行的时候需要去“猜测”变量的类型，从而降低了运行效率。</p><p>​    在python3.5及之后版本，python加入了模块typing，它允许在你命名变量的时候设定它的类型，抽象出来它长这个样子：<code>variable : type</code>，在设定一个变量类型为常量（int）之后并不会影响你给他赋值为字符串（str），这种类型设定如名字一样是类型暗示（Type Hint），而不是决定。</p><p>​    有一个名为mypy的包可以显式的帮你找出你在类型上的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install mypy</span><br><span class="line">$ mypy program.py</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可供使用的类型：</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>int</code></td><td>integer</td></tr><tr><td><code>float</code></td><td>floating point number</td></tr><tr><td><code>bool</code></td><td>boolean value</td></tr><tr><td><code>str</code></td><td>string (unicode)</td></tr><tr><td><code>bytes</code></td><td>8-bit string</td></tr><tr><td><code>object</code></td><td>an arbitrary object (<code>object</code> is the common base class)</td></tr><tr><td><code>List[str]</code></td><td>list of <code>str</code> objects</td></tr><tr><td><code>Tuple[int, int]</code></td><td>tuple of two <code>int</code> objects (<code>Tuple[()]</code> is the empty tuple)</td></tr><tr><td><code>Tuple[int, ...]</code></td><td>tuple of an arbitrary number of <code>int</code> objects</td></tr><tr><td><code>Dict[str, int]</code></td><td>dictionary from <code>str</code> keys to <code>int</code> values</td></tr><tr><td><code>Iterable[int]</code></td><td>iterable object containing ints</td></tr><tr><td><code>Sequence[bool]</code></td><td>sequence of booleans (read-only)</td></tr><tr><td><code>Mapping[str, int]</code></td><td>mapping from <code>str</code> keys to <code>int</code> values (read-only)</td></tr><tr><td><code>Any</code></td><td>dynamically typed value with an arbitrary type</td></tr><tr><td><code>Union[T1, ..., Tn]</code></td><td><code>Union[int, str]</code>both integers and strings are valid argument values.</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Set, Dict, Tuple, Optional, Union, Any</span><br><span class="line">x: int = <span class="number">1</span></span><br><span class="line">x: float = <span class="number">1.0</span></span><br><span class="line">x: bool = <span class="keyword">True</span></span><br><span class="line">x: str = <span class="string">"test"</span></span><br><span class="line">x: bytes = <span class="string">b"test"</span></span><br><span class="line">x: List[int] = [<span class="number">1</span>]</span><br><span class="line">x: Set[int] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">x: Dict[str, float] = &#123;<span class="string">'field'</span>: <span class="number">2.0</span>&#125;</span><br><span class="line">x: Tuple[int, str, float] = (<span class="number">3</span>, <span class="string">"yes"</span>, <span class="number">7.5</span>)</span><br><span class="line">x: List[Union[int, str]] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">"test"</span>, <span class="string">"fun"</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(num1: int, num2: float)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: Union[int, str])</span> -&gt; Any:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, int):</span><br><span class="line">        <span class="comment"># Here type of x is int.</span></span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>)      <span class="comment"># OK</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Here type of x is str.</span></span><br><span class="line">       <span class="keyword">return</span> (x + <span class="string">'a'</span>)    <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list)</span>:</span> <span class="comment">#定义一个方法，不做类型设定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join(<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'h, e, l, l, o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join([<span class="string">'hello'</span>,<span class="string">'world'</span>])</span><br><span class="line"><span class="string">'hello, world'</span></span><br></pre></td></tr></table></figure><p>对于这个函数，期望的结果就是会把[‘hello’, ‘world’]变成’hello, world’。 但是如果不小心没有传list而是传了一个字符串’hello’，这段代码也不会报错，只是会返回’h, e, l, l, o’这个并不期望的结果。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"><span class="comment">#string_list 局部变量名， List[str] 局部变量类型， str 返回结果类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join(<span class="string">'hello'</span>)<span class="comment">#虽然不期待，但是仍可以运行</span></span><br><span class="line"><span class="string">'h, e, l, l, o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join([<span class="string">'hello'</span>,<span class="string">'world'</span>])</span><br><span class="line"><span class="string">'hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join.__annotations__</span><br><span class="line">&#123;<span class="string">'string_list'</span>: typing.List[str], <span class="string">'return'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>这样声明函数有一个好处，就是不需要在注释里面说明变量类型，更加直观。Python把这种类型的声明看成是一种对函数的注解(annotation)，而注解本身并不具有任何的意义，也不影响运行的过程。与没有注解的版本差别就是多了一个<strong>annotations</strong>的字段 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"></span><br><span class="line">print(join(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure><p>运行以及使用mypy检查，代码可以运行，mypy也可以给出提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 test_mypy.py</span><br><span class="line">h, e, l, l, o</span><br><span class="line">$ mypy test_mypy.py</span><br><span class="line">test_mypy.py:<span class="number">6</span>: error: Argument <span class="number">1</span> to <span class="string">"join"</span> has incompatible type <span class="string">"str"</span>; expected List[str]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas和R中的groupby</title>
      <link href="/2018/09/18/groupby-in-Python-and-R/"/>
      <url>/2018/09/18/groupby-in-Python-and-R/</url>
      
        <content type="html"><![CDATA[<p>groupby 可以根据一个数据框的部分数据，将整个数据框进行分组，简称：聚合。聚合之后，可以按组进行对数据进行统计分析。</p><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</span><br><span class="line">   ....:                    <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">   ....:                    <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df  <span class="comment">#建立一个Dataframe数据框</span></span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> <span class="number">-0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> <span class="number">-0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> <span class="number">-0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df.groupby(<span class="string">'key1'</span>)  <span class="comment">#按key1进行分组</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped  <span class="comment">#得到的grouped一个简单处理的可迭代对象（GroupBy），实际上还没有进行任何计算</span></span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.DataframeGroupBy object at <span class="number">0x0000000000FF07EB8</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()  <span class="comment">#调用GroupBy的mean方法来计算分组平均值：</span></span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.114474</span>  <span class="number">0.714913</span></span><br><span class="line">b     <span class="number">0.300820</span> <span class="number">-1.160967</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).mean()[<span class="string">'data1'</span>]  <span class="comment">#按key1和key2分组，选出data1数据</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    <span class="number">-0.519439</span></span><br><span class="line">      two    <span class="number">-0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</span><br><span class="line">   ....:                       index=[<span class="string">'Joe'</span>, <span class="string">'Steve'</span>, <span class="string">'Wes'</span>, <span class="string">'Jim'</span>, <span class="string">'Travis'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people  <span class="comment">#另建一个数据框，拥有index名</span></span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> <span class="number">-1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span></span><br><span class="line">Wes    <span class="number">-0.539741</span> <span class="number">-2.001001</span> <span class="number">-2.001002</span> <span class="number">-1.021228</span> <span class="number">-0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis <span class="number">-0.713544</span> <span class="number">-0.831154</span> <span class="number">-2.370232</span> <span class="number">-1.860761</span> <span class="number">-0.860757</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(len).sum() <span class="comment">#用python函数分组将使用index</span></span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> <span class="number">-0.993608</span>  <span class="number">0.798764</span> <span class="number">-0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span></span><br><span class="line"><span class="number">6</span> <span class="number">-0.713544</span> <span class="number">-0.831154</span> <span class="number">-2.370232</span> <span class="number">-1.860761</span> <span class="number">-0.860757</span></span><br></pre></td></tr></table></figure><h3 id="聚合运算方法"><a href="#聚合运算方法" class="headerlink" title="聚合运算方法"></a>聚合运算方法</h3><img src="/2018/09/18/groupby-in-Python-and-R/pandas-groupby.png"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></span><br><span class="line">       ....:     <span class="keyword">return</span> arr.max() - arr.min()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)  <span class="comment">#使用自己的聚合函数，将其传入aggregate或agg方法</span></span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: grouped.agg([<span class="string">'mean'</span>,<span class="string">'size'</span>]) <span class="comment">#使用多个统计方法</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">'fuc1'</span>, <span class="string">'mean'</span>),(<span class="string">'fuc2'</span>, np.var)]  <span class="comment">#使用自定义的名字</span></span><br><span class="line">In [<span class="number">70</span>]: grouped.agg(ftuples)</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">'data1'</span> : [<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'std'</span>],  <span class="comment">#不同列可以指定不同的统计方法</span></span><br><span class="line">   ....:              <span class="string">'data2'</span> : [<span class="string">'sum'</span>]&#125;)</span><br></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(dplyr)  <span class="comment">#group_by和summarise都在dplyr包中</span></span><br><span class="line">data &lt;- data.frame(year = rep(<span class="number">2016</span>:<span class="number">2017</span>,<span class="number">6</span>),month = seq(<span class="number">1</span>:<span class="number">12</span>),sales=rep(c(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>),<span class="number">3</span>))</span><br><span class="line">   year month sales</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>     <span class="number">1</span>    <span class="number">10</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>     <span class="number">2</span>    <span class="number">20</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2016</span>     <span class="number">3</span>    <span class="number">30</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2017</span>     <span class="number">4</span>    <span class="number">40</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2016</span>     <span class="number">5</span>    <span class="number">10</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2017</span>     <span class="number">6</span>    <span class="number">20</span></span><br><span class="line"><span class="number">7</span>  <span class="number">2016</span>     <span class="number">7</span>    <span class="number">30</span></span><br><span class="line"><span class="number">8</span>  <span class="number">2017</span>     <span class="number">8</span>    <span class="number">40</span></span><br><span class="line"><span class="number">9</span>  <span class="number">2016</span>     <span class="number">9</span>    <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">2017</span>    <span class="number">10</span>    <span class="number">20</span></span><br><span class="line"><span class="number">11</span> <span class="number">2016</span>    <span class="number">11</span>    <span class="number">30</span></span><br><span class="line"><span class="number">12</span> <span class="number">2017</span>    <span class="number">12</span>    <span class="number">40</span></span><br><span class="line">planes &lt;- group_by(data, year)  <span class="comment">#按年分组</span></span><br><span class="line">delay &lt;- summarise(planes,</span><br><span class="line">                   count = n(),                <span class="comment">#个数</span></span><br><span class="line">                   max_mon = max(month),       <span class="comment">#最大值</span></span><br><span class="line">                   min_mon = min(month),       <span class="comment">#最小值</span></span><br><span class="line">                   avg_sales = mean(sales),    <span class="comment">#平均值</span></span><br><span class="line">                   sum_sales = sum(sales))     <span class="comment">#求和</span></span><br><span class="line"><span class="comment"># A tibble: 2 x 6</span></span><br><span class="line">   year count max_mon min_mon avg_sales sum_sales</span><br><span class="line">  &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>     <span class="number">6</span>      <span class="number">11</span>       <span class="number">1</span>        <span class="number">20</span>       <span class="number">120</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>     <span class="number">6</span>      <span class="number">12</span>       <span class="number">2</span>        <span class="number">30</span>       <span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="常用的摘要函数"><a href="#常用的摘要函数" class="headerlink" title="常用的摘要函数"></a>常用的摘要函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean()    sd()    min()    max()    first()    last()    n()    sum()</span><br><span class="line">median()    <span class="comment">#中位数</span></span><br><span class="line">quantile()    <span class="comment">#分位数，quantile(x，0.25)将会找出x从小到大排列，在25%时的数</span></span><br></pre></td></tr></table></figure><h3 id="聚合函数和逻辑筛选结合"><a href="#聚合函数和逻辑筛选结合" class="headerlink" title="聚合函数和逻辑筛选结合"></a>聚合函数和逻辑筛选结合</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delay &lt;- summarise(planes,</span><br><span class="line">                   avg_sales_1 = mean(sales,na.rm=<span class="literal">TRUE</span>),    </span><br><span class="line">                   <span class="comment">#na.rm=TRUE,遇到NA值时不处理，因为统计时R默认NA值会传播，python不会</span></span><br><span class="line">                   avg_sales_2 = mean(sales[sales&gt;<span class="number">10</span>],na.rm=<span class="literal">TRUE</span>)    <span class="comment">#加入逻辑判断</span></span><br><span class="line">planes &lt;- group_by(data, year)  <span class="comment">#按年分组</span></span><br><span class="line"><span class="comment"># A tibble: 2 x 3</span></span><br><span class="line">   year avg_sales_1 avg_sales_2</span><br><span class="line">  &lt;int&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>         <span class="number">20.</span>         <span class="number">30.</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>         <span class="number">30.</span>         <span class="number">30.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In    [<span class="number">53</span>]: grouped = df[df.data1&gt;<span class="number">0</span>].groupby(<span class="string">'key1'</span>)  <span class="comment">#逻辑筛选后按key1进行分组</span></span><br><span class="line">Out    [<span class="number">53</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.679126</span>  <span class="number">1.013678</span></span><br><span class="line">b     <span class="number">0.300820</span> <span class="number">-1.160967</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python标准库学习（二）</title>
      <link href="/2018/09/18/python-standard-library-2/"/>
      <url>/2018/09/18/python-standard-library-2/</url>
      
        <content type="html"><![CDATA[<h2 id="可迭代对象与迭代器"><a href="#可迭代对象与迭代器" class="headerlink" title="可迭代对象与迭代器"></a>可迭代对象与迭代器</h2><p>可迭代对象与迭代器概念不同。可迭代对象在内部实现了<code>__iter__</code>，所以可以进行迭代，迭代器在内部实现了<code>__iter__</code>和<code>__next__</code>,所以是个迭代器也可以进行迭代。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"> <span class="comment">#mylist是个列表，可以进行迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = （x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)） <span class="comment">#生成器表达式，结果同iter(mylist)</span></span><br><span class="line"><span class="comment">#现在mylist是个迭代器，可以使用.next()方法</span></span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器本质就是一个迭代器，自带了<code>iter</code>方法和<code>next</code>方法。迭代器是用来迭代可迭代对象的，而生成器是用来迭代方法的。调用函数的之后函数不执行，返回一个生成器每次调用<code>next</code>方法的时候会取到一个值直到取完最后一个，再执行next会报错。</p><p>生成器表达式类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。</p><p>比较：</p><ul><li>列表表达式在生成后可以按序列取值，排序，切片等，但是占用内存大。</li><li>生成器表达式只是产生一个可迭代对象，需要时再迭代取值，占用内存小，但是不可进行列表的操作，迭代完后对象清空。</li></ul><hr><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><h3 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product"></a>itertools.product</h3><p>产生多个列表和迭代器的笛卡尔积，可以用product来改写深度嵌套的列表推导操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.product(<span class="string">'ABC'</span>, range(<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'A'</span>, <span class="number">2</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">2</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-accumulate"><a href="#itertools-accumulate" class="headerlink" title="itertools.accumulate"></a>itertools.accumulate</h3><p>简单来说就是累加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.accumulate(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-chain"><a href="#itertools-chain" class="headerlink" title="itertools.chain"></a>itertools.chain</h3><p>连接多个列表或者迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.chain(range(<span class="number">3</span>), range(<span class="number">4</span>), [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-combinations"><a href="#itertools-combinations" class="headerlink" title="itertools.combinations"></a>itertools.combinations</h3><p>求列表或生成器中指定数目的元素不重复的所有组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.combinations(range(<span class="number">4</span>), <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-combinations-with-replacement"><a href="#itertools-combinations-with-replacement" class="headerlink" title="itertools.combinations_with_replacement"></a>itertools.combinations_with_replacement</h3><p>允许重复元素的组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-count"><a href="#itertools-count" class="headerlink" title="itertools.count"></a>itertools.count</h3><p>就是一个计数器,可以指定起始位置和步长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.count(start=<span class="number">20</span>, step=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.islice(x, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>)))</span><br><span class="line">[<span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-cycle"><a href="#itertools-cycle" class="headerlink" title="itertools.cycle"></a>itertools.cycle</h3><p>循环指定的列表和迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.islice(x, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-dropwhile"><a href="#itertools-dropwhile" class="headerlink" title="itertools.dropwhile"></a>itertools.dropwhile</h3><p>按照真值函数丢弃掉列表和迭代器前面的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.dropwhile(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-takewhile"><a href="#itertools-takewhile" class="headerlink" title="itertools.takewhile"></a>itertools.takewhile</h3><p>与dropwhile相反，保留元素直至真值函数值为假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.takewhile(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-filterfalse"><a href="#itertools-filterfalse" class="headerlink" title="itertools.filterfalse"></a>itertools.filterfalse</h3><p>保留对应真值为False的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.filterfalse(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, (<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-groupby"><a href="#itertools-groupby" class="headerlink" title="itertools.groupby"></a>itertools.groupby</h3><p>按照分组函数的值对元素进行分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.groupby(range(<span class="number">10</span>), <span class="keyword">lambda</span> x: x &lt; <span class="number">5</span> <span class="keyword">or</span> x &gt; <span class="number">8</span>)                                                                                                 </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> condition, numbers <span class="keyword">in</span> x:                                                  </span><br><span class="line"><span class="meta">... </span>    print(condition, list(numbers))                                                                                                        </span><br><span class="line"><span class="keyword">True</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]                                                              </span><br><span class="line"><span class="keyword">False</span> [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]                                                                </span><br><span class="line"><span class="keyword">True</span> [<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-islice"><a href="#itertools-islice" class="headerlink" title="itertools.islice"></a>itertools.islice</h3><p>上文使用过的函数，对迭代器进行切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.islice(range(<span class="number">10</span>), <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-repeat"><a href="#itertools-repeat" class="headerlink" title="itertools.repeat"></a>itertools.repeat</h3><p>简单的生成一个拥有指定数目元素的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.repeat(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-zip-longest"><a href="#itertools-zip-longest" class="headerlink" title="itertools.zip_longest"></a>itertools.zip_longest</h3><p>类似于zip，不过已较长的列表和迭代器的长度为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.zip_longest(range(<span class="number">3</span>), range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = zip(range(<span class="number">3</span>), range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="keyword">None</span>, <span class="number">3</span>), (<span class="keyword">None</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(y))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>seqkit 使用说明</title>
      <link href="/2018/09/13/seqkit-usage/"/>
      <url>/2018/09/13/seqkit-usage/</url>
      
        <content type="html"><![CDATA[<p>seqkit 是 Wei Shen 使用 go 语言编写处理 fa 和 fq 文件的一把利器，当前介绍版本为0.9.1。这里不详细介绍各个函数的参数，官方给出的文档已经足够。</p><p>软件地址：<a href="https://github.com/shenwei356/seqkit" target="_blank" rel="noopener">https://github.com/shenwei356/seqkit</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Available Commands:</span><br><span class="line">  common          find common sequences of multiple files by id/name/sequence</span><br><span class="line">  concat          concatenate sequences with same ID from multiple files</span><br><span class="line">  convert         convert FASTQ quality encoding between Sanger, Solexa and Illumina</span><br><span class="line">  duplicate       duplicate sequences N times</span><br><span class="line">  faidx           create FASTA index file and extract subsequence</span><br><span class="line">  fq2fa           convert FASTQ to FASTA</span><br><span class="line">  fx2tab          convert FASTA/Q to tabular format (with length/GC content/GC skew)</span><br><span class="line">  genautocomplete generate shell autocompletion script</span><br><span class="line">  grep            search sequences by ID/name/sequence/sequence motifs, mismatch allowed</span><br><span class="line">  head            print first N FASTA/Q records</span><br><span class="line">  help            Help about any command</span><br><span class="line">  locate          locate subsequences/motifs, mismatch allowed</span><br><span class="line">  range           print FASTA/Q records in a range (start:end)</span><br><span class="line">  rename          rename duplicated IDs</span><br><span class="line">  replace         replace name/sequence by regular expression</span><br><span class="line">  restart         reset start position for circular genome</span><br><span class="line">  rmdup           remove duplicated sequences by id/name/sequence</span><br><span class="line">  sample          sample sequences by number or proportion</span><br><span class="line">  seq             transform sequences (revserse, complement, extract ID...)</span><br><span class="line">  shuffle         shuffle sequences</span><br><span class="line">  sliding         sliding sequences, circular genome supported</span><br><span class="line">  sort            sort sequences by id/name/sequence/length</span><br><span class="line">  split           split sequences into files by id/seq region/size/parts (mainly for FASTA)</span><br><span class="line">  split2          split sequences into files by size/parts (FASTA, PE/SE FASTQ)</span><br><span class="line">  stats           simple statistics of FASTA/Q files</span><br><span class="line">  subseq          get subsequences by region/gtf/bed, including flanking sequences</span><br><span class="line">  tab2fx          convert tabular format to FASTA/Q format</span><br><span class="line">  translate       translate DNA/RNA to protein sequence</span><br><span class="line">  version         print version information and check for update</span><br></pre></td></tr></table></figure><h2 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit seq hairpin.fa.gz  <span class="comment">#展示fa文件</span></span><br><span class="line">&gt;cel-let-7 MI0000001 Caenorhabditis elegans <span class="built_in">let</span>-7 stem-loop</span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC</span><br><span class="line">UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA</span><br><span class="line"></span><br><span class="line">$ seqkit seq read_1.fq.gz  <span class="comment">#展示fq文件</span></span><br><span class="line">@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG</span><br><span class="line">TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG</span><br><span class="line">+</span><br><span class="line">HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit seq hairpin.fa.gz -n  <span class="comment">#展示序列全名</span></span><br><span class="line">cel-let-7 MI0000001 Caenorhabditis elegans <span class="built_in">let</span>-7 stem-loop</span><br><span class="line">cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop</span><br><span class="line">cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop</span><br><span class="line"></span><br><span class="line">$ seqkit seq hairpin.fa.gz -n -i  <span class="comment">#展示序列ID</span></span><br><span class="line">cel-let-7</span><br><span class="line">cel-lin-4</span><br><span class="line">cel-mir-1</span><br><span class="line"></span><br><span class="line">$ seqkit seq hairpin.fa.gz -n -i --id-regexp <span class="string">"^[^\s]+\s([^\s]+)\s"</span>  <span class="comment">#使用正则匹配序列名</span></span><br><span class="line">MI0000001</span><br><span class="line">MI0000002</span><br><span class="line">MI0000003</span><br><span class="line"></span><br><span class="line">$ seqkit seq hairpin.fa.gz -s -w 0  <span class="comment">#只展示序列 并设置每行碱基数为默认</span></span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCG</span><br><span class="line">GAGACAGAACUCUUCGA</span><br><span class="line">AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACG</span><br><span class="line">GUUUGAGCAGAU</span><br><span class="line">AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAG</span><br><span class="line">AACGGGGUGGUAGU</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit seq hairpin.fa.gz -m 50 -M 150   <span class="comment">#过滤fq文件，使序列长度在50-150bp之间。</span></span><br><span class="line"></span><br><span class="line">$ seqkit seq hairpin.fa.gz -r -p  <span class="comment">#反转录序列</span></span><br><span class="line">&gt;cel-let-7 MI0000001 Caenorhabditis elegans <span class="built_in">let</span>-7 stem-loop</span><br><span class="line">UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC</span><br><span class="line">AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq\nACGT-actgc-ACC"</span> | seqkit seq -g -u  <span class="comment">#去除序列gap 并大写碱基</span></span><br><span class="line">&gt;seq</span><br><span class="line">ACGTACTGCACC</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq\nUCAUAUGCUUGUCUCAAAGAUUA"</span> | seqkit seq --rna2dna <span class="comment">#DNA转RNA,--dna2rna亦可</span></span><br><span class="line">&gt;seq</span><br><span class="line">TCATATGCTTGTCTCAAAGATTA</span><br></pre></td></tr></table></figure><h2 id="subseq"><a href="#subseq" class="headerlink" title="subseq"></a>subseq</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ zcat hairpin.fa.gz | seqkit subseq -r 1:12  <span class="comment">#展示序列前12个碱基</span></span><br><span class="line">$ zcat hairpin.fa.gz | seqkit subseq -r -12:-1 <span class="comment">#后12个</span></span><br><span class="line"></span><br><span class="line">$ cat t.fa</span><br><span class="line">&gt;seq</span><br><span class="line">actgACTGactgn</span><br><span class="line">$ cat t.gtf  <span class="comment">#注意gtf文件格式，必须以\t分割。</span></span><br><span class="line">seq    <span class="built_in">test</span>    CDS    5    8    .    .    .    gene_id <span class="string">"A"</span>; transcript_id <span class="string">""</span>;</span><br><span class="line">seq    <span class="built_in">test</span>    CDS    5    8    .    -    .    gene_id <span class="string">"B"</span>; transcript_id <span class="string">""</span>;</span><br><span class="line">$ seqkit subseq --gtf t.gtf t.fa  <span class="comment">#使用gtf位置信息，挑选fa序列</span></span><br><span class="line">&gt;seq_5:8:. A</span><br><span class="line">ACTG</span><br><span class="line">&gt;seq_5:8:- B</span><br><span class="line">CAGT</span><br><span class="line"></span><br><span class="line">$ seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa</span><br><span class="line"> &gt; chr1.gtf.cds.fa  <span class="comment">#指定染色体和特征</span></span><br><span class="line"></span><br><span class="line">$ seqkit subseq --gtf t.gtf t.fa -u 3  <span class="comment">#另加3bp上游序列</span></span><br><span class="line">&gt;seq_5:8:._us:3 A</span><br><span class="line">ctgACTG</span><br><span class="line">&gt;seq_5:8:-_us:3 B</span><br><span class="line">agtCAGT</span><br><span class="line"></span><br><span class="line">$ seqkit subseq --gtf t.gtf t.fa -u 3 -f  <span class="comment">#只取上游3bp序列</span></span><br><span class="line">&gt;seq_5:8:._usf:3 A</span><br><span class="line">ctg</span><br><span class="line">&gt;seq_5:8:-_usf:3 B</span><br><span class="line">agt</span><br></pre></td></tr></table></figure><p>gff3 文件第九列格式为ID=XXXXX; gtf 文件第九列格式为 gene_id “A”; transcript_id “”;</p><h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit stats *.f&#123;a,q&#125;.gz  <span class="comment">#统计序列信息</span></span><br><span class="line">file             format     <span class="built_in">type</span>     num_seqs     sum_len     min_len     avg_len     max_len</span><br><span class="line">hairpin.fa.gz      FASTA     RNA      28,645      2,949,871      39          103         2,354</span><br><span class="line">mature.fa.gz      FASTA      RNA      35,828      781,222      15          21.8         34</span><br><span class="line">reads_1.fq.gz      FASTQ      DNA      2,500          567,516      226         227         229</span><br><span class="line">reads_2.fq.gz      FASTQ      DNA      2,500          560,002      223          224         225</span><br><span class="line">$ seqkit stats *.f&#123;a,q&#125;.gz  -a  <span class="comment">#列出所有统计结果</span></span><br><span class="line">file               format  <span class="built_in">type</span>  num_seqs    sum_len  min_len  avg_len  max_len   Q1   Q2   Q3  sum_gap  N50  Q20(%)  Q30(%)</span><br><span class="line">hairpin.fa.gz      FASTA   RNA     28,645  2,949,871       39      103    2,354   76   91  111        0  101       0       0</span><br><span class="line">mature.fa.gz       FASTA   RNA     35,828    781,222       15     21.8       34   21   22   22        0   22       0       0</span><br><span class="line">Illimina1.8.fq.gz  FASTQ   DNA     10,000  1,500,000      150      150      150  150  150  150        0  150   96.16   89.71</span><br><span class="line">reads_1.fq.gz      FASTQ   DNA      2,500    567,516      226      227      229  227  227  227        0  227   91.24   86.62</span><br><span class="line">reads_2.fq.gz      FASTQ   DNA      2,500    560,002      223      224      225  224  224  224        0  224   91.06   87.66</span><br></pre></td></tr></table></figure><h2 id="faidx"><a href="#faidx" class="headerlink" title="faidx"></a>faidx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit faidx hairpin.fa  <span class="comment">#建立序列索引</span></span><br><span class="line">&gt;hsa-let-7a-1</span><br><span class="line">UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU</span><br><span class="line">ACAAUCUACUGUCUUUCCUA</span><br><span class="line">&gt;hsa-let-7a-2</span><br><span class="line">AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU</span><br><span class="line">CCUAGCUUUCCU</span><br></pre></td></tr></table></figure><h2 id="fq2fa"><a href="#fq2fa" class="headerlink" title="fq2fa"></a>fq2fa</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit fq2fa reads_1.fq.gz -o reads1_.fa.gz  <span class="comment">#fq转fa</span></span><br></pre></td></tr></table></figure><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit head -n 1 tests/Illimina1.8.fq.gz</span><br><span class="line">...</span><br><span class="line"><span class="comment">#AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJ</span></span><br><span class="line">JJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;</span><br><span class="line"></span><br><span class="line">$ seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1  <span class="comment">#默认转换fq文件质量值到1.8+</span></span><br><span class="line">[INFO] possible quality encodings: [Illumina-1.8+]</span><br><span class="line">[INFO] guessed quality encoding: Illumina-1.8+</span><br><span class="line">[INFO] converting Illumina-1.8+ -&gt; Sanger</span><br><span class="line">[WARN] <span class="built_in">source</span> and target quality encoding match.</span><br><span class="line">...</span><br><span class="line"><span class="comment">#AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJ</span></span><br><span class="line">JJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;</span><br><span class="line"></span><br><span class="line">$ seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1</span><br><span class="line">[INFO] possible quality encodings: [Illumina-1.8+] </span><br><span class="line">[INFO] guessed quality encoding: Illumina-1.8+</span><br><span class="line">[INFO] converting Illumina-1.8+ -&gt; Illumina-1.5+  <span class="comment">#转换 Illumina1.8+ -&gt; Illumina1.5+</span></span><br><span class="line">...</span><br><span class="line">B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iii</span><br><span class="line">iieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa  <span class="comment">#正则匹配序列名</span></span><br><span class="line">&gt;hsa-let-7a-1 MI0000060 Homo sapiens <span class="built_in">let</span>-7a-1 stem-loop</span><br><span class="line">UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU</span><br><span class="line">ACAAUCUACUGUCUUUCCUA</span><br><span class="line">&gt;hsa-let-7a-2 MI0000061 Homo sapiens <span class="built_in">let</span>-7a-2 stem-loop</span><br><span class="line">AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU</span><br><span class="line">CCUAGCUUUCCU</span><br><span class="line"></span><br><span class="line">$ zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v  <span class="comment">#2个条件并取反</span></span><br><span class="line"></span><br><span class="line">$ zcat hairpin.fa.gz | seqkit grep -f list &gt; new.fa  <span class="comment">#将需要提取的序列名放在list中</span></span><br><span class="line"></span><br><span class="line">$ zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg  <span class="comment">#正则匹配序列碱基，-i 忽略大小写</span></span><br><span class="line"></span><br><span class="line">$ seqkit grep -s -R 1:30 -i -r -p GCTGG  <span class="comment">#-R 在前30个碱基中正则匹配</span></span><br></pre></td></tr></table></figure><h2 id="rmdup"><a href="#rmdup" class="headerlink" title="rmdup"></a>rmdup</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz <span class="comment">#去除重复的序列</span></span><br><span class="line">[INFO] 2226 duplicated records removed</span><br><span class="line"></span><br><span class="line">$ zcat hairpin.fa.gz | seqkit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D</span><br><span class="line"> duplicated.detail.txt <span class="comment">#-d输出重复序列，-D统计重复序列</span></span><br><span class="line">$ cat duplicated.detail.txt <span class="comment"># here is not the entire list</span></span><br><span class="line">3 hsa-mir-424, mml-mir-424, ppy-mir-424</span><br><span class="line">3 hsa-mir-342, mml-mir-342, ppy-mir-342</span><br><span class="line">2 ngi-mir-932, nlo-mir-932</span><br><span class="line">2 ssc-mir-9784-1, ssc-mir-9784-2</span><br></pre></td></tr></table></figure><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit common file*.fa -o common.fasta  <span class="comment">#通过ID寻找共同序列</span></span><br><span class="line">$ seqkit common file*.fa -n -o common.fasta  <span class="comment">#通过全名</span></span><br><span class="line">$ seqkit common file*.fa -s -i -o common.fasta  <span class="comment">#通过序列</span></span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit split hairpin.fa.gz -s 10000  <span class="comment">#按序列数分割文件</span></span><br><span class="line">[INFO] split into 10000 seqs per file</span><br><span class="line">[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz</span><br><span class="line">[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz</span><br><span class="line">[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz </span><br><span class="line"></span><br><span class="line">$ seqkit split hairpin.fa.gz -p 4  <span class="comment">#按文件个数分割文件</span></span><br><span class="line">[INFO] split into 4 parts</span><br><span class="line">[INFO] <span class="built_in">read</span> sequences ...</span><br><span class="line">[INFO] <span class="built_in">read</span> 28645 sequences</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz</span><br><span class="line">[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz</span><br><span class="line"></span><br><span class="line">$ seqkit split hairpin.fa.gz -p 4 -2  <span class="comment">#-2减少内存使用</span></span><br><span class="line">[INFO] split into 4 parts</span><br><span class="line">[INFO] <span class="built_in">read</span> and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] create and <span class="built_in">read</span> FASTA index ...</span><br><span class="line">[INFO] <span class="built_in">read</span> sequence IDs from FASTA index ...</span><br><span class="line">[INFO] 28645 sequences loaded</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_001.fa.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_002.fa.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_003.fa.gz</span><br><span class="line">[INFO] write 7159 sequences to file: hairpin.part_004.fa.gz</span><br><span class="line"></span><br><span class="line">$ seqkit split hairpin.fa.gz -i --id-regexp <span class="string">"^([\w]+)\-"</span> -2  <span class="comment">#按ID</span></span><br><span class="line">[INFO] split by ID. idRegexp: ^([\w]+)\-</span><br><span class="line">[INFO] <span class="built_in">read</span> and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] create and <span class="built_in">read</span> FASTA index ...</span><br><span class="line">[INFO] create FASTA index <span class="keyword">for</span> hairpin.fa.gz.fa</span><br><span class="line">[INFO] <span class="built_in">read</span> sequence IDs from FASTA index ...</span><br><span class="line">[INFO] 28645 sequences loaded</span><br><span class="line">[INFO] write 48 sequences to file: hairpin.id_cca.fa.gz</span><br><span class="line">[INFO] write 3 sequences to file: hairpin.id_hci.fa.gz</span><br><span class="line"></span><br><span class="line">$ seqkit split hairpin.fa.gz -r 1:3 -2  <span class="comment">#按前3个碱基</span></span><br><span class="line">[INFO] split by region: 1:3</span><br><span class="line">[INFO] <span class="built_in">read</span> and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] <span class="built_in">read</span> sequence IDs and sequence region from FASTA file ...</span><br><span class="line">[INFO] create and <span class="built_in">read</span> FASTA index ...</span><br><span class="line">[INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz</span><br><span class="line">[INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz</span><br><span class="line">[INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz</span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat hairpin.fa | seqkit range -r 101:150  <span class="comment">#输出范围内的序列（1:12 如同 head -n 12）</span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet  <span class="comment">#按ID排序，--quiet不输出提示信息</span></span><br><span class="line">&gt;SEQ2</span><br><span class="line">acgtnAAAA</span><br><span class="line">&gt;seq1</span><br><span class="line">ACGTNcccc</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet -i  <span class="comment">#不区分大小写</span></span><br><span class="line">&gt;seq1</span><br><span class="line">ACGTNcccc</span><br><span class="line">&gt;SEQ2</span><br><span class="line">acgtnAAAA</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet -i -r <span class="comment">#不区分大小写，反转结果</span></span><br><span class="line">&gt;SEQ2</span><br><span class="line">acgtnAAAA</span><br><span class="line">&gt;seq1</span><br><span class="line">ACGTNcccc</span><br><span class="line">$ <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAAnnn\n&gt;seq3\nacgt"</span> | seqkit sort --quiet -l  <span class="comment">#按序列长度</span></span><br><span class="line">&gt;seq3</span><br><span class="line">acgt</span><br><span class="line">&gt;seq1</span><br><span class="line">ACGTNcccc</span><br><span class="line">&gt;SEQ2</span><br><span class="line">acgtnAAAAnnn</span><br></pre></td></tr></table></figure><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ seqkit translate tests/mouse-p53-cds.fna  <span class="comment">#将DNA/RNA 翻译为蛋白序列</span></span><br><span class="line">&gt;lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]</span><br><span class="line">MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA</span><br><span class="line">LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM</span><br><span class="line">CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS</span><br><span class="line">DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM</span><br><span class="line">GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS</span><br><span class="line">AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR</span><br><span class="line">AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD*</span><br><span class="line"></span><br><span class="line">$ seqkit translate tests/mouse-p53-cds.fna --trim  <span class="comment">#去掉 */X（终止密码子）</span></span><br><span class="line">&gt;lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]</span><br><span class="line">MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA</span><br><span class="line">LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM</span><br><span class="line">CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS</span><br><span class="line">DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM</span><br><span class="line">GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS</span><br><span class="line">AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR</span><br><span class="line">AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> bioinfo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python标准库学习（一）</title>
      <link href="/2018/09/11/python-standard-library-1/"/>
      <url>/2018/09/11/python-standard-library-1/</url>
      
        <content type="html"><![CDATA[<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>该模块实现专门的容器数据类型，提供Python通用内置容器（<code>dict，set，list，tuple</code>）的替代方案。</p><table><thead><tr><th style="text-align:left"><code>nametuple()</code></th><th style="text-align:left">工厂函数用于创建带有命名字段的元组子类</th></tr></thead><tbody><tr><td style="text-align:left"><code>deque()</code></td><td style="text-align:left">列表式容器，在两端有快速附加和弹出</td></tr><tr><td style="text-align:left"><code>ChainMap()</code></td><td style="text-align:left">类似于类的类，用于创建多个映射的单个视图</td></tr><tr><td style="text-align:left"><code>Counter ()</code></td><td style="text-align:left">dict子类用于计算hashable对象</td></tr><tr><td style="text-align:left"><code>OrderedDict ()</code></td><td style="text-align:left">dict子类，记住已添加的条目的顺序</td></tr><tr><td style="text-align:left"><code>defaultdict ()</code></td><td style="text-align:left">dict子类调用一个工厂函数时提供缺失值</td></tr><tr><td style="text-align:left"><code>UserDict ()</code></td><td style="text-align:left">包装字典对象，更容易dict子类化</td></tr><tr><td style="text-align:left"><code>UserList ()</code></td><td style="text-align:left">包装列表对象以方便列表子类化</td></tr><tr><td style="text-align:left"><code>UserString()</code></td><td style="text-align:left">包装字符串对象，更容易字符串子类化</td></tr></tbody></table><h3 id="ChainMap"><a href="#ChainMap" class="headerlink" title="ChainMap"></a>ChainMap</h3><p><code>ChainMap</code>用来将多个dict(字典)组成一个list(只是比喻)，可以理解成合并多个字典，但和<code>update</code>不同，而且效率更高。</p><p><code>ChainMap</code>用来将多个dict组成一个list之后，多个dict之间的键不冲突。当多个dict有重复键时，使用get方法：如<code>chainMap.get(&#39;name&#39;)</code>将会返回第一个dict[‘name’]。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建ChainMap及它的结构</span></span><br><span class="line">In[<span class="number">2</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line">In[<span class="number">3</span>]: m1 = &#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'user'</span>: <span class="string">'guest'</span>&#125;</span><br><span class="line">In[<span class="number">4</span>]: m2 = &#123;<span class="string">'name'</span>: <span class="string">'drfish'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;</span><br><span class="line">In[<span class="number">5</span>]: chainMap = ChainMap(m1, m2)</span><br><span class="line">In[<span class="number">6</span>]: print(chainMap.items())</span><br><span class="line">ItemsView(ChainMap(&#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'user'</span>: <span class="string">'guest'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'drfish'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ChainMap中的元素</span></span><br><span class="line">In[<span class="number">7</span>]: print(chainMap.get(<span class="string">'name'</span>))</span><br><span class="line">drfish</span><br><span class="line">In[<span class="number">8</span>]: print(chainMap.get(<span class="string">'not'</span>))</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增map</span></span><br><span class="line">In[<span class="number">9</span>]: m3 = &#123;<span class="string">'name'</span>: <span class="string">'boy'</span>&#125;</span><br><span class="line">In[<span class="number">10</span>]: chainMap = chainMap.new_child(m3)</span><br><span class="line">In[<span class="number">11</span>]: print(chainMap.items())</span><br><span class="line">ItemsView(ChainMap(&#123;<span class="string">'name'</span>: <span class="string">'boy'</span>&#125;, &#123;<span class="string">'color'</span>: <span class="string">'red'</span>, <span class="string">'user'</span>: <span class="string">'guest'</span>&#125;, &#123;<span class="string">'name'</span>: <span class="string">'drfish'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;))</span><br><span class="line">In[<span class="number">12</span>]: print(chainMap.get(<span class="string">'name'</span>))</span><br><span class="line"><span class="string">'boy'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#一次遍历多个字典</span></span><br><span class="line">In[<span class="number">13</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> chainMap.maps:</span><br><span class="line">    print(<span class="string">"----------------"</span>)</span><br><span class="line">    <span class="keyword">for</span> mykey <span class="keyword">in</span> i.keys():</span><br><span class="line">        print(mykey,i[mykey])</span><br><span class="line">     </span><br><span class="line">----------------</span><br><span class="line">name boy</span><br><span class="line">----------------</span><br><span class="line">color red</span><br><span class="line">user guest</span><br><span class="line">----------------</span><br><span class="line">name drfish</span><br><span class="line">age <span class="number">18</span></span><br></pre></td></tr></table></figure><h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><p>Counter是一个简单的计数器，使用起来非常方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=<span class="number">-2</span>) <span class="comment">#不大于0的全部忽略</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(c.elements())</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Counter(<span class="string">'abracadabra'</span>).most_common(<span class="number">3</span>)  <span class="comment">#返回出现次数最多的字符</span></span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">5</span>), (<span class="string">'r'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt = Counter() <span class="comment"># 统计列表中元素出现的个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> word <span class="keyword">in</span> [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'blue'</span>]:</span><br><span class="line"><span class="meta">... </span> cnt[word] += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt</span><br><span class="line">Counter(&#123;<span class="string">'blue'</span>: <span class="number">3</span>, <span class="string">'red'</span>: <span class="number">2</span>, <span class="string">'green'</span>: <span class="number">1</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt = Counter() <span class="comment"># 统计字符串中元素出现的个数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> ch <span class="keyword">in</span> <span class="string">'hello'</span>:</span><br><span class="line"><span class="meta">... </span>    cnt[ch] = cnt[ch] + <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cnt</span><br><span class="line">Counter(&#123;<span class="string">'l'</span>: <span class="number">2</span>, <span class="string">'o'</span>: <span class="number">1</span>, <span class="string">'h'</span>: <span class="number">1</span>, <span class="string">'e'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque就是一个双端队列，与list非常相似，不过可以同时在list的左边增删元素，支持线程安全 ，从队列两端添加或弹出元素的复杂度都是O(1)，而从列表的头部插入或移除元素时，列表的复杂度为O(N)。 deque和list从中部处理数据复杂度都为为O(N)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">72</span>]: dq = deque(<span class="string">'abc'</span>)</span><br><span class="line">In[<span class="number">73</span>]: dq</span><br><span class="line">Out[<span class="number">73</span>]: deque([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">In[<span class="number">74</span>]: dq.append(<span class="string">'A'</span>)</span><br><span class="line">In[<span class="number">75</span>]: dq.appendleft(<span class="string">'Z'</span>)</span><br><span class="line">In[<span class="number">76</span>]: dq</span><br><span class="line">Out[<span class="number">76</span>]: deque([<span class="string">'Z'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'A'</span>])</span><br><span class="line">In[<span class="number">77</span>]: dq.popleft()</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">'Z'</span></span><br><span class="line">In[<span class="number">78</span>]: dq.extendleft(<span class="string">"hello"</span>)</span><br><span class="line">In[<span class="number">79</span>]: dq</span><br><span class="line">Out[<span class="number">79</span>]: deque([<span class="string">'o'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'A'</span>])</span><br></pre></td></tr></table></figure><h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><p>使用 <code>list</code> 作为 <code>default_factory</code>，很容易将键值对的序列分组到列表的字典,类似<code>setdefault</code></p><p>当第一次遇到每个键时，它不在映射中；因此使用返回空 <code>list</code> 的 <code>default_factory</code> 函数自动创建一个条目。然后，<code>list.append()</code> 操作将值附加到新列表。当再次遇到键时，查找继续正常（返回该键的列表），<code>list.append()</code> 操作将另一个值添加到列表。这种技术比使用 <code>dict.setdefault()</code> 的等效技术更简单和更快</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    d[k].append(v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [(<span class="string">'yellow'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'yellow'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    d.setdefault(k,[]).append(v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'blue'</span>, [<span class="number">2</span>, <span class="number">4</span>]), (<span class="string">'red'</span>, [<span class="number">1</span>]), (<span class="string">'yellow'</span>, [<span class="number">1</span>, <span class="number">3</span>])]</span><br></pre></td></tr></table></figure><p>将 <code>default_factory</code> 设置为<code>int</code> 使 <code>defaultdict</code> 可用于计数,当首次遇到字母时，映射中缺少字母，因此 <code>default_factory</code> 函数调用 <a href="https://www.rddoc.com/doc/Python/3.6.0/zh/library/functions/#int" target="_blank" rel="noopener"><code>int()</code></a> 以提供默认计数为零。增量操作然后建立每个字母的计数。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'mississippi'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    d[k] += <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'i'</span>, <span class="number">4</span>), (<span class="string">'m'</span>, <span class="number">1</span>), (<span class="string">'p'</span>, <span class="number">2</span>), (<span class="string">'s'</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><p>将 <code>default_factory</code> 设置为 <code>set</code>使得 <code>defaultdict</code> 可用于构建集合的字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = [(<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">2</span>), (<span class="string">'red'</span>, <span class="number">3</span>), (<span class="string">'blue'</span>, <span class="number">4</span>), (<span class="string">'red'</span>, <span class="number">1</span>), (<span class="string">'blue'</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = defaultdict(set)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> k, v <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    d[k].add(v)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(d.items())</span><br><span class="line">[(<span class="string">'blue'</span>, &#123;<span class="number">2</span>, <span class="number">4</span>&#125;), (<span class="string">'red'</span>, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;)]</span><br></pre></td></tr></table></figure><h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><p>有序字典与常规字典类似，但它们记住项目插入的顺序。在对有序字典进行迭代时，项目按它们的键首次添加的顺序返回。 </p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-underscore</title>
      <link href="/2018/09/10/python-underscore/"/>
      <url>/2018/09/10/python-underscore/</url>
      
        <content type="html"><![CDATA[<h2 id="name"><a href="#name" class="headerlink" title="_name"></a>_name</h2><p>以单下划线开头，表示这是一个<strong>保护成员</strong>，只有类对象和子类对象自己能访问到这些变量。以单下划线开头的变量和函数被默认当作是内部函数，使用<code>from module improt *</code>时不会被获取，但是使用<code>import module</code>可以获取</p><h2 id="name-1"><a href="#name-1" class="headerlink" title="name_"></a>name_</h2><p>以单下划线结尾仅仅是为了区别该名称与关键词</p><h2 id="name-2"><a href="#name-2" class="headerlink" title="__name"></a>__name</h2><p>双下划线开头，表示为<strong>私有成员</strong>，只允许类本身访问，子类也不行。在文本上被替换为<code>_class__method</code></p><h2 id="name-3"><a href="#name-3" class="headerlink" title="name"></a><strong>name</strong></h2><p>双下划线开头，双下划线结尾。一种约定，Python内部的名字，用来区别其他用户自定义的命名,以防冲突。是一些 Python 的“魔术”对象，表示这是一个特殊成员，例如：定义类的时候，若是添加<strong>init</strong>方法，那么在创建类的实例的时候，实例会自动调用这个方法，一般用来对实例的属性进行初使化，Python不建议将自己命名的方法写为这种形式</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ruby部分代码风格</title>
      <link href="/2018/09/10/ruby-guide-tips/"/>
      <url>/2018/09/10/ruby-guide-tips/</url>
      
        <content type="html"><![CDATA[<p>每个缩排层级使用两个<strong>空格</strong>。不要使用制表符.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差 - 四个空格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span></span></span><br><span class="line">    do_something</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span></span></span><br><span class="line">  do_something</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>范围的字面量语法中，不要添加任何空格。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="number">1</span> .. <span class="number">3</span></span><br><span class="line"><span class="string">'a'</span> ... <span class="string">'z'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="number">1</span>..<span class="number">3</span></span><br><span class="line"><span class="string">'a'</span>...<span class="string">'z'</span></span><br></pre></td></tr></table></figure><p>使用 <code>_</code> 语法改善大数的数值字面量的可读性。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差 - 有几个零？</span></span><br><span class="line">num = <span class="number">1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好 - 方便人脑理解</span></span><br><span class="line">num = <span class="number">1_000_000</span></span><br></pre></td></tr></table></figure><p>使用 <code>def</code> 定义方法时，如果有参数则使用括号，如果无参数则省略括号。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span><span class="params">()</span></span></span><br><span class="line">  <span class="comment"># 省略主体</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span></span></span><br><span class="line">  <span class="comment"># 省略主体</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method_with_parameters</span> <span class="title">param1</span>, <span class="title">param2</span></span></span><br><span class="line">  <span class="comment"># 省略主体</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method_with_parameters</span><span class="params">(param1, param2)</span></span></span><br><span class="line">  <span class="comment"># 省略主体</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>除非必要，否则避免在并行赋值时使用单字符的 <code>_</code> 变量。优先考虑前缀形式的下划线变量，而不是直接使用 <code>_</code>，因为前者可以提供一定的语义信息。但当赋值语句左侧出现带 <code>*</code> 操作符的变量时，使用 <code>_</code> 也是可以接受的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">'one,two,three,four,five'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差 _可有可无，且无任何有用信息</span></span><br><span class="line">first, second, <span class="number">_</span> = foo.split(<span class="string">','</span>)</span><br><span class="line">first, <span class="number">_</span>, <span class="number">_</span> = foo.split(<span class="string">','</span>)</span><br><span class="line">first, *<span class="number">_</span> = foo.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好 _可有可无，但提供了额外信息</span></span><br><span class="line">first, _second = foo.split(<span class="string">','</span>)</span><br><span class="line">first, _second, = foo.split(<span class="string">','</span>)</span><br><span class="line">first, *_ending = foo.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好 _占位符，_ 担当最后一个元素</span></span><br><span class="line">*beginning, <span class="number">_</span> = foo.split(<span class="string">','</span>)</span><br><span class="line">*beginning, something, <span class="number">_</span> = foo.split(<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>永远不要使用 <code>for</code>， 除非你很清楚为什么。大部分情况下，你应该使用迭代器。<code>for</code> 是由 <code>each</code> 实现的，所以你绕弯了。另外，<code>for</code> 没有引入一个新的作用域 (<code>each</code> 有），因此在它内部定义的变量在外部仍是可见的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> arr <span class="keyword">do</span></span><br><span class="line">  puts elem</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，elem 可在 for 循环外部被访问</span></span><br><span class="line">elem <span class="comment"># =&gt; 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">arr.each &#123; <span class="params">|elem|</span> puts elem &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，elem 不可在 each 块外部被访问</span></span><br><span class="line">elem <span class="comment"># =&gt; NameError: undefined local variable or method `elem'</span></span><br></pre></td></tr></table></figure><p>倾向使用三元操作符（<code>?:</code>）而不是 <code>if/then/else/end</code> 结构。前者更为常见且简练。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">result = <span class="keyword">if</span> some_condition <span class="keyword">then</span> something <span class="keyword">else</span> something_else <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">result = some_condition ? something : something_else</span><br></pre></td></tr></table></figure><p>永远不要使用 <code>if x; ...</code>。使用三元操作符来替代。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">result = <span class="keyword">if</span> some_condition; something <span class="keyword">else</span> something_else <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">result = some_condition ? something : something_else</span><br></pre></td></tr></table></figure><p>使用 <code>!</code> 而不是 <code>not</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差 - 因为操作符的优先级，这里必须使用括号</span></span><br><span class="line">x = (<span class="keyword">not</span> something)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">x = !something</span><br></pre></td></tr></table></figure><p>永远不要使用 <code>and</code> 与 <code>or</code> 关键字。使用 <code>&amp;&amp;</code> 与 <code>||</code> 来替代。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="comment"># 布尔表达式</span></span><br><span class="line">ok = got_needed_arguments <span class="keyword">and</span> arguments_are_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流程控制</span></span><br><span class="line">document.save <span class="keyword">or</span> fail(RuntimeError, <span class="string">"Failed to save document!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="comment"># 布尔表达式</span></span><br><span class="line">ok = got_needed_arguments &amp;&amp; arguments_are_valid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流程控制</span></span><br><span class="line">fail(RuntimeError, <span class="string">"Failed to save document!"</span>) <span class="keyword">unless</span> document.save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流程控制</span></span><br><span class="line">document.save <span class="params">||</span> fail(RuntimeError, <span class="string">"Failed to save document!"</span>)</span><br></pre></td></tr></table></figure><p>对于单行主体，倾向使用 <code>{...}</code> 而不是 <code>do...end</code>。对于多行主体，避免使用 <code>{...}</code>。对于“流程控制”或“方法定义”（比如 Rakefile、其他 DSL 构成片段），总是使用 <code>do...end</code>。避免在链式方法调用中使用 <code>do...end</code>.</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">names = <span class="string">%w[Bozhidar Steve Sarah]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 差</span></span><br><span class="line">names.each <span class="keyword">do</span> <span class="params">|name|</span></span><br><span class="line">  puts name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">names.each &#123; <span class="params">|name|</span> puts name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 差</span></span><br><span class="line">names.select <span class="keyword">do</span> <span class="params">|name|</span></span><br><span class="line">  name.start_with?(<span class="string">'S'</span>)</span><br><span class="line"><span class="keyword">end</span>.map &#123; <span class="params">|name|</span> name.upcase &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">names.select &#123; <span class="params">|name|</span> name.start_with?(<span class="string">'S'</span>) &#125;.map(&amp;<span class="symbol">:upcase</span>)</span><br></pre></td></tr></table></figure><p>某些人可能会争论在多行链式方法调用时使用 <code>{...}</code> 看起来还可以。但他们应该扪心自问——这样的代码真的可读吗？难道不能把区块内容提取出来放到小巧的方法里吗？ #我觉得写成代码块易读。</p><p>避免在不需要流程控制的情况下使用 <code>return</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span><span class="params">(some_arr)</span></span></span><br><span class="line">  <span class="keyword">return</span> some_arr.size</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_method</span><span class="params">(some_arr)</span></span></span><br><span class="line">  some_arr.size</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>嗯。。。很魔幻。</p><p>通过使用范围或 <code>Comparable#between?</code> 来替代复杂的比较逻辑。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">do_something <span class="keyword">if</span> x &gt;= <span class="number">1000</span> &amp;&amp; x &lt;= <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">do_something <span class="keyword">if</span> (<span class="number">1000</span>..<span class="number">2000</span>).<span class="keyword">include</span>?(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">do_something <span class="keyword">if</span> x.between?(<span class="number">1000</span>, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>当创建一组元素为单词（没有空格或特殊字符）的数组时，倾向使用 <code>%w</code> 而不是 <code>[]</code>。此规则只适用于数组元素有两个或以上的时候。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">STATES = [<span class="string">'draft'</span>, <span class="string">'open'</span>, <span class="string">'closed'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">STATES = <span class="string">%w[draft open closed]</span></span><br></pre></td></tr></table></figure><p>倾向使用符号而不是字符串作为哈希键。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">hash = &#123; <span class="string">'one'</span> =&gt; <span class="number">1</span>, <span class="string">'two'</span> =&gt; <span class="number">2</span>, <span class="string">'three'</span> =&gt; <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">hash = &#123; <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>倾向使用 <code>Hash#each_key</code> 而不是 <code>Hash#keys.each</code>，使用 <code>Hash#each_value</code> 而不是 <code>Hash#values.each</code>。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 差</span></span><br><span class="line">hash.keys.each &#123; <span class="params">|k|</span> p k &#125;</span><br><span class="line">hash.values.each &#123; <span class="params">|v|</span> p v &#125;</span><br><span class="line">hash.each &#123; <span class="params">|k, _v|</span> p k &#125;</span><br><span class="line">hash.each &#123; <span class="params">|_k, v|</span> p v &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好</span></span><br><span class="line">hash.each_key &#123; <span class="params">|k|</span> p k &#125;</span><br><span class="line">hash.each_value &#123; <span class="params">|v|</span> p v &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ruby </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas学习（二）</title>
      <link href="/2018/09/06/pandas-2/"/>
      <url>/2018/09/06/pandas-2/</url>
      
        <content type="html"><![CDATA[<h2 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h2><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。对于有数据库经验的用户，这就像在索引标签上进行自动外连接。看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">150</span>]: s1 = pd.Series([<span class="number">7.3</span>, <span class="number">-2.5</span>, <span class="number">3.4</span>, <span class="number">1.5</span>], index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: s2 = pd.Series([<span class="number">-2.1</span>, <span class="number">3.6</span>, <span class="number">-1.5</span>, <span class="number">4</span>, <span class="number">3.1</span>],</span><br><span class="line">   .....:                index=[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: s1</span><br><span class="line">Out[<span class="number">152</span>]: </span><br><span class="line">a    <span class="number">7.3</span></span><br><span class="line">c   <span class="number">-2.5</span></span><br><span class="line">d    <span class="number">3.4</span></span><br><span class="line">e    <span class="number">1.5</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: s2</span><br><span class="line">Out[<span class="number">153</span>]: </span><br><span class="line">a   <span class="number">-2.1</span></span><br><span class="line">c    <span class="number">3.6</span></span><br><span class="line">e   <span class="number">-1.5</span></span><br><span class="line">f    <span class="number">4.0</span></span><br><span class="line">g    <span class="number">3.1</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>将它们相加就会产生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">154</span>]: s1 + s2</span><br><span class="line">Out[<span class="number">154</span>]: </span><br><span class="line">a    <span class="number">5.2</span></span><br><span class="line">c    <span class="number">1.1</span></span><br><span class="line">d    NaN</span><br><span class="line">e    <span class="number">0.0</span></span><br><span class="line">f    NaN</span><br><span class="line">g    NaN</span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播。</p><p>对于DataFrame，对齐操作会同时发生在行和列上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">155</span>]: df1 = pd.DataFrame(np.arange(<span class="number">9.</span>).reshape((<span class="number">3</span>, <span class="number">3</span>)), columns=list(<span class="string">'bcd'</span>),</span><br><span class="line">   .....:                    index=[<span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Colorado'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">156</span>]: df2 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)), columns=list(<span class="string">'bde'</span>),</span><br><span class="line">   .....:                    index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">157</span>]: df1</span><br><span class="line">Out[<span class="number">157</span>]: </span><br><span class="line">            b    c    d</span><br><span class="line">Ohio      <span class="number">0.0</span>  <span class="number">1.0</span>  <span class="number">2.0</span></span><br><span class="line">Texas     <span class="number">3.0</span>  <span class="number">4.0</span>  <span class="number">5.0</span></span><br><span class="line">Colorado  <span class="number">6.0</span>  <span class="number">7.0</span>  <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: df2</span><br><span class="line">Out[<span class="number">158</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br></pre></td></tr></table></figure><p>把它们相加后将会返回一个新的DataFrame，其索引和列为原来那两个DataFrame的并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">159</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">159</span>]: </span><br><span class="line">            b   c     d   e</span><br><span class="line">Colorado  NaN NaN   NaN NaN</span><br><span class="line">Ohio      <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Oregon    NaN NaN   NaN NaN</span><br><span class="line">Texas     <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br><span class="line">Utah      NaN NaN   NaN NaN</span><br></pre></td></tr></table></figure><p>因为’c’和’e’列均不在两个DataFrame对象中，在结果中以缺省值呈现。行也是同样。</p><h3 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h3><p>在对不同索引的对象进行算术运算时，你可能希望当一个对象中某个轴标签在另一个对象中找不到时填充一个特殊值（比如0）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">165</span>]: df1 = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                    columns=list(<span class="string">'abcd'</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: df2 = pd.DataFrame(np.arange(<span class="number">20.</span>).reshape((<span class="number">4</span>, <span class="number">5</span>)),</span><br><span class="line">   .....:                    columns=list(<span class="string">'abcde'</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: df2.loc[<span class="number">1</span>, <span class="string">'b'</span>] = np.nan</span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: df1</span><br><span class="line">Out[<span class="number">168</span>]: </span><br><span class="line">     a    b     c     d</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">169</span>]: df2</span><br><span class="line">Out[<span class="number">169</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">5.0</span>   NaN   <span class="number">7.0</span>   <span class="number">8.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">12.0</span>  <span class="number">13.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure><p>将它们相加时，没有重叠的位置就会产生NA值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">170</span>]: df1 + df2</span><br><span class="line">Out[<span class="number">170</span>]: </span><br><span class="line">      a     b     c     d   e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span> NaN</span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   NaN  <span class="number">13.0</span>  <span class="number">15.0</span> NaN</span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span> NaN</span><br><span class="line"><span class="number">3</span>   NaN   NaN   NaN   NaN NaN</span><br></pre></td></tr></table></figure><p>使用df1的add方法，传入df2以及一个fill_value参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">171</span>]: df1.add(df2, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">171</span>]: </span><br><span class="line">      a     b     c     d     e</span><br><span class="line"><span class="number">0</span>   <span class="number">0.0</span>   <span class="number">2.0</span>   <span class="number">4.0</span>   <span class="number">6.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>   <span class="number">9.0</span>   <span class="number">5.0</span>  <span class="number">13.0</span>  <span class="number">15.0</span>   <span class="number">9.0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">18.0</span>  <span class="number">20.0</span>  <span class="number">22.0</span>  <span class="number">24.0</span>  <span class="number">14.0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">15.0</span>  <span class="number">16.0</span>  <span class="number">17.0</span>  <span class="number">18.0</span>  <span class="number">19.0</span></span><br></pre></td></tr></table></figure><img src="/2018/09/06/pandas-2/suanshu.png"><p>与此类似，在对Series或DataFrame重新索引时，也可以指定一个填充值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">174</span>]: df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">174</span>]: </span><br><span class="line">     a    b     c     d  e</span><br><span class="line"><span class="number">0</span>  <span class="number">0.0</span>  <span class="number">1.0</span>   <span class="number">2.0</span>   <span class="number">3.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4.0</span>  <span class="number">5.0</span>   <span class="number">6.0</span>   <span class="number">7.0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">8.0</span>  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h3><p>跟不同维度的NumPy数组一样，DataFrame和Series之间算术运算也是有明确规定的。先来看一个具有启发性的例子，计算一个二维数组与其某行之间的差：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">175</span>]: arr = np.arange(<span class="number">12.</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">176</span>]: arr</span><br><span class="line">Out[<span class="number">176</span>]: </span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>,   <span class="number">3.</span>],</span><br><span class="line">       [  <span class="number">4.</span>,   <span class="number">5.</span>,   <span class="number">6.</span>,   <span class="number">7.</span>],</span><br><span class="line">       [  <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">177</span>]: arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">177</span>]: array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">178</span>]: arr - arr[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">178</span>]: </span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>,  <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure><p>当我们从arr减去arr[0]，每一行都会执行这个操作。这就叫做广播（broadcasting），附录A将对此进行详细讲解。DataFrame和Series之间的运算差不多也是如此：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">179</span>]: frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),</span><br><span class="line">   .....:                      columns=list(<span class="string">'bde'</span>),</span><br><span class="line">   .....:                      index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">180</span>]: series = frame.iloc[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">181</span>]: frame</span><br><span class="line">Out[<span class="number">181</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">182</span>]: series</span><br><span class="line">Out[<span class="number">182</span>]: </span><br><span class="line">b    <span class="number">0.0</span></span><br><span class="line">d    <span class="number">1.0</span></span><br><span class="line">e    <span class="number">2.0</span></span><br><span class="line">Name: Utah, dtype: float64</span><br></pre></td></tr></table></figure><p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">183</span>]: frame - series</span><br><span class="line">Out[<span class="number">183</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah    <span class="number">0.0</span>  <span class="number">0.0</span>  <span class="number">0.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>  <span class="number">3.0</span>  <span class="number">3.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>  <span class="number">6.0</span>  <span class="number">6.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">9.0</span>  <span class="number">9.0</span></span><br></pre></td></tr></table></figure><p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">184</span>]: series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">185</span>]: frame + series2</span><br><span class="line">Out[<span class="number">185</span>]: </span><br><span class="line">          b   d     e   f</span><br><span class="line">Utah    <span class="number">0.0</span> NaN   <span class="number">3.0</span> NaN</span><br><span class="line">Ohio    <span class="number">3.0</span> NaN   <span class="number">6.0</span> NaN</span><br><span class="line">Texas   <span class="number">6.0</span> NaN   <span class="number">9.0</span> NaN</span><br><span class="line">Oregon  <span class="number">9.0</span> NaN  <span class="number">12.0</span> NaN</span><br></pre></td></tr></table></figure><p>如果你希望匹配行且在列上广播，则必须使用算术运算方法。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">186</span>]: series3 = frame[<span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">187</span>]: frame</span><br><span class="line">Out[<span class="number">187</span>]: </span><br><span class="line">          b     d     e</span><br><span class="line">Utah    <span class="number">0.0</span>   <span class="number">1.0</span>   <span class="number">2.0</span></span><br><span class="line">Ohio    <span class="number">3.0</span>   <span class="number">4.0</span>   <span class="number">5.0</span></span><br><span class="line">Texas   <span class="number">6.0</span>   <span class="number">7.0</span>   <span class="number">8.0</span></span><br><span class="line">Oregon  <span class="number">9.0</span>  <span class="number">10.0</span>  <span class="number">11.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">188</span>]: series3</span><br><span class="line">Out[<span class="number">188</span>]: </span><br><span class="line">Utah       <span class="number">1.0</span></span><br><span class="line">Ohio       <span class="number">4.0</span></span><br><span class="line">Texas      <span class="number">7.0</span></span><br><span class="line">Oregon    <span class="number">10.0</span></span><br><span class="line">Name: d, dtype: float64</span><br><span class="line"></span><br><span class="line">In [<span class="number">189</span>]: frame.sub(series3, axis=<span class="string">'index'</span>)</span><br><span class="line">Out[<span class="number">189</span>]: </span><br><span class="line">          b    d    e</span><br><span class="line">Utah   <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Ohio   <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Texas  <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br><span class="line">Oregon <span class="number">-1.0</span>  <span class="number">0.0</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>传入的轴号就是希望匹配的轴。在本例中，我们的目的是匹配DataFrame的行索引（axis=’index’ or axis=0）并进行广播。</p><h2 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h2><p>NumPy的ufuncs（元素级数组方法）也可用于操作pandas对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">190</span>]: frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),</span><br><span class="line">   .....:                      index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">191</span>]: frame</span><br><span class="line">Out[<span class="number">191</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah   <span class="number">-0.204708</span>  <span class="number">0.478943</span> <span class="number">-0.519439</span></span><br><span class="line">Ohio   <span class="number">-0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span> <span class="number">-1.296221</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">192</span>]: np.abs(frame)</span><br><span class="line">Out[<span class="number">192</span>]: </span><br><span class="line">               b         d         e</span><br><span class="line">Utah    <span class="number">0.204708</span>  <span class="number">0.478943</span>  <span class="number">0.519439</span></span><br><span class="line">Ohio    <span class="number">0.555730</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br><span class="line">Texas   <span class="number">0.092908</span>  <span class="number">0.281746</span>  <span class="number">0.769023</span></span><br><span class="line">Oregon  <span class="number">1.246435</span>  <span class="number">1.007189</span>  <span class="number">1.296221</span></span><br></pre></td></tr></table></figure><p>另一个常见的操作是，将函数应用到由各列或行所形成的一维数组上。DataFrame的apply方法即可实现此功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">193</span>]: f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line"></span><br><span class="line">In [<span class="number">194</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">194</span>]: </span><br><span class="line">b    <span class="number">1.802165</span></span><br><span class="line">d    <span class="number">1.684034</span></span><br><span class="line">e    <span class="number">2.689627</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>这里的函数f，计算了一个Series的最大值和最小值的差，在frame的每列都执行了一次。结果是一个Series，使用frame的列作为索引。</p><p>如果传递axis=’columns’到apply，这个函数会在每行执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">195</span>]: frame.apply(f, axis=<span class="string">'columns'</span>)</span><br><span class="line">Out[<span class="number">195</span>]:</span><br><span class="line">Utah      <span class="number">0.998382</span></span><br><span class="line">Ohio      <span class="number">2.521511</span></span><br><span class="line">Texas     <span class="number">0.676115</span></span><br><span class="line">Oregon    <span class="number">2.542656</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>许多最为常见的数组统计功能都被实现成DataFrame的方法（如sum和mean），因此无需使用apply方法。</p><p>传递到apply的函数不是必须返回一个标量，还可以返回由多个值组成的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">196</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">   .....:     <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">197</span>]: frame.apply(f)</span><br><span class="line">Out[<span class="number">197</span>]: </span><br><span class="line">            b         d         e</span><br><span class="line">min <span class="number">-0.555730</span>  <span class="number">0.281746</span> <span class="number">-1.296221</span></span><br><span class="line">max  <span class="number">1.246435</span>  <span class="number">1.965781</span>  <span class="number">1.393406</span></span><br></pre></td></tr></table></figure><h2 id="汇总和计算描述统计"><a href="#汇总和计算描述统计" class="headerlink" title="汇总和计算描述统计"></a>汇总和计算描述统计</h2><p>pandas对象拥有一组常用的数学和统计方法。它们大部分都属于约简和汇总统计，用于从Series中提取单个值（如sum或mean）或从DataFrame的行或列中提取一个Series。跟对应的NumPy数组方法相比，它们都是基于没有缺失数据的假设而构建的。看一个简单的DataFrame：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">230</span>]: df = pd.DataFrame([[<span class="number">1.4</span>, np.nan], [<span class="number">7.1</span>, <span class="number">-4.5</span>],</span><br><span class="line">   .....:                    [np.nan, np.nan], [<span class="number">0.75</span>, <span class="number">-1.3</span>]],</span><br><span class="line">   .....:                   index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>],</span><br><span class="line">   .....:                   columns=[<span class="string">'one'</span>, <span class="string">'two'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">231</span>]: df</span><br><span class="line">Out[<span class="number">231</span>]: </span><br><span class="line">    one  two</span><br><span class="line">a  <span class="number">1.40</span>  NaN</span><br><span class="line">b  <span class="number">7.10</span> <span class="number">-4.5</span></span><br><span class="line">c   NaN  NaN</span><br><span class="line">d  <span class="number">0.75</span> <span class="number">-1.3</span></span><br></pre></td></tr></table></figure><p>调用DataFrame的sum方法将会返回一个含有列的和的Series：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">232</span>]: df.sum()</span><br><span class="line">Out[<span class="number">232</span>]: </span><br><span class="line">one    <span class="number">9.25</span></span><br><span class="line">two   <span class="number">-5.80</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>传入axis=’columns’或axis=1将会按行进行求和运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">233</span>]: df.sum(axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">233</span>]:</span><br><span class="line">a    <span class="number">1.40</span></span><br><span class="line">b    <span class="number">2.60</span></span><br><span class="line">c     NaN</span><br><span class="line">d   <span class="number">-0.55</span></span><br></pre></td></tr></table></figure><p>NA值会自动被排除，除非整个切片（这里指的是行或列）都是NA。通过skipna选项可以禁用该功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">234</span>]: df.mean(axis=<span class="string">'columns'</span>, skipna=<span class="keyword">False</span>)</span><br><span class="line">Out[<span class="number">234</span>]: </span><br><span class="line">a      NaN</span><br><span class="line">b    <span class="number">1.300</span></span><br><span class="line">c      NaN</span><br><span class="line">d   <span class="number">-0.275</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><img src="/2018/09/06/pandas-2/tongji.jpg">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas学习（一）</title>
      <link href="/2018/09/05/pandas-1/"/>
      <url>/2018/09/05/pandas-1/</url>
      
        <content type="html"><![CDATA[<p>导入 pandas、numpy、matplotlib </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h2 id="创造对象"><a href="#创造对象" class="headerlink" title="创造对象"></a>创造对象</h2><p>Series 是一个值的序列，它只有一个列，以及索引。下面的例子中，就用默认的整数索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,np.nan,<span class="number">6</span>,<span class="number">8</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line"><span class="number">0</span>     <span class="number">1</span></span><br><span class="line"><span class="number">1</span>     <span class="number">3</span></span><br><span class="line"><span class="number">2</span>     <span class="number">5</span></span><br><span class="line"><span class="number">3</span>   NaN</span><br><span class="line"><span class="number">4</span>     <span class="number">6</span></span><br><span class="line"><span class="number">5</span>     <span class="number">8</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure><p>DataFrame 是有多个列的数据表，每个列拥有一个 label，当然，DataFrame 也有索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: dates</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">'2013-01-01'</span>, <span class="string">'2013-01-02'</span>, <span class="string">'2013-01-03'</span>, <span class="string">'2013-01-04'</span>,</span><br><span class="line">               <span class="string">'2013-01-05'</span>, <span class="string">'2013-01-06'</span>],</span><br><span class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), index=dates, columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line"><span class="comment">#index 行名，columns，列名。都需要提供一个列表对象</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: df</span><br><span class="line">Out[<span class="number">9</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span> <span class="number">-1.478427</span>  <span class="number">0.524988</span></span><br></pre></td></tr></table></figure><p>如果参数是一个 dict，每个 dict 的 value 会被转化成一个 Series</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df2 = pd.DataFrame(&#123; <span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">   ....:                      <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">   ....:                      <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">   ....:                      <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">   ....:                      <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">   ....:                      <span class="string">'F'</span> : <span class="string">'foo'</span> &#125;)</span><br><span class="line">   ....: </span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df2</span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">   A          B  C  D      E    F</span><br><span class="line"><span class="number">0</span>  <span class="number">1</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">1</span>  <span class="number">1</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1</span>  <span class="number">3</span>  train  foo</span><br><span class="line"><span class="number">2</span>  <span class="number">1</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1</span>  <span class="number">3</span>   test  foo</span><br><span class="line"><span class="number">3</span>  <span class="number">1</span> <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1</span>  <span class="number">3</span>  train  foo</span><br></pre></td></tr></table></figure><p>每列的格式用 dtypes 查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: df2.dtypes</span><br><span class="line">Out[<span class="number">12</span>]: </span><br><span class="line">A           float64</span><br><span class="line">B    datetime64[ns]</span><br><span class="line">C           float32</span><br><span class="line">D             int32</span><br><span class="line">E          category</span><br><span class="line">F            object</span><br><span class="line">dtype: object</span><br></pre></td></tr></table></figure><p>你可以认为，DataFrame 是由 Series 组成的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: df2.A</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">1</span></span><br><span class="line"><span class="number">2</span>    <span class="number">1</span></span><br><span class="line"><span class="number">3</span>    <span class="number">1</span></span><br><span class="line">Name: A, dtype: float64</span><br></pre></td></tr></table></figure><h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><p>用 head 和 tail 查看顶端和底端的几列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: df.head()</span><br><span class="line">Out[<span class="number">14</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: df.tail(<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span> <span class="number">-1.478427</span>  <span class="number">0.524988</span></span><br></pre></td></tr></table></figure><p>实际上，DataFrame 内部用 numpy 格式存储数据。你也可以单独查看 index 和 columns</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: df.index</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">DatetimeIndex([<span class="string">'2013-01-01'</span>, <span class="string">'2013-01-02'</span>, <span class="string">'2013-01-03'</span>, <span class="string">'2013-01-04'</span>,</span><br><span class="line">               <span class="string">'2013-01-05'</span>, <span class="string">'2013-01-06'</span>],</span><br><span class="line">              dtype=<span class="string">'datetime64[ns]'</span>, freq=<span class="string">'D'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: df.columns</span><br><span class="line">Out[<span class="number">17</span>]: Index([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>], dtype=<span class="string">'object'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: df.values</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">array([[ <span class="number">0.4691</span>, <span class="number">-0.2829</span>, <span class="number">-1.5091</span>, <span class="number">-1.1356</span>],</span><br><span class="line">       [ <span class="number">1.2121</span>, <span class="number">-0.1732</span>,  <span class="number">0.1192</span>, <span class="number">-1.0442</span>],</span><br><span class="line">       [<span class="number">-0.8618</span>, <span class="number">-2.1046</span>, <span class="number">-0.4949</span>,  <span class="number">1.0718</span>],</span><br><span class="line">       [ <span class="number">0.7216</span>, <span class="number">-0.7068</span>, <span class="number">-1.0396</span>,  <span class="number">0.2719</span>],</span><br><span class="line">       [<span class="number">-0.425</span> ,  <span class="number">0.567</span> ,  <span class="number">0.2762</span>, <span class="number">-1.0874</span>],</span><br><span class="line">       [<span class="number">-0.6737</span>,  <span class="number">0.1136</span>, <span class="number">-1.4784</span>,  <span class="number">0.525</span> ]])</span><br></pre></td></tr></table></figure><p><code>describe()</code> 显示数据的概要。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">19</span>]: df.describe()</span><br><span class="line">Out[<span class="number">19</span>]: </span><br><span class="line">              A         B         C         D</span><br><span class="line">count  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span>  <span class="number">6.000000</span></span><br><span class="line">mean   <span class="number">0.073711</span> <span class="number">-0.431125</span> <span class="number">-0.687758</span> <span class="number">-0.233103</span></span><br><span class="line">std    <span class="number">0.843157</span>  <span class="number">0.922818</span>  <span class="number">0.779887</span>  <span class="number">0.973118</span></span><br><span class="line">min   <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">25</span>%   <span class="number">-0.611510</span> <span class="number">-0.600794</span> <span class="number">-1.368714</span> <span class="number">-1.076610</span></span><br><span class="line"><span class="number">50</span>%    <span class="number">0.022070</span> <span class="number">-0.228039</span> <span class="number">-0.767252</span> <span class="number">-0.386188</span></span><br><span class="line"><span class="number">75</span>%    <span class="number">0.658444</span>  <span class="number">0.041933</span> <span class="number">-0.034326</span>  <span class="number">0.461706</span></span><br><span class="line">max    <span class="number">1.212112</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span>  <span class="number">1.071804</span></span><br></pre></td></tr></table></figure><p>和 numpy 一样，可以方便的得到转置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: df.T</span><br><span class="line">Out[<span class="number">20</span>]: </span><br><span class="line">   <span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">2013</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">2013</span><span class="number">-01</span><span class="number">-05</span>  <span class="number">2013</span><span class="number">-01</span><span class="number">-06</span></span><br><span class="line">A    <span class="number">0.469112</span>    <span class="number">1.212112</span>   <span class="number">-0.861849</span>    <span class="number">0.721555</span>   <span class="number">-0.424972</span>   <span class="number">-0.673690</span></span><br><span class="line">B   <span class="number">-0.282863</span>   <span class="number">-0.173215</span>   <span class="number">-2.104569</span>   <span class="number">-0.706771</span>    <span class="number">0.567020</span>    <span class="number">0.113648</span></span><br><span class="line">C   <span class="number">-1.509059</span>    <span class="number">0.119209</span>   <span class="number">-0.494929</span>   <span class="number">-1.039575</span>    <span class="number">0.276232</span>   <span class="number">-1.478427</span></span><br><span class="line">D   <span class="number">-1.135632</span>   <span class="number">-1.044236</span>    <span class="number">1.071804</span>    <span class="number">0.271860</span>   <span class="number">-1.087401</span>    <span class="number">0.524988</span></span><br></pre></td></tr></table></figure><p>对 axis 按照 index 排序（<code>axis=1</code> 是指第二个维度，即：列，<code>axis=0</code> 是指第一个维度，即：行）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">21</span>]: df.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>) <span class="comment">#ascending=False 默认为True，升序</span></span><br><span class="line">Out[<span class="number">21</span>]: </span><br><span class="line">                   D         C         B         A</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span> <span class="number">-1.135632</span> <span class="number">-1.509059</span> <span class="number">-0.282863</span>  <span class="number">0.469112</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span> <span class="number">-1.044236</span>  <span class="number">0.119209</span> <span class="number">-0.173215</span>  <span class="number">1.212112</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span>  <span class="number">1.071804</span> <span class="number">-0.494929</span> <span class="number">-2.104569</span> <span class="number">-0.861849</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.271860</span> <span class="number">-1.039575</span> <span class="number">-0.706771</span>  <span class="number">0.721555</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-1.087401</span>  <span class="number">0.276232</span>  <span class="number">0.567020</span> <span class="number">-0.424972</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span>  <span class="number">0.524988</span> <span class="number">-1.478427</span>  <span class="number">0.113648</span> <span class="number">-0.673690</span></span><br></pre></td></tr></table></figure><p>按值排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">22</span>]: df.sort_values(by=<span class="string">'B'</span>) <span class="comment">#也可以是by=['A','B']，按2列排序</span></span><br><span class="line">Out[<span class="number">22</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span> <span class="number">-1.478427</span>  <span class="number">0.524988</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span></span><br></pre></td></tr></table></figure><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><blockquote><p>注意，以下这些对交互式环境很友好，但是作为 production code 请用优化过的 <code>.at</code>, <code>.iat</code>, <code>.loc</code>, <code>.iloc</code> 和 <code>.ix</code></p></blockquote><h3 id="获取行-列"><a href="#获取行-列" class="headerlink" title="获取行/列"></a>获取行/列</h3><p>从 DataFrame 选择一个列，就得到了 Series</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">23</span>]: df[<span class="string">'A'</span>]</span><br><span class="line">Out[<span class="number">23</span>]: </span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>    <span class="number">0.469112</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>    <span class="number">1.212112</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span>   <span class="number">-0.861849</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>    <span class="number">0.721555</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span>   <span class="number">-0.424972</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span>   <span class="number">-0.673690</span></span><br><span class="line">Freq: D, Name: A, dtype: float64</span><br></pre></td></tr></table></figure><p>和 numpy 类似，这里也能用 <code>[]</code>选择行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: df[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">24</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: df[<span class="string">'20130102'</span>:<span class="string">'20130104'</span>]</span><br><span class="line">Out[<span class="number">25</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br></pre></td></tr></table></figure><h3 id="通过-label-选择"><a href="#通过-label-选择" class="headerlink" title="通过 label 选择"></a>通过 label 选择</h3><p>还可以多选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]] <span class="comment">#所有行，AB列</span></span><br><span class="line">Out[<span class="number">27</span>]: </span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span></span><br></pre></td></tr></table></figure><p>注意那个冒号，用法和 MATLAB 或 NumPy 是一样的！所以也可以这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">28</span>]: df.loc[<span class="string">'20130102'</span>:<span class="string">'20130104'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]] </span><br><span class="line">Out[<span class="number">28</span>]: </span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">29</span>]: df.loc[<span class="string">'20130102'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]]</span><br><span class="line">Out[<span class="number">29</span>]: </span><br><span class="line">A    <span class="number">1.212112</span></span><br><span class="line">B   <span class="number">-0.173215</span></span><br><span class="line">Name: <span class="number">2013</span><span class="number">-01</span><span class="number">-02</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>, dtype: float64</span><br></pre></td></tr></table></figure><p>如果对所有的维度都写了标量，不就是选出一个元素吗？</p><p>如果对所有的维度都写了标量，不就是选出一个元素吗？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">30</span>]: df.loc[dates[<span class="number">0</span>],<span class="string">'A'</span>]</span><br><span class="line">Out[<span class="number">30</span>]: <span class="number">0.46911229990718628</span></span><br></pre></td></tr></table></figure><p>这种情况通常用 <code>at</code> ，速度更快</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: df.at[dates[<span class="number">0</span>],<span class="string">'A'</span>]</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">0.46911229990718628</span></span><br></pre></td></tr></table></figure><h3 id="通过整数下标选择"><a href="#通过整数下标选择" class="headerlink" title="通过整数下标选择"></a>通过整数下标选择</h3><p>这个就和数组类似啦，直接看例子。选出第3行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">32</span>]: df.iloc[<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">32</span>]: </span><br><span class="line">A    <span class="number">0.721555</span></span><br><span class="line">B   <span class="number">-0.706771</span></span><br><span class="line">C   <span class="number">-1.039575</span></span><br><span class="line">D    <span class="number">0.271860</span></span><br><span class="line">Name: <span class="number">2013</span><span class="number">-01</span><span class="number">-04</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span>, dtype: float64</span><br></pre></td></tr></table></figure><p>选出3~4行，0~1列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">33</span>]: df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">0</span>:<span class="number">2</span>] <span class="comment">#注意 3:5 是第3行到第4行（有第0行）</span></span><br><span class="line">Out[<span class="number">33</span>]: </span><br><span class="line">                   A         B</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span></span><br></pre></td></tr></table></figure><p>也能用 list 选择</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">34</span>]: df.iloc[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">2</span>]]</span><br><span class="line">Out[<span class="number">34</span>]: </span><br><span class="line">                   A         C</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span>  <span class="number">0.119209</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-0.494929</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.276232</span></span><br></pre></td></tr></table></figure><p>对应单个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: df.iloc[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">37</span>]: <span class="number">-0.17321464905330858</span></span><br><span class="line">In [<span class="number">38</span>]: df.iat[<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">38</span>]: <span class="number">-0.17321464905330858</span></span><br></pre></td></tr></table></figure><p><strong>总结：<code>df.icol</code> 是按下标选择，<code>df.col</code>是按标签选择。</strong></p><h3 id="通过布尔值下标"><a href="#通过布尔值下标" class="headerlink" title="通过布尔值下标"></a>通过布尔值下标</h3><p>基本用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">39</span>]: df[df.A &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">39</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span></span><br></pre></td></tr></table></figure><p>不满足条件的填充为： NaN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: df[df &gt; <span class="number">0</span>]</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">                   A         B         C         D</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span>       NaN       NaN       NaN</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span>       NaN  <span class="number">0.119209</span>       NaN</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span>       NaN       NaN       NaN  <span class="number">1.071804</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span>       NaN       NaN  <span class="number">0.271860</span></span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span>       NaN  <span class="number">0.567020</span>  <span class="number">0.276232</span>       NaN</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span>       NaN  <span class="number">0.113648</span>       NaN  <span class="number">0.524988</span></span><br></pre></td></tr></table></figure><p><code>isin()</code> 函数：是否在集合中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df2 = df.copy()</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df2[<span class="string">'E'</span>] = [<span class="string">'one'</span>, <span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'three'</span>,<span class="string">'four'</span>,<span class="string">'three'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: df2</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">                   A         B         C         D      E</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-01</span>  <span class="number">0.469112</span> <span class="number">-0.282863</span> <span class="number">-1.509059</span> <span class="number">-1.135632</span>    one</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-02</span>  <span class="number">1.212112</span> <span class="number">-0.173215</span>  <span class="number">0.119209</span> <span class="number">-1.044236</span>    one</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span>    two</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-04</span>  <span class="number">0.721555</span> <span class="number">-0.706771</span> <span class="number">-1.039575</span>  <span class="number">0.271860</span>  three</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span>   four</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-06</span> <span class="number">-0.673690</span>  <span class="number">0.113648</span> <span class="number">-1.478427</span>  <span class="number">0.524988</span>  three</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: df2[df2[<span class="string">'E'</span>].isin([<span class="string">'two'</span>,<span class="string">'four'</span>])]</span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">                   A         B         C         D     E</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-03</span> <span class="number">-0.861849</span> <span class="number">-2.104569</span> <span class="number">-0.494929</span>  <span class="number">1.071804</span>   two</span><br><span class="line"><span class="number">2013</span><span class="number">-01</span><span class="number">-05</span> <span class="number">-0.424972</span>  <span class="number">0.567020</span>  <span class="number">0.276232</span> <span class="number">-1.087401</span>  four</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>丢弃某条轴上的一个或多个项很简单，只要有一个索引数组或列表即可。由于需要执行一些数据整理和集合逻辑，所以drop方法返回的是一个在指定轴上删除了指定值的新对象： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">110</span>]: data = pd.DataFrame(np.arange(<span class="number">16</span>).reshape((<span class="number">4</span>, <span class="number">4</span>)),</span><br><span class="line">   .....:                     index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'Utah'</span>, <span class="string">'New York'</span>],</span><br><span class="line">   .....:                     columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: data</span><br><span class="line">Out[<span class="number">111</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>用标签序列调用drop会从行标签（axis 0）删除值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">112</span>]: data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line">Out[<span class="number">112</span>]: </span><br><span class="line">          one  two  three  four</span><br><span class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><p>通过传递axis=1或axis=’columns’可以删除列的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">113</span>]: data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">113</span>]: </span><br><span class="line">          one  three  four</span><br><span class="line">Ohio        <span class="number">0</span>      <span class="number">2</span>     <span class="number">3</span></span><br><span class="line">Colorado    <span class="number">4</span>      <span class="number">6</span>     <span class="number">7</span></span><br><span class="line">Utah        <span class="number">8</span>     <span class="number">10</span>    <span class="number">11</span></span><br><span class="line">New York   <span class="number">12</span>     <span class="number">14</span>    <span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="读取、写入数据"><a href="#读取、写入数据" class="headerlink" title="读取、写入数据"></a>读取、写入数据</h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">136</span>]: df.to_csv(<span class="string">'foo.csv'</span>)</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">137</span>]: pd.read_csv(<span class="string">'foo.csv'</span>)</span><br><span class="line">In [<span class="number">137</span>]: pd.read_csv(StringIO(data), names=[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>], header=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># 自定义表头，当name设定的时候，header必须显式None，因为默认为0</span></span><br><span class="line">    foo bar baz</span><br><span class="line"><span class="number">0</span>   a   b   c</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line"><span class="number">2</span>   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">3</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_table(<span class="string">'example.txt'</span>,sep=<span class="string">'\t'</span>,header=<span class="number">0</span>) </span><br><span class="line"><span class="comment"># 指定分隔符和表头，默认header=0，把第一行作为表头。分割符默认制表符'/t'，'/s+'，可以匹配任何空格。</span></span><br></pre></td></tr></table></figure><h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><p>写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">140</span>]: df.to_excel(<span class="string">'foo.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>)</span><br></pre></td></tr></table></figure><p>读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">141</span>]: pd.read_excel(<span class="string">'foo.xlsx'</span>, sheet_name=<span class="string">'Sheet1'</span>, index_col=<span class="keyword">None</span>, na_values=[<span class="string">'NA'</span>])</span><br><span class="line"><span class="comment">#index_col 行名，na_values 缺失值的形式</span></span><br></pre></td></tr></table></figure><img src="/2018/09/05/pandas-1/file1.png"><img src="/2018/09/05/pandas-1/file.png"><img src="/2018/09/05/pandas-1/file3.png">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>next主题设置</title>
      <link href="/2018/09/01/next-theme/"/>
      <url>/2018/09/01/next-theme/</url>
      
        <content type="html"><![CDATA[<h2 id="主题风格"><a href="#主题风格" class="headerlink" title="主题风格"></a>主题风格</h2><p>通过修改next主题下的<code>_config.yml</code>的scheme字段，配置不同的风格。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Schemes</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Muse</span></span><br><span class="line">scheme: Mist  #推荐</span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Pisces</span></span><br><span class="line"><span class="meta">#</span><span class="bash">scheme: Gemini</span></span><br></pre></td></tr></table></figure><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p>通过修改next主题下的<code>_config.yml</code>的menu字段，选定显示的菜单项。 可自己修改字段和目录名，||之后为配套的小图标。我添加了links字段，但是当前语言是简体中文，页面上无法给我翻译出来，去添加<code>language/zh-CN.yml</code>里的对应字段即可。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: /home/ || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line"><span class="meta">  #</span><span class="bash">tags: /tags/ || tags</span></span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  links: /links/ || calendar</span><br></pre></td></tr></table></figure><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>在主题下的<code>source/images/</code>下替换原有的头像文件<code>avatar.gif</code>，并在<code>_config.yml</code>中查找<code>Sidebar Avatar</code>字段，添加<code>url</code>字段内容： /images/avatar.gif</p><h3 id="头像旋转"><a href="#头像旋转" class="headerlink" title="头像旋转"></a>头像旋转</h3><p>找到位于 <code>source/css/_common/components/sidebar/sidebar-author.syl</code> 模板文件里侧边栏头像的样式 <code>.site-author-image</code> </p><p>将内容修改为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    -webkit-border-radius: 50%;</span><br><span class="line">    -moz-border-radius: 50%;</span><br><span class="line">    transition: 1.4s all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后添加 <code>.site-author-image:hover</code> 样式，由 <code>rotate()</code> 方法实现，旋转 360° </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image:hover &#123;</span><br><span class="line">    -webkit-transform: rotate(360deg);</span><br><span class="line">    -moz-transform: rotate(360deg);</span><br><span class="line">    -ms-transform: rotate(360deg);</span><br><span class="line">    -transform: rotate(360deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文章代码主题"><a href="#文章代码主题" class="headerlink" title="文章代码主题"></a>文章代码主题</h2><p>Next主题总共支持5种主题，默认主题是白色的normal。通过修改next主题下的<code>_config.yml</code>的highlight字段，来设置代码主题。 推荐 night 。</p><h2 id="标签、分类"><a href="#标签、分类" class="headerlink" title="标签、分类"></a>标签、分类</h2><p>在存在标签页、分类页的情况下，在写文章的时候，在文章头部添加 tags、categories 字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags: [npm, hexo, github]</span><br><span class="line">categories: 搭建博客</span><br></pre></td></tr></table></figure><h2 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h2><p>安装 hexo-generator-searchdb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-generator-searchdb --save</span></span><br></pre></td></tr></table></figure><p>在站点<code>myBlog/_config.yml</code>中添加search字段，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure><p>修改next主题下的<code>_config.yml</code>的Local search字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable: true</span><br></pre></td></tr></table></figure><h2 id="hexo博客底部页脚"><a href="#hexo博客底部页脚" class="headerlink" title="hexo博客底部页脚"></a>hexo博客底部页脚</h2><p>找到<code>/themes/next/layout/_partials/footer.swig文件</code> 内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"copyright"</span> &gt;</span></span><br><span class="line">  &#123;% set current = date(Date.now(), "YYYY") %&#125;</span><br><span class="line">  © &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">itemprop</span>=<span class="string">"copyrightYear"</span>&gt;</span>&#123;&#123; current &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"with-love"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-heart"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"author"</span> <span class="attr">itemprop</span>=<span class="string">"copyrightHolder"</span>&gt;</span>&#123;&#123; config.author &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"powered-by"</span>&gt;</span></span><br><span class="line">  &#123;&#123; __('footer.powered', '<span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://hexo.io"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"theme-info"</span>&gt;</span></span><br><span class="line">  &#123;&#123; __('footer.theme') &#125;&#125; -</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span>&gt;</span></span><br><span class="line">    NexT.&#123;&#123; theme.scheme &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除class 为powered-by的div和theme-info的div。</p><h2 id="github标识"><a href="#github标识" class="headerlink" title="github标识"></a>github标识</h2><p>在<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">网站</a>上选择一个喜欢的标识类型，复制粘贴代码到<code>themes/next/layout/_layout.swig</code>文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把<code>href</code>改为个人github地址  。</p><h2 id="首页隐藏指定文章"><a href="#首页隐藏指定文章" class="headerlink" title="首页隐藏指定文章"></a>首页隐藏指定文章</h2><p>有时候我们可能只想在首页显示关于编程之类的内容，而个人日记之类的文章放在其他分类之下而不在首页显示。可以从、分类、标签、归档中查看文章。 </p><h3 id="自定义front-matter的参数"><a href="#自定义front-matter的参数" class="headerlink" title="自定义front-matter的参数"></a>自定义front-matter的参数</h3><p>例如，自定义添加一个<strong>notshow</strong>参数，值为<strong>true</strong>，用来提供判断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags: [npm, hexo, github]</span><br><span class="line">categories: 搭建博客</span><br><span class="line">notshow: true</span><br></pre></td></tr></table></figure><p>修改主题的<code>themes/next/layout/index.swig</code>文件,将</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span><br><span class="line">    &#123;% for post in page.posts %&#125;</span><br><span class="line">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% include '_partials/pagination.swig' %&#125;</span><br><span class="line">&#123;% endblock %</span><br></pre></td></tr></table></figure><p>添加过滤条件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"posts"</span> <span class="attr">class</span>=<span class="string">"posts-expand"</span>&gt;</span></span><br><span class="line">    &#123;% for post in page.posts %&#125;</span><br><span class="line">&#123;% if post.notshow != true %&#125;</span><br><span class="line">&#123;&#123; post_template.render(post, true) &#125;&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  &#123;% include '_partials/pagination.swig' %&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-copy</title>
      <link href="/2018/08/27/python-copy/"/>
      <url>/2018/08/27/python-copy/</url>
      
        <content type="html"><![CDATA[<h4 id="赋值（assignment）"><a href="#赋值（assignment）" class="headerlink" title="赋值（assignment）"></a>赋值（assignment）</h4><p>在Python中，用一个变量给另一个变量<strong>赋值</strong>，其实就是给当前内存中的对象增加一个“标签”而已。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(b), sep=<span class="string">'\n'</span>)  <span class="comment">#a和b都只是[1,2,3]的一个标签</span></span><br><span class="line"><span class="number">139701469405552</span></span><br><span class="line"><span class="number">139701469405552</span></span><br></pre></td></tr></table></figure><h4 id="浅拷贝（shallow-copy）"><a href="#浅拷贝（shallow-copy）" class="headerlink" title="浅拷贝（shallow copy）"></a>浅拷贝（shallow copy）</h4><p><strong>注意：浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</strong></p><p>所谓“浅拷贝”，是指创建一个新的对象，其内容是原对象中元素的引用。（拷贝组合对象，不拷贝子对象）</p><p>常见的浅拷贝有：切片操作、工厂函数（如<code>list()</code>，<code>dict()</code>等）、对象的copy()方法、copy模块中的copy函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = list(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(b))          <span class="comment"># a和b身份不同</span></span><br><span class="line"><span class="number">140601785066200</span> <span class="number">140601784764968</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):       <span class="comment"># 但它们包含的子对象身份相同</span></span><br><span class="line"><span class="meta">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure><p>从上面可以明显的看出来，a 浅拷贝得到 b，a 和 b 指向内存中不同的 <strong>list</strong> 对象，但它们的元素却指向相同的 <strong>int</strong> 对象。这就是浅拷贝！ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = list(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-1</span>].append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b) <span class="comment">#当a的子对象发生改变时，b也发生了改变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure><h4 id="深拷贝（deep-copy）"><a href="#深拷贝（deep-copy）" class="headerlink" title="深拷贝（deep copy）"></a>深拷贝（deep copy）</h4><p>所谓“深拷贝”，是指创建一个新的对象，然后递归的拷贝原对象所包含的子对象。深拷贝出来的对象与原对象没有任何关联。</p><p>深拷贝只有一种方式：copy模块中的deepcopy函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">-1</span>].append(<span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b) <span class="comment">#当a的子对象发生改变时，b不发生改变</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>，[<span class="number">4</span>,<span class="number">5</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(b))</span><br><span class="line"><span class="number">140601785065840</span> <span class="number">140601785066200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):</span><br><span class="line"><span class="meta">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">140601911441984</span> <span class="number">140601911441984</span></span><br><span class="line"><span class="number">140601911442016</span> <span class="number">140601911442016</span></span><br><span class="line"><span class="number">140601911442048</span> <span class="number">140601911442048</span></span><br></pre></td></tr></table></figure><p>看了上面的例子，有人可能会疑惑：</p><p><strong>为什么使用了深拷贝，a和b中元素的id还是一样呢？</strong></p><p>答：这是因为对于<strong>不可变对象</strong>，当需要一个新的对象时，python可能会返回已经存在的某个类型和值都一致的对象的引用。而且这种机制并不会影响 a 和 b 的相互独立性，因为当两个元素指向同一个不可变对象时，对其中一个赋值不会影响另外一个。</p><p>我们可以用一个包含可变对象的列表来确切地展示“浅拷贝”与“深拷贝”的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [[<span class="number">1</span>, <span class="number">2</span>],[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">8</span>, <span class="number">9</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.copy(a)              <span class="comment"># 浅拷贝得到b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = copy.deepcopy(a)          <span class="comment"># 深拷贝得到c</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(b))           <span class="comment"># a 和 b 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578335520</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, b):        <span class="comment"># a 和 b 的子对象相同</span></span><br><span class="line"><span class="meta">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578622816</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578622672</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(id(a), id(c))           <span class="comment"># a 和 c 不同</span></span><br><span class="line"><span class="number">139832578518984</span> <span class="number">139832578622456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(a, c):        <span class="comment"># a 和 c 的子对象也不同</span></span><br><span class="line"><span class="meta">... </span>    print(id(x), id(y))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">139832578622816</span> <span class="number">139832578621520</span></span><br><span class="line"><span class="number">139832578622672</span> <span class="number">139832578518912</span></span><br><span class="line"><span class="number">139832578623104</span> <span class="number">139832578623392</span></span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、赋值：简单地拷贝对象的引用，两个对象的id相同。<br>2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。<br>3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。</p><p>浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串(如<code>a=1</code>)以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ruby-re</title>
      <link href="/2018/08/21/ruby-re/"/>
      <url>/2018/08/21/ruby-re/</url>
      
        <content type="html"><![CDATA[<h2 id="Ruby中正则表达式的写法"><a href="#Ruby中正则表达式的写法" class="headerlink" title="Ruby中正则表达式的写法"></a>Ruby中正则表达式的写法</h2><p>主要有三种</p><ul><li>在//之间，要进行转义</li><li>在%r{}内，不用进行转义</li><li><code>Regexp.new()</code>内，不用进行转义</li></ul><h2 id="匹配的两种方法"><a href="#匹配的两种方法" class="headerlink" title="匹配的两种方法"></a>匹配的两种方法</h2><ul><li><p>=~肯定匹配, !~否定匹配。=~表达式返回匹配到的位置索引，失败返回nil，符号左右内容可交换</p></li><li><p><code>regexp#match(str)</code>，返回MatchData，一个数组，从0开始，还有<code>match.pre_match</code>返回匹配前内容，<code>match.post_match</code>返回匹配后内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/cat/ =~ <span class="string">"dog and cat"</span> <span class="comment">#返回8</span></span><br><span class="line"><span class="comment"># 类似python可以将正则放入一个变量，如re = Regexp.new(/cat/)，在后续匹配时直接使用re</span></span><br><span class="line">mt = <span class="regexp">/cat/</span>.match(<span class="string">"bigcatcomes"</span>) <span class="comment"># mt = re.match("bigcatcomes")</span></span><br><span class="line"><span class="string">"<span class="subst">#&#123;mt.pre_match&#125;</span>-&gt;<span class="subst">#&#123;mt[<span class="number">0</span>]&#125;</span>&lt;-<span class="subst">#&#123;mt.post_match&#125;</span>"</span> <span class="comment">#返回big-&gt;cat&lt;-comes</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p>很多时候匹配是为了替换，Ruby中进行正则替换非常简单，两个方法即可搞定，sub()+gsub()。sub只替换第一次匹配，gsub（g:global）会替换所有的匹配，没有匹配到返回原字符串的copy</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"ABDADA"</span></span><br><span class="line">new_str = str.sub(<span class="regexp">/A/</span>, <span class="string">"a"</span>) <span class="comment">#返回"aBDADA"</span></span><br><span class="line">new_str2 = str.gsub(<span class="regexp">/A/</span>, <span class="string">"a"</span>)<span class="comment">#返回"aBDaDa"</span></span><br></pre></td></tr></table></figure><h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><p>Ruby的分组匹配与其它语言差别不大，分组匹配表达式是对要进行分组的内容加()。对于匹配到的结果，可以用系统变量$1，$2…索引，也可用matchData数组来索引</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">md = <span class="regexp">/(\d\d):(\d\d)(..)/</span>.match(<span class="string">"12:50am"</span>) <span class="comment"># md为一个MatchData对象</span></span><br><span class="line">puts <span class="string">"Hour is <span class="subst">#&#123;$1&#125;</span>, minute <span class="subst">#&#123;$2&#125;</span>"</span></span><br><span class="line">puts <span class="string">"Hour is <span class="subst">#&#123;md[<span class="number">1</span>]&#125;</span>, minute <span class="subst">#&#123;md[<span class="number">2</span>]&#125;</span>"</span></span><br></pre></td></tr></table></figure><h2 id="匹配所有"><a href="#匹配所有" class="headerlink" title="匹配所有"></a>匹配所有</h2><p>regexp#match()只能匹配一次，如果想匹配所有要用regexp#scan()用法示例：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"abcabcqwe"</span>.scan(<span class="regexp">%r&#123;abc&#125;</span>).each &#123;<span class="params">|x|</span> puts x&#125; <span class="comment"># 输出2行abc</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ruby </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建博客</title>
      <link href="/2018/08/09/hexo+github/"/>
      <url>/2018/08/09/hexo+github/</url>
      
        <content type="html"><![CDATA[<h2 id="准备node-js和git"><a href="#准备node-js和git" class="headerlink" title="准备node.js和git"></a>准备node.js和git</h2><ul><li><p>node.js : 直接官网下载</p></li><li><p>git : 直接官网下载</p></li><li><p>验证安装结果 :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash">npm是随同NodeJS一起安装的包管理工具,类似python的pip</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Github账户注册和新建项目"><a href="#Github账户注册和新建项目" class="headerlink" title="Github账户注册和新建项目"></a>Github账户注册和新建项目</h2><p>项目必须要遵守格式：uername.github.io，如下：</p><img src="/2018/08/09/hexo+github/io.png"><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><ul><li><p>Hexo 是一个快速、简洁且高效的博客框架。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir blog &amp;&amp; <span class="built_in">cd</span> - <span class="comment">#创建个人目录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install -g hexo-cli <span class="comment">#安装hexo</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo -v <span class="comment">#检查hexo</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo init <span class="comment">#初始化hexo</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install <span class="comment">#安装所需包</span></span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Hexo与Github-page关联"><a href="#Hexo与Github-page关联" class="headerlink" title="Hexo与Github page关联"></a>Hexo与Github page关联</h2><ul><li><p>设置Git的user name和email（如果是第一次的话）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name  "xxx" git用户名</span><br><span class="line">git config --global user.email  "xxx@xx.com" git邮箱</span><br></pre></td></tr></table></figure></li><li><p>生成密钥、公钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -D</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -r ~/.ssh <span class="comment">#删除存在的密钥、公钥</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"xxx@xx.com"</span> <span class="comment">#生成新密钥、公钥对应git邮箱</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub <span class="comment">#查看公钥内容</span></span></span><br></pre></td></tr></table></figure></li><li><p>添加公钥到github</p><p>登陆github帐户，点击头像，然后 Settings -&gt; 左栏点击 SSH and GPG keys -&gt; 点击 New SSH key。然后复制上面的公钥内容，粘贴进“Key”文本域内。 title随便起个名字，点击 Add key完成。</p></li><li><p>确认成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T xxx@github.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure><p>git使用https协议，每次pull, push都会提示要输入密码，使用git协议，然后使用ssh密钥，这样免去每次都输密码的麻烦。</p><p>SSH地址</p><img src="/2018/08/09/hexo+github/ssh.png"><p>HTTPS地址</p><img src="/2018/08/09/hexo+github/www.png"></li></ul><h2 id="在-config-yml-进行基础配置"><a href="#在-config-yml-进行基础配置" class="headerlink" title="在_config.yml 进行基础配置"></a>在_config.yml 进行基础配置</h2><p>回到创建hexo的文件夹找到_config.yml，并编辑最后的信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy：</span><br><span class="line">    type： git</span><br><span class="line">    repository ：git@github.com:flystar233/flystar233.github.io.git #发布不再需要密码</span><br><span class="line">    repository ：https://github.com/flystar233/flystar233.github.io.git #发布需要密码</span><br><span class="line">    branch ：master</span><br></pre></td></tr></table></figure><h2 id="让博客能加载图片"><a href="#让博客能加载图片" class="headerlink" title="让博客能加载图片"></a>让博客能加载图片</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">post_asset_folder: true #在_config.yml中将false改为true</span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-asset-image --save <span class="comment">#在命令行中执行</span></span></span><br></pre></td></tr></table></figure><p>这样之后，在运行<code>hexo n &quot;xxxx&quot;</code>来生成md博客时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹。将博客所需图片放入此文件夹中，在md文件中（博客内容）插入图片时，使用命令<code></code> 来插入图片，xxxx是文件名，路径不可有中文。</p><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>在生成以及部署文章之前，需要安装一个扩展：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install hexo-deployer-git --save</span></span><br></pre></td></tr></table></figure><ul><li><p>发布相关命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo clean <span class="comment"># 清除全部文章</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo generate == hexo g <span class="comment">#生成静态文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo deploy == hexo d <span class="comment">#部署文件到github</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new <span class="string">"文件名"</span> <span class="comment">#创建新文章</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo new page <span class="string">"页面名"</span> <span class="comment">#创建新页面</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span></span><br></pre></td></tr></table></figure></li><li><p>查看博客</p><p>部署成功后访问博客地址，如：flystar233.github.io</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>awk</title>
      <link href="/2018/08/08/awk/"/>
      <url>/2018/08/08/awk/</url>
      
        <content type="html"><![CDATA[<p>使用awk 取文件第一列是<code>以数字开头</code>的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1~/^[0-9]+/ &#123;print $0&#125;'</span> infile &gt; outfile</span><br></pre></td></tr></table></figure><p>使用awk 取文件第一列<code>包含chr或者包含sca</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1~/chr|sca/ &#123;print $0&#125;'</span> infile &gt; outfile</span><br></pre></td></tr></table></figure><p>使用awk 取文件第一列<code>大于0.1且小于0.5</code>的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1&gt;0.1 &amp;&amp; $1&lt;0.5 &#123;print $0&#125;'</span> infile &gt; outfile</span><br></pre></td></tr></table></figure><p>使用awk 取文件第一列<code>是chr</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">'$1~/^chr$/ &#123;print $0&#125;'</span> infile &gt; outfile</span><br><span class="line">$ awk <span class="string">'$1=="chr" &#123;print $0&#125;'</span> infile &gt; outfile</span><br></pre></td></tr></table></figure><p>使用awk 进行字符串<code>捕获</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat file</span><br><span class="line">aaaaBASE_DDDD123</span><br><span class="line">$ awk <span class="string">'&#123;match($0,/(BASE_[a-zA-Z0-9]+)/,a);print a[1]&#125;'</span> file</span><br><span class="line">BASE_DDDD123</span><br></pre></td></tr></table></figure><p>split 函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"12:00:00"</span>|awk <span class="string">'&#123;split($0,time,":" ); for (i in time) print time[i]&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># split()是awk内置函数，还有length()</span></span><br><span class="line"><span class="comment"># $0 指代前面的字符，time为存放数据的数组名，":" 为分隔符</span></span><br></pre></td></tr></table></figure><p>使用awk 进行<code>格式化</code>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %c 字符    %s 字符串    %d 十进制整数    %f 浮点数</span></span><br><span class="line">$ <span class="built_in">printf</span> (<span class="string">"%s\t%s\t%s"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>world</title>
      <link href="/2018/08/07/world/"/>
      <url>/2018/08/07/world/</url>
      
        <content type="html"><![CDATA[<p>要了解世界的概念就要不断的减少个体的差异性。</p><p>我们知道人生而不同，但是要在脑海中形成对世界的认识，就要减少对相同类不同个体的存在，然后逐渐逼近对世界的正确认识。</p><p>世界是人在运行的么？不是。人只是世界很小的一个产物，人的主观能动性使人类科技，社会发展，那么人已经拥有可以控制世界的能力了么？小点说，人类已经拥有可以控制地球的能力了么？没有。人类在不断的进步中，还是在顺应自然的变化。</p><p>世界是太阳运行的么？不是。太阳为地球所有的生物提供了生存的条件：能量，万物生长，在地球上形成自然环境。那么，太阳会消失么？会的，太阳不断地核聚变产生能量，也在不断的泯灭，终有一天，太阳不在发出光芒，如果人类没有最终造出太阳的替代品，那么地球也将会消失。那么世界不再运行了么？没有。太阳系在已知宇宙中小的就像沧海一粟，一块皮肤老了，掉了也无所谓。</p><p>世界是光运行的么？只能说，光是一个必要不充分条件。没有光，世界万物无法生长，世界没有生机，没有了活力，没有了发展的动力。然而，没有光世界还在运行，宇宙深处没有光线，只有天体，他们依然按照旋转规律不停地运动，如果你觉得没有光，怎么知道有天体在动，那你可以做个小小的实验：找一个不透光的长盒子，两端开口，把一个小球扔进去，那么一定会在另一端小球出来。你看见小球在里边的运动了么？没有。你知道小球在动么？知道。</p><p>世界根本没有事物在操纵运行，完全是按照无序的规律自我运行的么？不知道，最起码现在不知道。我们不能把一切无法了解的事物归于神。神是什么？在外人解释来说，神就是唯心主义，是精神。谁也没见过神，是神造人？还是人造神？…</p>]]></content>
      
      
      <categories>
          
          <category> thought </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
