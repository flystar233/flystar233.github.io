<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rainsong</title>
  
  <subtitle>Everyone is a dreamer</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-11T02:35:10.086Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>轩暮</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比对格式问题</title>
    <link href="http://yoursite.com/2019/04/11/ka-ks/"/>
    <id>http://yoursite.com/2019/04/11/ka-ks/</id>
    <published>2019-04-11T01:41:52.000Z</published>
    <updated>2019-04-11T02:35:10.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Phylip-格式"><a href="#Phylip-格式" class="headerlink" title="Phylip 格式"></a>Phylip 格式</h2><p>在使 pamlX 的 CodeML 进行 Ka/Ks 计算时，蛋白比对序列需要不含终止密码子且格式为 phylip 格式。如今 phylip 有两种格式：第一种为 Phylip3.2，第二种为 Phylip4。这两种格式具有明显的差别，图示如下：</p><p><img src="/2019/04/11/ka-ks/p3-p4.png" alt=""></p><p>其中，第一行 Phylip4 是没有 I 标识的，且 Phylip4 格式中是把所有序列的第一行集中起来放置的。在 CodeML 使用中发现只有 Phylip4 可以使用，但是会报错，原因不清楚，但是在 Phylip4 格式文件中第一行也加上 I 标识就可以正常使用了。</p><h2 id="格式转换工具"><a href="#格式转换工具" class="headerlink" title="格式转换工具"></a>格式转换工具</h2><p>序列比对一般有两种方式：在线版和离线版，现在我通常用 <strong>mafft</strong>，mafft 比对完后会默认输出 CLUSTAL 的格式。好用的是他提供了 Reformat 来进行格式转换，基本包含了常用的所有格式。离线的一个 python 包工具为 <strong>seqmagick</strong>，可以进行 fasta 和 phylip，fasta 和 fastq 格式的转换，他还可以使用一个已经比对好的蛋白序列来进行蛋白的 DNA 序列的回比对（具体什么专业名字不清楚），也非常方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Phylip-格式&quot;&gt;&lt;a href=&quot;#Phylip-格式&quot; class=&quot;headerlink&quot; title=&quot;Phylip 格式&quot;&gt;&lt;/a&gt;Phylip 格式&lt;/h2&gt;&lt;p&gt;在使 pamlX 的 CodeML 进行 Ka/Ks 计算时，蛋白比对序列需要不含终
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>shinyCircos使用方法</title>
    <link href="http://yoursite.com/2019/03/19/shinyCircos/"/>
    <id>http://yoursite.com/2019/03/19/shinyCircos/</id>
    <published>2019-03-19T06:53:57.000Z</published>
    <updated>2019-03-19T08:37:40.198Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/venyao/shinyCircos" target="_blank" rel="noopener">https://github.com/venyao/shinyCircos</a></p><p>用perl写的circos的学习成本太高了，想看看两个基因组之间的差异（装个逼）怎么还得学习一周？现在我们用shinyCircos解决这个烦恼。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>shinyCircos是个用shiny部署的R应用，所以使用RStudio安装就好了。</p><p>首先先把这些包安装：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"shiny"</span>)  </span><br><span class="line">install.packages(<span class="string">"circlize"</span>)  </span><br><span class="line">install.packages(<span class="string">"RColorBrewer"</span>)</span><br><span class="line">install.packages(<span class="string">"data.table"</span>)</span><br><span class="line">install.packages(<span class="string">"RLumShiny"</span>)  </span><br><span class="line"><span class="comment"># try http:// if https:// URLs are not supported   </span></span><br><span class="line"><span class="keyword">source</span>(<span class="string">"https://bioconductor.org/biocLite.R"</span>)  </span><br><span class="line">biocLite(<span class="string">"GenomicRanges"</span>)</span><br></pre></td></tr></table></figure><p>然后进入项目主页，把整个项目下载下来放在自己硬盘的某个文件夹下并解压（解压后文件名为：shinyCircos-master）。</p><p>回到RStudio，并输入下面的命令，则会自动打开shinyCircos的程序网页。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(shiny)</span><br><span class="line">runApp(<span class="string">"your_dir/shinyCircos-master"</span>, launch.browser = <span class="literal">TRUE</span>)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/19/shinyCircos/shiny.jpg" alt=""></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>主页给出了所有文件的示例文件，下载下来对比自己的文件就可以知道需要做出什么改变。</p><h3 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h3><p>主文件包含3列：chr    start    end</p><p>如果是单基因组chr列按照普通染色体命名即可，如果要做多基因组之间的关系，染色体命名要区分开。</p><h3 id="tracks"><a href="#tracks" class="headerlink" title="tracks"></a>tracks</h3><p>tracks文件可以有任意多个，包含有散点图，条形图，折线图，热图等等。</p><p>散点图、折线图、条形图包含4列：chr    start    end    value1</p><p>热图包含：chr start end    value1    value2    value3 ……   valuen</p><h3 id="links-data"><a href="#links-data" class="headerlink" title="links data"></a>links data</h3><p>link data旨在描述染色体位点之间的关系。</p><p>数据包含6列或者7列：chr    start    end    chr    start    end    （color）</p><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><p>点击页面的 data upload，在Upload chromosome data下选择本地的染色体文件上传。然后，在Upload data for inner tracks下选择本地的track文件上传，点击后可以选择图的类型（散点，条形等）。最后在Upload data to create links下选择本地的连锁文件上传。点击左下角的Go！即可展示、检查全部上传的文件。</p><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><p>点击页面的 Circos viasualization进入画图界面。在Plot options下勾选你所上传的所有文件的名字。选择后会有各种细微的操作调整图画。最后点击左下角的Go！即可展示所做circos图，同时支持PDF,SVG和作图所用R脚本的下载。</p><p>具体实践需要理解各种文件的内容和所做出来的图的外观，相信你在不断的操作中会摸索到其中的方法的。毕竟一个可视化的界面比一个脚本界面舒服的多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/venyao/shinyCircos&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/venyao/shinyCircos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用per
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>plink-vcftools</title>
    <link href="http://yoursite.com/2019/03/01/plink-vcftools/"/>
    <id>http://yoursite.com/2019/03/01/plink-vcftools/</id>
    <published>2019-03-01T08:02:40.000Z</published>
    <updated>2019-03-11T10:00:12.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bcftools"><a href="#bcftools" class="headerlink" title="bcftools"></a>bcftools</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bgzip view.vcf  <span class="comment">#bgzip压缩</span></span><br><span class="line"></span><br><span class="line">bcftools index view.vcf.gz  <span class="comment">#建立索引</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcftools view view.vcf.gz -s NA00001,NA00002  -o subset.vcf  <span class="comment">#筛选样本</span></span><br><span class="line">bcftools view view.vcf.gz -s ^NA00001,NA00002 -o subset.vcf  <span class="comment"># ^去除样本</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools sort view.vcf.gz -o sort.view.vcf  <span class="comment">#排序vcf</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bcftools reheader -s trans.file sample.vcf -o new.sample.vcf  <span class="comment">#更改vcf文件中样本名</span></span><br><span class="line"></span><br><span class="line">cat trans.file</span><br><span class="line">    NA00001 NA1</span><br><span class="line">    NA00002 NA2</span><br><span class="line">    NA00003 NA3</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools concat chr1.vcf.gz chr2.vcf.gz -o concat.vcf  <span class="comment">#合并vcf文件</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcftools merge merge.a.vcf.gz merge.b.vcf.gz -o merge.vcf  <span class="comment">#合并vcf文件（单样本多vcf文件）</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcftools stats view.vcf &gt;  view.stats  <span class="comment">#统计vcf文件</span></span><br><span class="line">bcftools filter view.vcf.gz --regions chr16:17052042-17594883 &gt; filter.vcf  <span class="comment">#选择固定区域SNP</span></span><br></pre></td></tr></table></figure><h1 id="vcftools"><a href="#vcftools" class="headerlink" title="vcftools"></a>vcftools</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf myvcf.vcf --plink --out myplink  <span class="comment">#vcf2ped</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf final.vcf --min-alleles 2.0 --max-alleles 2.0 --max-missing 0.95 --non-ref-af 0.05 --max-non-ref-af 0.95 --recode -c &gt;filter.vcf  <span class="comment">#vcf过滤</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --vcf filter.vcf --thin  1000 --recode -c &gt;thin.vcf  <span class="comment">#按snp间隔过滤vcf</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vcftools --gzvcf file.vcf.gz --positions specific_position.txt --recode --out specific_position.vcf  <span class="comment">#选择指定SNP</span></span><br></pre></td></tr></table></figure><h1 id="plink"><a href="#plink" class="headerlink" title="plink"></a>plink</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --vcf myvcf.vcf --recode --out myplink  <span class="comment">#vcf2ped</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink --file FILENAME --make-bed --out FILENAME  <span class="comment">#ped2bed</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plink --bfile FILENAME --indep-pairwise 50 5 0.5  <span class="comment">#LD-pruning</span></span><br><span class="line">plink --bfile FILENAME --extract plink.prune.in --make-bed --out data_pruned</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plink -file FILENAME --recodeHV --out recode  <span class="comment">#haploview</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;bcftools&quot;&gt;&lt;a href=&quot;#bcftools&quot; class=&quot;headerlink&quot; title=&quot;bcftools&quot;&gt;&lt;/a&gt;bcftools&lt;/h1&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>gwas</title>
    <link href="http://yoursite.com/2019/01/04/gwas/"/>
    <id>http://yoursite.com/2019/01/04/gwas/</id>
    <published>2019-01-04T02:30:19.000Z</published>
    <updated>2019-01-04T08:13:49.709Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/04/gwas/gwas.jpg" alt=""></p><h2 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h2><p>质量控制是为了去掉在测序过程中低质量的、没有测到的和测序的接头序列。质控软件大同小异，在去除低质量碱基时，最好使用的方法应该是滑动窗口。</p><blockquote><p>因为根据目前的测序原理，read的错误率会明显富集于末端区域，而前半部分的质量都会比较高，这种计算(SOAPnuke按照低质量碱基比例去除序列)比例的方法并不能很好地反映这一现象。</p></blockquote><p>质控同时要注意测序下机数据 fq 文件的质量值格式是Phred33还是Phred64。</p><h2 id="数据比对"><a href="#数据比对" class="headerlink" title="数据比对"></a>数据比对</h2><p>数据比对软件还是最常用的 bwa ，在构建参考序列索引时，is 算法最快(基因组小于1G常用)，而 bwtsw 用于大基因组。</p><p>在 bwa mem算法比对时，<code>-R &#39;@RG\tID:foo_lane\tPL:illumina\tLB:library\tSM:sample_name&#39;</code>  -R参数中的@RG信息要给出，如果没有给出，仍然可以使用 picard 中 AddOrReplaceReadGroups 对 sam 或 bam 文件进行加头处理。这个信息对于我们后续对比对数据进行错误率分析和Mark duplicate时非常重要 。</p><p>另外，samtools 可以利用参考基因组为 sam 或者 bam 文件加上 header 中的 @SQ 信息。</p><h2 id="变异检测"><a href="#变异检测" class="headerlink" title="变异检测"></a>变异检测</h2><p>变异检测核心是使用 GATK 中的HaplotypeCaller 组件进行 snp calling 。而决定变异检测最终结果的好坏则是<strong>Variant quality score recalibration（VQSR）</strong>，其中VQSR中使用VariantFiltration进行硬过滤时，我的参数为：<code>--filterExpression &quot;QD &lt; 2.0 || MQ &lt; 40.0 || ReadPosRankSum &lt; -8.0 || FS &gt; 60.0|| HaplotypeScore &gt; 13.0 || MQRankSum &lt; -12.5&quot;</code></p><p>在获得变异 vcf 文件后将其转为基因型文件后，常常发现有些个体在某些位点上是没有基因型的，这个时候就需要Beagle软件将这些空缺的位点补齐，形成一份完整的变异文件。</p><p>vcf 文件也可以 使用SnpEff， Annovar 这个2个软件进行变异注释，得出每一个变异位点的确切功能。</p><h2 id="个性化分析"><a href="#个性化分析" class="headerlink" title="个性化分析"></a>个性化分析</h2><p>个性化是变异文件内容充分挖掘的过程，是从几百万 snp 位点中挑选出和表型具有显著联系的几个或几十个位点的过程。如果群体结构简单，是单一种群使用简单线性模型(GLM)即可得出良好的结果，如果测序的包含多个群体，或者单群体经过群体结构分析(PCA分析、structrue分析)分群严重，则可以使用混合线性模型(MLM)进行分析，MLM 需要亲缘矩阵(K)和群体结构矩阵(Q)作为协变量建模计算。</p><p>建模计算出结果后便可以使用结果中的P值画曼哈顿图和QQ图，QQ图用来检测结果的正态性，曼哈顿图中阈值一直在讨论和研究中，包括且不限于(Bonferroni校正，sampleM，Keff，SLIDE)方法来确定阈值，一般简单的，使用0.05/snp数作为阈值，如果结果有点差，可以做出图后确定阈值后在阈值上留下1-100个点为好。</p><p>在选出显著性位点后，查看注释文件确定位点的位置、变异、功能等，处于编码区还是非编码区，是否改变氨基酸等。接下来就是找出这些点所处的基因或基因的上下游什么位置。一般以位点的上下游500Kb搜寻，严格的可以以上下游100Kb。</p><p>经过资料、文献的确认接下来就要准确确认基因的信息(所选基因很可能是某个亚家族的一个分支)，方法可以是进化树、domain 分析。</p><h2 id="推荐文献"><a href="#推荐文献" class="headerlink" title="推荐文献"></a>推荐文献</h2><p>质控：</p><p>Sickle: A sliding-window, adaptive, quality-based trimming tool for FastQ files<br>Cutadapt removes adapter sequences from high-throughput sequencing reads</p><p>比对：</p><p>Fast and accurate short read alignment with Burrows–Wheeler transform</p><p>变异检测</p><p>Performance benchmarking of GATK3.8 and GATK4</p><p>A One-Penny Imputed Genome from Next-Generation Reference Panels</p><p>Genotype imputation for genome-wide association studies</p><p>Non-Synonymous and Synonymous Coding SNPs Show Similar Likelihood and Effect Size of Human Disease Association</p><p>个性化分析</p><p>Mixed linear model approach adapted for genome-wide association studies</p><p>The importance of cohort studies in the post-GWAS era</p><p>From genome- wide associations to candidate causal variants by statistical fine- mapping</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019/01/04/gwas/gwas.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;质量控制&quot;&gt;&lt;a href=&quot;#质量控制&quot; class=&quot;headerlink&quot; title=&quot;质量控制&quot;&gt;&lt;/a&gt;质量控制&lt;/h2&gt;&lt;p&gt;质量控制是为了去掉在
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>linux 工具替换</title>
    <link href="http://yoursite.com/2019/01/04/linux-tools/"/>
    <id>http://yoursite.com/2019/01/04/linux-tools/</id>
    <published>2019-01-04T02:03:23.000Z</published>
    <updated>2019-01-04T02:15:45.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ack"><a href="#ack" class="headerlink" title="ack"></a>ack</h2><p>用来代替linux中的grep，使用方法：</p><p><a href="https://github.com/beyondgrep/ack2" target="_blank" rel="noopener">https://github.com/beyondgrep/ack2</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ack text ./ <span class="comment">#在当前目录下所有文件中寻找text存在的行</span></span><br><span class="line">ack text test.py <span class="comment">#在test.py 文件中寻找text存在的行</span></span><br><span class="line">ack -i text test.py <span class="comment">#忽略大小写</span></span><br><span class="line">ack -v text test.py <span class="comment">#寻找没有text存在的行</span></span><br><span class="line">ack -w text test.py <span class="comment">#text必须是一个单词</span></span><br><span class="line">ack -H text test.py <span class="comment">#同时输出文件名和行号</span></span><br><span class="line">ack -m 2 text test.py <span class="comment">#最多输出2个匹配</span></span><br><span class="line">ack -g work <span class="comment">#通过正则表达寻找文件</span></span><br></pre></td></tr></table></figure><p><img src="/2019/01/04/linux-tools/ack.png" alt=""></p><h2 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h2><p>fzf 用来进行模糊匹配，超级强大。使用Ctrl+r 反向查看命令历史然后进行模糊搜索快速定位。less |fzf 可以快速查找需要内容。</p><p><a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a></p><p><code>less work1.1.1.py |fzf</code></p><p><img src="/2019/01/04/linux-tools/fzf.png" alt=""></p><p><code>Ctrl + r</code></p><p><img src="/2019/01/04/linux-tools/fzf2.png" alt=""></p><h2 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h2><p>progress可以显示系统绝大多数命令的进程。使用 -w 参数预估进程速度和剩余时间。</p><p><a href="https://github.com/Xfennec/progress" target="_blank" rel="noopener">https://github.com/Xfennec/progress</a></p><p><img src="/2019/01/04/linux-tools/progress.png" alt=""></p><h2 id="ccat"><a href="#ccat" class="headerlink" title="ccat"></a>ccat</h2><p>用来代替系统的cat命令（代码高亮）</p><p><a href="https://github.com/jingweno/ccat" target="_blank" rel="noopener">https://github.com/jingweno/ccat</a></p><p><img src="/2019/01/04/linux-tools/ccat.png" alt=""></p><h2 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h2><p>ncdu用来代替系统的du命令，使用友好的界面展示储存使用情况。</p><p><a href="https://github.com/rofl0r/ncdu" target="_blank" rel="noopener">https://github.com/rofl0r/ncdu</a></p><p><code>ncdu</code></p><p><img src="/2019/01/04/linux-tools/ncdu.png" alt=""></p><h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><p>tldr用来代替系统的man命令，相比man是给出一个命令的详细解释，tldr是给出一个命令的常用示例。</p><p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">https://github.com/tldr-pages/tldr</a></p><p><img src="/2019/01/04/linux-tools/tldr.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ack&quot;&gt;&lt;a href=&quot;#ack&quot; class=&quot;headerlink&quot; title=&quot;ack&quot;&gt;&lt;/a&gt;ack&lt;/h2&gt;&lt;p&gt;用来代替linux中的grep，使用方法：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beyondgre
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>sam文件header全面解析</title>
    <link href="http://yoursite.com/2018/11/20/sam-header/"/>
    <id>http://yoursite.com/2018/11/20/sam-header/</id>
    <published>2018-11-20T09:18:28.000Z</published>
    <updated>2018-11-20T09:26:14.366Z</updated>
    
    <content type="html"><![CDATA[<p>众说周知，最常用的比对软件 bwa 产生的结果文件是 sam 格式，具体格式可以参考 <a href="http://samtools.github.io/hts-specs/SAMv1.pdf" target="_blank" rel="noopener">sam</a> 。</p><p>其中文件的主体便是比对的结果，而头文件往往是我们最容易忽视的地方，尤其踩过太多的坑，特来解释和记录其 header。</p><p>header 中最常见的有3个：@SQ  @RG  @PG  ，@SQ 用来记录参考序列的信息，@RG 用来记录样本的信息，@PG 用来记录 bwa 程序信息。</p><p>@SQ 和 @PG 在 bwa 比对之后就会在 sam 文件中存在。而 @RG 则需要自己在 bwa mem 比对的命令中使用 -R 参数来添加。@RG 这个信息对于我们后续对比对数据进行错误率分析和Mark duplicate时非常重要 。</p><p>如果在 bwa 比对期间没有选择 -R 参数，可以 picard 中 AddOrReplaceReadGroups 对 sam 或bam 文件进行加头处理。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-R '@RG\tID:sample\tLB:sample\tSM:sample\tPL:ILLUMINA'   #bwa mem @RG头格式</span><br><span class="line"></span><br><span class="line">java -jar picard.jar AddOrReplaceReadGroups \   #sam或bam文件（picard ）</span><br><span class="line">      I = input.bam \ </span><br><span class="line">      O = output.bam \ </span><br><span class="line">      RGID = 4 \ </span><br><span class="line">      RGLB = lib1 \ </span><br><span class="line">      RGPL = illumina \ </span><br><span class="line">      RGPU = unit1 \ </span><br><span class="line">      RGSM = 20</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> bwa mem -t 4 genome.fa ./samples/A.fastq &gt;A.sam   <span class="comment">#非常普通的SE数据bwa比对</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> head -n 3 A.sam</span></span><br><span class="line">@SQ     SN:I    LN:230218</span><br><span class="line">@PG     ID:bwa  PN:bwa  VN:0.7.17-r1188 CL:bwa mem -t 4 genome.fa -R </span><br><span class="line">SRR800764.1     4       *       0       0       *       *       0       0       CATCTTTGGAGTAACTATTATTTCGCCCCTTTTGTTTGCTGCATATCGCCCCGCTCTCTGCATACACGATTGGATAATGACCAAAGCAAGGTTTAATACGC…………   #关键看头文件，后面比对信息省略</span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -Sb A.sam &gt; A.bam   <span class="comment">#转为bam文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools sort  A.bam &gt; A_sort.bam   <span class="comment">#排序</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> samtools view -h A_sort.bam &gt; A_sort.sam   <span class="comment">#再转回来sam文件，一定要加-h参数，默认是不输出header的。如果没有-h参数，是无法对sam文件进行转换和排序的。如下：</span></span></span><br><span class="line">[E::sam_parse1] missing SAM header</span><br><span class="line">[W::sam_read1] parse error at line 1</span><br><span class="line">[main_samview] truncated file.</span><br></pre></td></tr></table></figure><p>上面提到在缺少头文件的前提下是无法将 sam 转为 bam 的，更加无进行 bam 文件排序。但是如果我们使用 picard 这个问题就可以解决了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx5g -Djava.io.tmpdir=./tmp -jar ../picard-tools-1.117/SortSam.jar INPUT=A_sort.sam OUTPUT=A_sort.bam SORT_ORDER=coordinate VALIDATION_STRINGENCY=SILENT</span><br></pre></td></tr></table></figure><p>picard 的 SortSam.jar 可以直接对没有 header 的 sam 文件排序并转为 bam 文件。</p><p>另外，samtools 可以为sam或者bam文件加上 header 中的 @SQ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">samtools view -Sb -T genome.fa sample_no_header.sam &gt;sample_with_header.bam  #使用 -T 参考序列加header（@SQ）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众说周知，最常用的比对软件 bwa 产生的结果文件是 sam 格式，具体格式可以参考 &lt;a href=&quot;http://samtools.github.io/hts-specs/SAMv1.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;sam&lt;/a&gt;
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>水产育种中的基因组选择（翻译）(二)</title>
    <link href="http://yoursite.com/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/"/>
    <id>http://yoursite.com/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/</id>
    <published>2018-11-13T02:54:46.000Z</published>
    <updated>2018-11-13T10:08:46.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一个实现基因组预测的实例"><a href="#一个实现基因组预测的实例" class="headerlink" title="一个实现基因组预测的实例"></a>一个实现基因组预测的实例</h2><p>如上一节所述，许多方法已被用于基因组预测。这里，将使用R包<code>rrBLUP</code>展示实现基因组预测的示例 (Endelman, 2011)。在演示中，将使用另一个R包<code>BLR</code>中的599个小麦品系的数据集，这些小麦系在1279个DArT标记上进行基因分型。如果你是语言新手，有许多在线资源可用于获取R的基本介绍 (Torfs &amp; Brauer, 2014; Venables, Smith &amp; R Development Core Team, 2016)。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">'rrBLUP'</span>)</span><br><span class="line">install.packages(<span class="string">'BLR'</span>)</span><br><span class="line"><span class="keyword">library</span>(BLR)</span><br><span class="line"><span class="keyword">library</span>(rrBLUP)</span><br><span class="line"></span><br><span class="line">rm(list=ls())</span><br><span class="line">set.seed(<span class="number">99</span>)  <span class="comment">#设置随机数</span></span><br><span class="line">data(wheat)  <span class="comment">#载入小麦数据</span></span><br><span class="line"><span class="comment">############################################### marker-based</span></span><br><span class="line">M &lt;- <span class="number">2</span>∗X-<span class="number">1</span>  <span class="comment">#将标记转换为&#123;−1，1&#125;</span></span><br><span class="line">pheno &lt;-Y[,<span class="number">1</span>]  <span class="comment">#取第一列表型数据</span></span><br><span class="line">geno &lt;- M   <span class="comment">#取基因型数据</span></span><br><span class="line">whichTest&lt;-sample(<span class="number">1</span>:length(pheno),<span class="number">100</span>)   <span class="comment">#随机取出100个样本表型数据的编号</span></span><br><span class="line">phenoTrain &lt;- pheno[-whichTest]   <span class="comment">#取出训练集表型数据</span></span><br><span class="line">phenoTest &lt;- pheno[whichTest]     <span class="comment">#取出测试集表型数据</span></span><br><span class="line">GenoTrain &lt;- as.matrix(geno[-whichTest, ])   <span class="comment">#取出训练集基因型数据</span></span><br><span class="line">genoTest &lt;- as.matrix(geno[whichTest, ])     <span class="comment">##取出测试集基因型数据</span></span><br><span class="line">markerEffects &lt;- mixed.solve(y=phenoTrain, Z=GenoTrain)$u   <span class="comment">#计算位点效应</span></span><br><span class="line">predictedGBV &lt;- genoTest%∗%markerEffects    <span class="comment">#计算育种值</span></span><br><span class="line">(predictionAcc &lt;- cor(predictedGBV, phenoTest))   <span class="comment">#计算育种精确度</span></span><br><span class="line"><span class="comment"># 0.5370625</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################### kinship-based</span></span><br><span class="line">A1 &lt;-A.mat(M)   <span class="comment">#计算基因组关联矩阵</span></span><br><span class="line">rownames(A1) &lt;- <span class="number">1</span>:length(pheno)   <span class="comment">#替换A1矩阵行名</span></span><br><span class="line">yNA=pheno   <span class="comment">#取出表型</span></span><br><span class="line">yNA[whichTest] &lt;- <span class="literal">NA</span>   <span class="comment">#将测试集表型删除</span></span><br><span class="line">data1 &lt;-data.frame(y=yNA,gid=<span class="number">1</span>:length(pheno))   <span class="comment">#构建列表</span></span><br><span class="line">ans1 &lt;- kin.blup(data1,K=A1,geno=<span class="string">"gid"</span>,pheno=<span class="string">"y"</span>)   <span class="comment">#计算育种结果</span></span><br><span class="line">(cor(ans1$g[whichTest],Y[whichTest,<span class="number">1</span>]))   <span class="comment">#计算育种精确度</span></span><br><span class="line"><span class="comment"># 0.5370625</span></span><br></pre></td></tr></table></figure><h2 id="GS的几个重要考虑"><a href="#GS的几个重要考虑" class="headerlink" title="GS的几个重要考虑"></a>GS的几个重要考虑</h2><h3 id="需要多少动物进行基因分型？"><a href="#需要多少动物进行基因分型？" class="headerlink" title="需要多少动物进行基因分型？"></a>需要多少动物进行基因分型？</h3><p>GS 的准确性对与育种成功至关重要，它本身就是动植物育种的一个重要研究领域。除了选择统计模型外，GS 的准确性还取决于许多相互关联的因素，即基因组大小，标记密度，标记与 QTL之间的 LD，QTL 效应的数量和大小，有效群体大小，训练集的大小，训练与测试集动物的关系和性状遗传力。为了达到所需的精确度，训练集的动物数量主要取决于性状的遗传力估计和种群的有效规模。 (Ne) (Figure 2)。较低的遗传力估计将需要一个更大的训练集，同时，较大的Ne也需要相应的更大的训练样本。通常，更多的训练样本将为候选样本提供更准确的预测。例如， 荷斯坦奶牛需要有基因型和表型记录的3000-10000头公牛参考种群才能有0.7的基因组选择精确度。</p><p><img src="/2018/11/13/Genomic-Selection-in-Aquaculture-Breeding-Programs2/number.png" alt=""></p><p>​        <strong>Figure 2</strong> 参考种群中所需的动物数量，以便为估计的GBV精确性达到0.7(Goddard &amp; Hayes, 2009)</p><h3 id="多少SNP位点才足够？"><a href="#多少SNP位点才足够？" class="headerlink" title="多少SNP位点才足够？"></a>多少SNP位点才足够？</h3><p>snp位点应该覆盖整个基因组，并且要有足够的密度以确保大多数QTL都在LD中，需要至少有一个标记在LD区间，因此，对标记效应的估计可以捕捉到最大的遗传变异。所需SNP的总数主要取决于基因组大小和基因组的LD范围。通常，相邻SNP标记之间的LD的 <code>r2 &gt;0.2</code> ，那SNP将会足够(Calus et al., 2008)。</p><p>在实践中，50 K SNP 为奶牛品种提供了较好的预测精度。将密度从50 K进一步增加到800 K，只会略微增加预测精度 (Khatkar et al., 2012)。然而，如果训练集和测试集动物是相关的，基因组关联矩阵（GRM）可用于使用 gBLUP 预测 GBV。GRM 可以用一个很小的 SNP 集精确地计算出来。</p><p>用中等密度 SNP 芯片进行基因分型的成本(例如，牛的50 K SNP芯片)大约是每一个 DNA 样本40到100美元。基因分型和测序的成本正在迅速下降，使这项技术应用于更多物种，成本效益更高。此外，基因型估算可以有效地提高基因型数据的密度，降低成本。基因型估算包括用高密度 SNP 集对一小部分群体进行基因分型，并用低成本、低密度 SNP 位点预测其他群体的高密度基因型，这些经过计算模拟的基因型虽然不是太准确，但是还可以用于 GS (Khatkar et al., 2012)。</p><h3 id="对基因组预测来说，最重要的因素是样本数还是SNPs数？"><a href="#对基因组预测来说，最重要的因素是样本数还是SNPs数？" class="headerlink" title="对基因组预测来说，最重要的因素是样本数还是SNPs数？"></a>对基因组预测来说，最重要的因素是样本数还是SNPs数？</h3><p>更多的记录和更紧密的标记间距提高了准确性。但是，当 SNP 的密度很小时（小于1000个SNPs），在训练集中增加更多的动物对于提高基因组预测的准确性变得更加重要。</p><h3 id="是否有可能预测不同品种-群体？"><a href="#是否有可能预测不同品种-群体？" class="headerlink" title="是否有可能预测不同品种/群体？"></a>是否有可能预测不同品种/群体？</h3><p>是否有可能预测不同品种/群体—也就是说，使用一个品种的训练动物为另一个品种做预测。GS已成功地应用于群体内育种值的预测。然而，GS 在杂交预测中的成功是有限的。例如，当计算不属于训练组的品种的基因组预测时，精确度接近于零，或非常低 (Kachman et al., 2013)。在这种情况下，使用几个具有中/大效应的 SNP 并采用贝叶斯方法可能会有帮助，因为这可能只包括那些跨品系/品种分离的 QTL。</p><h3 id="我们需要有关基因和基因功能的知识吗？"><a href="#我们需要有关基因和基因功能的知识吗？" class="headerlink" title="我们需要有关基因和基因功能的知识吗？"></a>我们需要有关基因和基因功能的知识吗？</h3><p>在实践中，大多数GS方法主要使用(非线性)线性模型估计的 SNP 效应，或者仅仅使用 GRM，因此它们没有利用基因、基因功能的特定知识，甚至没有基因组中的SNPs的精确定位。</p><h3 id="准确性会随着世代下降吗？"><a href="#准确性会随着世代下降吗？" class="headerlink" title="准确性会随着世代下降吗？"></a>准确性会随着世代下降吗？</h3><p>一般，基因组选择中GBVs的预测是利用标记与数量性状位点（QTL）之间的 LD 来实现的。然而，在实践中，尤其是在种内预测，基因组预测的可靠性取决于候选/测试中动物与训练/参考动物之间遗传关系的强弱。因此，当应用于下一代时，来自固定训练集的预测方程的精度会迅速下降。这通常意味着预测方程需要通过添加来自更近几代的动物来更新。</p><h3 id="使用GS会增加近亲繁殖吗？"><a href="#使用GS会增加近亲繁殖吗？" class="headerlink" title="使用GS会增加近亲繁殖吗？"></a>使用GS会增加近亲繁殖吗？</h3><p>较短的世代间隔和较高的选择强度将使近交系的年率提高。特别是在选择的标记附近近亲繁殖。这将需要在管理种群近亲繁殖方面给予更多的关注。利用基因组关系信息进行仔细的交配选择，如最小同祖先交配和最优贡献选择，可以控制近交系。</p><h2 id="水产养殖中的基因组选择"><a href="#水产养殖中的基因组选择" class="headerlink" title="水产养殖中的基因组选择"></a>水产养殖中的基因组选择</h2><p>水产养殖物种繁多，由于生命周期、繁殖力、有效种群规模和育种目标的不同，GS 在水产养殖中的潜力将因品种不同而有所不同。目前，以水产养殖品种最多的传统养殖项目主要采用群体选择和家系选择两种方式。同胞系测试是针对那些不能直接在候选样本上测量的性状进行的(例如，在生命后期或屠宰时记录到的性状、抗病性)。以家系为基础的选择只使用了一小部分(一半)的遗传变异，并导致近亲育种的增加。GS 还可以预测家族内部的遗传差异，因此可以利用所有的遗传变异。由于只使用很少的动物/家系而导致近亲繁殖的增加是水产养殖中的一个主要问题。此外，在传统的选择方案中，个体的标记、谱系的记录和单独家系的饲养也是困难和昂贵的。遗传标记的信息可以帮助应对其中的一些挑战。随着测序和基因分型成本的降低，遗传标记和 GS 在水产养殖中的应用越来越受到人们的重视。然而，SNP 集的开发和基因组资源的应用直到最近才在几个水产养殖物种中进行，以此，在实际 GS 实施结果的信息是不全面的。已发表的报告主要是基于 GS 使用模拟数据的效率。所有的模拟研究表明，使用 GS 来进行水产养殖育种可以提高在生产(连续型)和疾病(二分型)位点的选择和遗传增益的准确性。(Sonesson &amp; Meuwissen, 2009)；(Nielsen, Sonesson &amp; Meuwissen, 2011)； (Lillehammer,Meuwissen &amp; Sonesson, 2013)，与传统的同胞系检测相比，近亲繁殖减少了81%(Sonesson &amp; Meuwissen, 2009)。通过结合传统的 BLUP 家系育种值和基于低密度基因分型而不影响遗传增益的家系内育种值，也可以降低基因分型的成本(Lillehammer et al., 2013)。</p><p>尽管基因分型和测序成本下降，由于大量样本的养殖和基因分型，基因组选择策略仍然需要很多的成本。然而，部分额外成本可以从增加的遗传收益中弥补而且与传统的选择方案相比，对同胞系样本测试的依赖更少。大多数水产养殖物种中个体动物的价值一般较低（与牛相比）。然而，由于大多数水产养殖物种的繁殖力很高，遗传增益的影响因遗传收益从繁殖核心立即转移到商业池塘而扩大。然而，利用GS优化育种方案还需要进一步的研究，比如在训练和选择中确定最佳的动物数量，标记密度，最小化近亲繁殖最大化长期遗传收益，与传统方案的比较的经济分析。GS 除了用于性状外，遗传标记在水产养殖中还可以提供比传统方法更多的优势，例如，性别相关标记的使用可以生产单性别的后代(Robinson et al., 2014)；基因渗入可以用来在种群中引入理想的基因，例如，通过反复回交和标记辅助选择，将对特定疾病的抗性从本地菌株转移到商品菌株(Odegard et al., 2009)；标记可用于监测和繁殖来自群体的任何有害突变；遗传物质的可操纵性来保护育种者。</p><p>总之，随着基因组技术的快速发展和基因组信息获取成本的不断降低，全基因组选择在提高盈利能力和在个体数增加依旧保持遗传变异性的同时，对提高水产养殖品种的食品生产水平具有很大的潜力。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>十分感谢 Dr. Gerhard Moser 对此手稿的建议。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>Calus, M.P., Meuwissen, T.H., de Roos, A.P. and Veerkamp, R.F. (2008) Accuracy of genomic selection using different methods to define haplotypes. Genetics, 178,553–561.<br>de Los Campos, G., Hickey, J.M., Pong-Wong, R. et al. (2013) Whole-genome regression and prediction methods applied to plant and animal breeding. Genetics, 193, 327–345.<br>de Los Campos, G., Naya, H., Gianola, D. et al. (2009) Predicting quantitative traits with regression models for dense molecular markers and pedigree. Genetics, 182, 375–385.<br>Endelman, J.B. (2011) Ridge regression and other kernels for genomic selection with R package rrBLUP. Plant Genome, 4, 250–255.<br>Erbe, M., Hayes, B.J., Matukumalli, L.K. et al. (2012) Improving accuracy of genomic predictions within and between dairy cattle breeds with imputed high-density single<br>nucleotide polymorphism panels. Journal of Dairy Science, 95, 4114–4129.<br>Falconer, D.S. and Mackay, T.F.C. (1996) Introduction to quantitative genetics, 4th edn, Longman, Essex, UK.<br>Gianola, D. and van Kaam, J.B. (2008) Reproducing kernel Hilbert spaces regression methods for genomic assisted prediction of quantitative traits. Genetics, 178,2289–2303.<br>Goddard, M.E. and Hayes, B.J. (2009) Mapping genes for complex traits in domestic animals and their use in breeding programmes. Nature Reviews Genetics, 10, 381–391.<br>Gonzalez-Camacho, J.M., de Los Campos, G., Perez, P. et al. (2012) Genome-enabled prediction of genetic values using radial basis function neural networks. Theoretical and Applied Genetics, 125, 759–771.<br>Gonzalez-Recio, O., Weigel, K.A., Gianola, D. et al. (2010) L2-Boosting algorithm applied to high-dimensional problems in genomic selection. Genetics Research (Cambridge), 92,227–237.<br>Habier, D., Fernando, R.L. and Dekkers, J.C. (2007) The impact of genetic relationship information on genome-assisted breeding values. Genetics, 177, 2389–2397</p><p>Habier, D., Fernando, R.L., Kizilkaya, K. and Garrick, D.J. (2011) Extension of the Bayesian alphabet for genomic selection. BMC Bioinformatics, 12, 186.</p><p>Heslot, N., Yang, H.P., Sorrells, M.E. and Jannink, J.L. (2012) Genomic selection in plant breeding: a comparison of models. Crop Science, 52 (1), 146–160.</p><p>Jannink, J.L., Lorenz, A.J. and Iwata, H. (2010) Genomic selection in plant breeding: from theory to practice. Briefings in Functional Genomics, 9, 166–177.<br>Kachman, S.D., Spangler, M.L., Bennett, G.L. et al. (2013) Comparison of molecular breeding values based on within- and across-breed training in beef cattle. Genetics Selection Evolution, 45, 30.<br>Khatkar, M.S., Moser, G., Hayes, B.J. and Raadsma, H.W. (2012) Strategies and utility of imputed SNP genotypes for genomic analysis in dairy cattle. BMC Genomics, 13, 538.<br>Khatkar, M.S., Zenger, K.R., Hobbs, M. et al. (2007) A primary assembly of a bovine haplotype block map based on a 15,036-single-nucleotide polymorphism panel genotyped in Holstein-Friesian cattle. Genetics, 176, 763–772.<br>Lillehammer, M., Meuwissen, T.H. and Sonesson, A.K. (2013) A low-marker density implementation of genomic selection in aquaculture using within-family genomic breeding values. Genetics Selection Evolution, 45, 39.<br>Maenhout, S., De Baets, B. and Haesaert, G. (2010) Prediction of maize single-cross hybrid performance: support vector machine regression versus best linear prediction. Theoretical and Applied Genetics, 120, 415–427.<br>Meuwissen, T.H., Hayes, B.J. and Goddard, M.E. (2001) Prediction of total genetic value using genome-wide dense marker maps. Genetics, 157, 1819–1829.<br>Moser, G., Tier, B., Crump, R.E. et al. (2009) A comparison of five methods to predictgenomic breeding values of dairy bulls from genome-wide SNP markers. Genetics Selection Evolution, 41, 56.<br>Nejati-Javaremi, A., Smith, C. and Gibson, J.P. (1997) Effect of total allelic relationship on accuracy of evaluation and response to selection. Journal of Animal Science, 75,1738–1745.<br>Nielsen, H.M., Sonesson, A.K. and Meuwissen, T.H. (2011) Optimum contribution selection using traditional best linear unbiased prediction and genomic breeding values in aquaculture breeding schemes. Journal of Animal Science, 89, 630–638.<br>Odegard, J., Yazdi, M.H., Sonesson, A.K. and Meuwissen, T.H. (2009) Incorporating desirable genetic characteristics from an inferior into a superior population using genomic selection. Genetics, 181, 737–745.<br>Ogutu, J.O., Piepho, H.P. and Schulz-Streeck, T. (2011) A comparison of random forests, boosting and support vector machines for genomic selection. BMC Proceedings, 5 (3), S11.<br>Pryce, J.E., Goddard, M.E., Raadsma, H.W. and Hayes, B.J. (2010) Deterministic models of breeding scheme designs that incorporate genomic selection. Journal of Dairy Science,93, 5455–5466.<br>Robinson, N.A., Gopikrishna, G., Baranski, M. et al. (2014) QTL for white spot syndrome virus resistance and the sex-determining locus in the Indian black tiger shrimp (Penaeus monodon). BMC Genomics, 15, 731.<br>Schaeffer, L.R. (2006) Strategy for applying genome-wide selection in dairy cattle. Journal of Animal Breeding and Genetics, 123, 218–223.<br>Sonesson, A.K. and Meuwissen, T.H.E. (2009) Testing strategies for genomic selection in aquaculture breeding programs. Genetics Selection Evolution, 41, 1.</p><p>Torfs, P. and Brauer, C. (2014). “A (very) short introduction to R,” Hydrology and Quantitative Water Management Group, Wageningen University, The Netherlands,available at <a href="https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf" target="_blank" rel="noopener">https://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf</a></p><p>Tsai, H.Y., Hamilton, A., Tinch, A.E. et al. (2015) Genome wide association and genomic prediction for growth traits in juvenile farmed Atlantic salmon using a high density SNP array. BMC Genomics, 16, 969.<br>VanRaden, P.M. (2008) Efficient methods to compute genomic predictions. Journal of Dairy Science, 91，4414–4423.<br>VanRaden, P.M., Van Tassell, C.P., Wiggans, G.R. et al. (2009) Invited review: reliability of genomic predictions for North American Holstein bulls. Journal of Dairy Science, 92,16–24.<br>Vazquez, A.I., de los Campos, G., Klimentidis, Y.C. et al. (2012) A comprehensive genetic approach for improving prediction of skin cancer risk in humans. Genetics, 192,1493–1502.<br>Venables, W.N., Smith, D.M. and the R Core Team. (2016). An introduction to R.<br>Notes on R: A programming environment for data analysis and graphics. Version 3.2.4 (2016-03-10) Available: <a href="https://cran.r-project.org/doc/manuals/R-intro.pdf" target="_blank" rel="noopener">https://cran.r-project.org/doc/manuals/R-intro.pdf</a>. Accessed 15 April 2016.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一个实现基因组预测的实例&quot;&gt;&lt;a href=&quot;#一个实现基因组预测的实例&quot; class=&quot;headerlink&quot; title=&quot;一个实现基因组预测的实例&quot;&gt;&lt;/a&gt;一个实现基因组预测的实例&lt;/h2&gt;&lt;p&gt;如上一节所述，许多方法已被用于基因组预测。这里，将使用R包&lt;
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>水产育种中的基因组选择（翻译）(一)</title>
    <link href="http://yoursite.com/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/"/>
    <id>http://yoursite.com/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/</id>
    <published>2018-11-08T02:47:36.000Z</published>
    <updated>2018-11-13T02:55:27.492Z</updated>
    
    <content type="html"><![CDATA[<p>​                                                                                                                                                 作者：Mehar S. Khatkar </p><p>​                                                                                                                                                 翻译：轩暮</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>基因组选择最初在2001年被提出，如今已经在家畜中广泛应用。但是迄今为止在水产物种中的应用却十分受限。在这一章我们介绍了基因组选择的基本原理，并给出如何进行基因组选择的示例，在结尾提出了一些对水产物种的看法。</p><p>最新研究的分子技术为获得成千上万的遗传标记提供了可能（典型的标记 SNPs），即使在没有基因组组装或遗传图谱的物种中也是如此。基因分型和测序的成本不断下降，使得在许多水产物种中使用这些工具成为可能。来自家系或非家系群体的基因型数据可以提供对种群结构、基因关联和选择育种信息的见解。事实上，随着分子数据的容易获得性，就不再需要记录家系信息，这可以大大简化育种计划，特别是在水产物种中。本章首先介绍了基因组选择的概念，即遗传标记在选择育种中的应用，然后介绍了遗传标记在水产育种中的应用前景。</p><h2 id="基因组选择"><a href="#基因组选择" class="headerlink" title="基因组选择"></a>基因组选择</h2><p>分子标记在动物育种中的应用已经有很长一段时间了。然而，直到近些年可以大量地获得全基因组的分子标记，才使得使用DNA检测来直接预测动物的育种特性成为可能。通过模拟， Meuwissen,Hayes, and Goddard (2001)表明动物的遗传值可以不使用其表型或家系信息，只使用在染色体上高密度标记的基因型被准确地估计出来。在这种方法中，最著名的就是基因组选择（genomic selection，GS）或称为全基因组选择（whole genome selection），选择决定是根据基因组育种值(GBVs)作出的，基因组育种值一般使用高密度标记（SNPs）计算得出。基因组选择依赖于如下假设：全基因组标记的密度足够高、至少一个数量性状位点处于高度连锁不平衡区间。整个基因组标记效应的估计将为某一个性状的遗传价值提供准确的预测。</p><p>基因组选择的实现非常简单。它使用“训练群体”（多个个体样本）来建立预测方程，该群体既有基因型也有表型。然后，将此方程应用于“测试群体”（另外多个个体样本）的基因型，以计算分子或基因组的育种值(GBVs)。使用育种值排序和选择样本来作为下一代的父母本。（Figure 1）如果需要，可以再使用传统的估计育种值(EBVs)来生成基因组估计育种值(GEBV)。</p><p><img src="/2018/11/08/Genomic-Selection-in-Aquaculture-Breeding-Programs/GS.png" alt=""></p><p>​                                          <strong>Figure 1</strong> 基因组选择概述（改编自Goddard &amp; Hayes, 2009）</p><p>与传统育种方案相比，基因组选择可以提高遗传增益率，因为它可以大幅缩短世代间隔和增加选择强度(Schaeffer, 2006)。例如，绵羊和奶牛的遗传改良率分别提高了25%和100%。基因组选择对于昂贵且难以测定表型的性状尤其有吸引力，这些性状仅以是否死亡来衡量，或在生命后期表达出来(Pryce et al., 2010)。基因组选择可能会增加难以记录性状的遗传增益，例如水产养殖和家禽品种的抗病性，猪的肉质和绵羊一生的羊毛产量及抗虫性。基因组选择技术被认为是动植物育种计划中的一个巨大里程碑。在家畜中，SNP 芯片首次应用在牛中(Khatkar et al., 2007)，这使得基因组选择首次成功地应用于奶牛(Moser et al., 2009)；(VanRaden et al., 2009)。基因组选择已经取代了许多国家的后裔测定方法，或者正应用于后裔测定的幼年公牛预选。目前，基因组选择正被应用于许多其他动植物物种中(Goddard &amp; Hayes,2009)，都具有不同程度的成功。基因组预测的原理甚至在人类研究中得到了应用，特别是对于高危人群的识别进行了最佳干预和个性化治疗。例如，一种基因组预测方法被用来预测人类患皮肤癌的可能性，并取得了很好的结果(Vazquez et al., 2012)。然而，应该注意到在使用“基因组选择”和“基因组预测”这两个术语方面的区别。“基因组选择”已被用于动物育种计划，这包括通过基因组预测鉴定遗传优越的动物选择和选择动物交配以生产下一代。相比之下，“基因组预测”只涉及从基因组信息中预测个体的遗传值，并且更适合于人类研究。</p><h2 id="基因组选择的步骤"><a href="#基因组选择的步骤" class="headerlink" title="基因组选择的步骤"></a>基因组选择的步骤</h2><p>图 1 已经概述了基因组选择，包括以下主要步骤。</p><h3 id="参考群体的准备"><a href="#参考群体的准备" class="headerlink" title="参考群体的准备"></a>参考群体的准备</h3><p>构建参考种群需要大量的动物样本。这些动物被用来测定所感兴趣的性状，并对基因组范围的标记进行基因分型，通常使用 snp 芯片来获得大量的 snp 标记。为了进行统计分析，SNP 基因型通常编码为数值变量，取值为0、1或2，分别对应于一个纯合子、杂合子、另一个纯合子。参考群体通常分为训练集和验证集。</p><h3 id="预测方程"><a href="#预测方程" class="headerlink" title="预测方程"></a>预测方程</h3><p>每个 SNP 标记（编码为0，1和2，一个等位基因的数目或拷贝）效果估计(W)的训练结果统计分析以及所有标记的基因型效应联合生成一个预测方程来估计每种动物的育种值。</p><p>​                    <strong>GBV = w1∗ SNP1 + w2∗ SNP2 + w3∗ SNP3 +…+ Wn∗ SNPn</strong></p><p>w是偏回归系数或称为某个SNP的效应值大小，SNP是基因型（数值型）的载体。</p><p>下节提到的许多分析方法的其中一种可以用来建立这样的方程。</p><h3 id="预测方程的验证"><a href="#预测方程的验证" class="headerlink" title="预测方程的验证"></a>预测方程的验证</h3><p>验证集中的动物也有基因型和表型的数据。将上述预测方程应用于验证集动物的基因型，用以估计 GBVs。预测方程的准确性是通过将估计的 GBVs 值与实际的表型信息进行比较来评估的。连续性状的预测精度可以用性状的预测值和实际值的方差或相关系数来衡量。此步骤是可选的，但提供了关于基因组选择准确性的重要信息，因此建议进行。</p><h3 id="测试集个体育种值的计算"><a href="#测试集个体育种值的计算" class="headerlink" title="测试集个体育种值的计算"></a>测试集个体育种值的计算</h3><p>测试集个体只需有基因型，不需要表型信息。将预测方程应用于这些动物的基因型计算中。</p><h3 id="选择与交配"><a href="#选择与交配" class="headerlink" title="选择与交配"></a>选择与交配</h3><p>测试集个体根据GBVs进行排序，而排在顶端的动物则被挑选和交配来生产下一代。</p><h2 id="基因组预测模型"><a href="#基因组预测模型" class="headerlink" title="基因组预测模型"></a>基因组预测模型</h2><p>几种分析方法已被应用于全基因组的遗传优势预测。可大致分为三大类：</p><ol><li>回归方法：基因组选择最简单的形式就是估计每个标记或者数量性状位点（QTL）的效应，然后对每个个体在基因组中的所有位点进行总结。这必须假定有效应的标记处于 LD 区间或者他们本身就是 QTL 位点，而且大部分的遗传变异都是可加的。然而，在使用高密度 SNP 集情况下，标记的数量（p）远大于在训练集中做训练的动物数量（n）。这使得使用简单回归模型估计所有标记的效应具有挑战性。为了解决这个大 p 与小 n 回归问题，提出几种变量选择和收缩估计方法来解决具表型的全基因组预测。Meuwissen et al. (2001)提出三种方法：<code>BLUP (rrBLUP)</code>，<code>Bayes A</code> 和 <code>Bayes B</code> 可以在预测模型中容纳大量的遗传标记。这些方法和其他后续贝叶斯方法：<code>Bayes C𝜋</code> (Habier et al.， 2011)，<code>Bayesian LASSO</code> (de Los Campos et al.， 2009)， <code>Bayes-R</code> (Erbe et al.，2012) 的不同之处在于SNP/QTL效应的先验分布的定义。关于这些办法的详细介绍和比较，请看 de Los Campos et al. (2013)。偏最小二乘回归 (PLSR) 和主成分回归（PC）通过计算隐变量来降维从而进行预测。(Jannink,，Lorenz &amp; Iwata，2010；Moser et al.，2009)。</li><li>基因组关系法：基因组关系法也被称为“gBLUP”。在此方法中，需要计算个体间的基因组关系矩阵(GRM)。然后使用 GRM 计算所有动物的育种值。这种方法与传统的“动物模型”是等价的，主要的区别在于用 GRM 替换基于家系的关系矩阵。同样的模型可以用来估计方差分量和遗传参数。这个框架可以很容易地扩展到多重性状的分析中。这在水产养殖中的应用是非常具有吸引力的，因为水产养殖记录家系信息是非常困难和昂贵的，而 gBLUP 不需要记录谱系信息直接应用于育种。GRM 是基于实际的基因组相似性估计实际亲缘关系。因此，与基于家系的预期关系相比它更准确。比如，减数分裂时染色体的随机分离会导致全同胞家系样本间实际基因组相似性的变化 (Nejati-Javaremi, Smith &amp; Gibson, 1997)。GRM 可以从标记的基因型矩阵构建。VanRaden (2008) 描述了3种构建 GRM 的方法并评价了它们的实际表现。</li><li>半参数和机器学习方法：在大多数实践应用中，GBVs只包括加性效应(传递给下一代遗传优势)。然而，在一些育种计划中，发掘显性基因和上位效应会是可取的。例如，通过选配和杂种优势生产具有最高遗传价值的(杂交)后代 (Falconer &amp; Mackay, 1996)。Gianola and van Kaam (2008) 提出非参数方法可以在不显式建模的情况下解释复杂的上位性效应。基因组选择的半参数和非参数程序，如再生核希尔伯特空间 (Gianola &amp; van Kaam, 2008)，径向基函数神经网络(Gonzalez-Camacho et al., 2012)，支持向量机(SVM) (Maenhout,DeBaets &amp; Haesaert, 2010; Moser et al., 2009)，惩罚支持向量机 ，随机森林(Ogutu, Piepho &amp; Schulz-Streeck, 2011)，boosting (Gonzalez-Recio et al.,2010)可以潜在地利用数千个标记之间的交互作用。 Heslot et al. (2012) 在植物基因组选择中比较了包括机器学习在内的10种不同的方法。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​                                                                                                                                        
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>biopython NCBI</title>
    <link href="http://yoursite.com/2018/11/08/biopython-NCBI/"/>
    <id>http://yoursite.com/2018/11/08/biopython-NCBI/</id>
    <published>2018-11-08T02:16:07.000Z</published>
    <updated>2018-11-08T02:17:12.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问NCBI-Entrez数据库"><a href="#访问NCBI-Entrez数据库" class="headerlink" title="访问NCBI Entrez数据库"></a>访问NCBI Entrez数据库</h1><p>Entrez (<a href="http://www.ncbi.nlm.nih.gov/Entrez" target="_blank" rel="noopener">http://www.ncbi.nlm.nih.gov/Entrez</a>) 是一个给客户提供 NCBI 各个数据库（如PubMed, GeneBank, GEO等等）访问的检索系统。 用户可以通过浏览器手动输入查询条目访问Entrez，也可以使用 Biopython 的 <code>Bio.Entrez</code> 模块以编程方式访问来访问 Entrez。 如果使用第二种方法，用户用一个 Python 脚本就可以实现在PubMed 里面搜索或者从 GenBank 下载数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; pip install Bio  <span class="comment">#安装模块</span></span><br></pre></td></tr></table></figure><h2 id="ESearch-搜索Entrez数据库"><a href="#ESearch-搜索Entrez数据库" class="headerlink" title="ESearch: 搜索Entrez数据库"></a>ESearch: 搜索Entrez数据库</h2><p>esearch 会根据参数得出所需文献、序列等的 ID 号。</p><p>检索文献：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>  <span class="comment">#Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"pubmed"</span>, term=<span class="string">"biopython"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"IdList"</span>]</span><br><span class="line">[<span class="string">'19304878'</span>, <span class="string">'18606172'</span>, <span class="string">'16403221'</span>, <span class="string">'16377612'</span>, <span class="string">'14871861'</span>, <span class="string">'14630660'</span>, <span class="string">'12230038'</span>]</span><br></pre></td></tr></table></figure><p>检索序列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"nucleotide"</span>,term=<span class="string">"Cypripedioideae[Orgn] AND matK[Gene]"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"Count"</span>]</span><br><span class="line"><span class="string">'25'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record[<span class="string">"IdList"</span>]</span><br><span class="line">[<span class="string">'126789333'</span>, <span class="string">'37222967'</span>, <span class="string">'37222966'</span>, <span class="string">'37222965'</span>, ..., <span class="string">'61585492'</span>]</span><br></pre></td></tr></table></figure><p>常用db参数：<code>pubmed</code> <code>nucleotide</code> <code>protein</code> <code>gene</code> <code>snp</code> <code>unigene</code> ，默认为<code>pubmed</code></p><p>term参数：在检索文献时，term 就是关键词。在检索序列时，ncbi 自己有一套规则，如<code>Cypripedioideae[Orgn] AND matK[Gene]</code>的意思是 拖鞋兰物种中的 matK 基因序列</p><p><code>biomol_mrna[properties] AND Osteichthyes[organism]</code>  只要 mRNA 序列在硬骨鱼纲中</p><p>其他关键词还有：<strong>OR</strong> <strong>NOT</strong></p><h2 id="EFetch-从Entrez下载数据"><a href="#EFetch-从Entrez下载数据" class="headerlink" title="EFetch: 从Entrez下载数据"></a>EFetch: 从Entrez下载数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=<span class="string">"186972394"</span>, rettype=<span class="string">"fasta"</span>, retmode=<span class="string">"text"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (handle.read())</span><br><span class="line">&gt;EU490707<span class="number">.1</span> Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast</span><br><span class="line">ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTACTTGTGAAACGTTTAA</span><br><span class="line">TTACTCGAATGTATCAACAGAATTTTTTGATTTCTTCGGTTAATGATTCTAACCAAAAAGGATTTTGGGG</span><br><span class="line">GCACAAGCATTTTTTTTCTTCTCATTTTTCTTCTCAAATGGTATCAGAAGGTTTTGGAGTCATTCTGGAA</span><br><span class="line">ATTCCATTCTCGTCGCAATTAGTATCTTCTCTTGAAGAAAAAAAAATACCAAAATATCAGAATTTACGAT</span><br><span class="line">CTATTCATTCAATATTTCCCTTTTTAGAAGACAAATTTTTACATTTGAATTATGTGTCAGATCTACTAAT</span><br><span class="line">ACCCCATCCCATCCATCTGGAAATCTTGGTTCAAATCCTTCAATGCCGGATCAAGGATGTTCCTTCTTTG</span><br><span class="line">………………</span><br></pre></td></tr></table></figure><p>id 参数 ：ncbi 为每一条序列标识的ID号，可以使用 Entrez.esearch 获得。</p><p>rettype 参数：常用的有 <code>fasta</code> <code>gb</code></p><p>retmode 参数：数据的组织形式有 <code>text</code>  <code>xml</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez, SeqIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=<span class="string">"186972394"</span>,rettype=<span class="string">"gb"</span>, retmode=<span class="string">"text"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = SeqIO.read(handle, <span class="string">"genbank"</span>)  <span class="comment">#使用SeqIO 读入genbank序列</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (record)</span><br><span class="line">ID: EU490707<span class="number">.1</span></span><br><span class="line">Name: EU490707</span><br><span class="line">Description: Selenipedium aequinoctiale maturase K (matK) gene, partial cds; chloroplast.</span><br><span class="line">Number of features: <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">Seq(<span class="string">'ATTTTTTACGAACCTGTGGAAATTTTTGGTTATGACAATAAATCTAGTTTAGTA...GAA'</span>, IUPACAmbiguousDNA())</span><br></pre></td></tr></table></figure><h2 id="EGQuery-全局搜索-统计搜索的条目"><a href="#EGQuery-全局搜索-统计搜索的条目" class="headerlink" title="EGQuery: 全局搜索- 统计搜索的条目"></a>EGQuery: 全局搜索- 统计搜索的条目</h2><p>EGQuery提供搜索字段在每个Entrez数据库中的数目。当我们只需要知道在每个数据库中能找到的条目的个数， 而不需要知道具体搜索结果的时候，这个非常的有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"1009133184@qq.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.egquery(term=<span class="string">"biopython"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> record[<span class="string">"eGQueryResult"</span>]: <span class="keyword">print</span> row[<span class="string">"DbName"</span>], row[<span class="string">"Count"</span>]</span><br><span class="line">...</span><br><span class="line">pubmed <span class="number">6</span></span><br><span class="line">pmc <span class="number">62</span></span><br><span class="line">journals <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="搜索，下载，和解析Entrez核酸记录"><a href="#搜索，下载，和解析Entrez核酸记录" class="headerlink" title="搜索，下载，和解析Entrez核酸记录"></a>搜索，下载，和解析Entrez核酸记录</h2><p>获取 Cypripedioideae 在 gene 库的条目数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entrez.email = <span class="string">"A.N.Other@example.com"</span>     <span class="comment"># Always tell NCBI who you are</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.egquery(term=<span class="string">"Cypripedioideae"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> record[<span class="string">"eGQueryResult"</span>]:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> row[<span class="string">"DbName"</span>]==<span class="string">"gene"</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> row[<span class="string">"Count"</span>]</span><br><span class="line"><span class="number">376</span></span><br></pre></td></tr></table></figure><p>获得这376条数据的ID：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> Bio <span class="keyword">import</span> Entrez</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.esearch(db=<span class="string">"nucleotide"</span>, term=<span class="string">"Cypripedioideae"</span>, retmax=<span class="number">376</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = Entrez.read(handle)</span><br></pre></td></tr></table></figure><p>使用 <code>efetch</code> 来下载这些结果的前5条：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>idlist = <span class="string">","</span>.join(record[<span class="string">"IdList"</span>][:<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (idlist)</span><br><span class="line"><span class="number">187237168</span>,<span class="number">187372713</span>,<span class="number">187372690</span>,<span class="number">187372688</span>,<span class="number">187372686</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>handle = Entrez.efetch(db=<span class="string">"nucleotide"</span>, id=idlist, retmode=<span class="string">"xml"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>records = Entrez.read(handle)  <span class="comment">#解析xml文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (len(records))</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问NCBI-Entrez数据库&quot;&gt;&lt;a href=&quot;#访问NCBI-Entrez数据库&quot; class=&quot;headerlink&quot; title=&quot;访问NCBI Entrez数据库&quot;&gt;&lt;/a&gt;访问NCBI Entrez数据库&lt;/h1&gt;&lt;p&gt;Entrez (&lt;a hre
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>python和R中的数据合并</title>
    <link href="http://yoursite.com/2018/10/31/merge-in-python-and-R/"/>
    <id>http://yoursite.com/2018/10/31/merge-in-python-and-R/</id>
    <published>2018-10-31T02:40:22.000Z</published>
    <updated>2018-12-13T08:45:51.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pandas（python）"><a href="#pandas（python）" class="headerlink" title="pandas（python）"></a>pandas（python）</h2><p><code>pandas.merge</code>可根据一个或多个键将不同 DataFrame 中的行连接起来。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">df1</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">   data1 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   a</span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>   c</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a</span><br><span class="line"><span class="number">6</span>      <span class="number">6</span>   b</span><br><span class="line"></span><br><span class="line">df2</span><br><span class="line">Out[<span class="number">6</span>]: </span><br><span class="line">   data2 key</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   a</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b</span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>   d</span><br><span class="line"></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line">Out[<span class="number">7</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>注意，我并没有指明要用哪个列进行连接。如果没有指定，merge就会将重叠列的列名当做键。不过，最好明确指定一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">40</span>]: pd.merge(df1, df2, on=<span class="string">'key'</span>)</span><br><span class="line">Out[<span class="number">40</span>]: </span><br><span class="line">   data1 key  data2</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>   b      <span class="number">1</span></span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>   a      <span class="number">0</span></span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>   a      <span class="number">0</span></span><br></pre></td></tr></table></figure><p>如果两个对象的列名不同，也可以分别进行指定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">41</span>]: df3 = pd.DataFrame(&#123;<span class="string">'lkey'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],</span><br><span class="line">   ....:                     <span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: df4 = pd.DataFrame(&#123;<span class="string">'rkey'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],</span><br><span class="line">   ....:                     <span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br><span class="line">Out[<span class="number">43</span>]: </span><br><span class="line">   data1 lkey  data2 rkey</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>    b      <span class="number">1</span>    b</span><br><span class="line"><span class="number">3</span>      <span class="number">2</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">4</span>      <span class="number">4</span>    a      <span class="number">0</span>    a</span><br><span class="line"><span class="number">5</span>      <span class="number">5</span>    a      <span class="number">0</span>    a</span><br></pre></td></tr></table></figure><p>结果里面c和d以及与之相关的数据消失了。默认情况下，merge做的是“内连接”<code>how=&#39;outer&#39;</code>；结果中的键是交集。其他方式还有”left”、”right”以及”outer”。</p><p><img src="/2018/10/31/merge-in-python-and-R/merge.png" alt=""></p><p>要根据多个键进行合并，传入一个由列名组成的列表即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">51</span>]: left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">   ....:                      <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">   ....:                      <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],</span><br><span class="line">   ....:                       <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],</span><br><span class="line">   ....:                       <span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">  key1 key2  lval  rval</span><br><span class="line"><span class="number">0</span>  foo  one   <span class="number">1.0</span>   <span class="number">4.0</span></span><br><span class="line"><span class="number">1</span>  foo  one   <span class="number">1.0</span>   <span class="number">5.0</span></span><br><span class="line"><span class="number">2</span>  foo  two   <span class="number">2.0</span>   NaN</span><br><span class="line"><span class="number">3</span>  bar  one   <span class="number">3.0</span>   <span class="number">6.0</span></span><br><span class="line"><span class="number">4</span>  bar  two   NaN   <span class="number">7.0</span></span><br></pre></td></tr></table></figure><h2 id="dplyr（R）"><a href="#dplyr（R）" class="headerlink" title="dplyr（R）"></a>dplyr（R）</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">innner_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#内连接</span></span><br><span class="line">left_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#左连接</span></span><br><span class="line">right_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#右连接</span></span><br><span class="line">full_join(x, y, by = <span class="string">"z"</span>)  <span class="comment">#全连接</span></span><br><span class="line">innner_join(x, y, by = c(<span class="string">"q"</span>,<span class="string">"j"</span>))  <span class="comment">#按多键连接</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pandas（python）&quot;&gt;&lt;a href=&quot;#pandas（python）&quot; class=&quot;headerlink&quot; title=&quot;pandas（python）&quot;&gt;&lt;/a&gt;pandas（python）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pandas.merge&lt;/co
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>SNP位点对基因的影响</title>
    <link href="http://yoursite.com/2018/10/30/The-effect-of-snp-on-genes/"/>
    <id>http://yoursite.com/2018/10/30/The-effect-of-snp-on-genes/</id>
    <published>2018-10-30T08:17:12.000Z</published>
    <updated>2018-10-31T01:47:56.693Z</updated>
    
    <content type="html"><![CDATA[<p>snp 是 single-nucleotide polymorphism 的简称，中文为单核苷酸多态性。snp 是如今遗传研究中最热门的一个研究对象，第一是因为他在生物中大量存在，分布广泛。第二他是引起人类（也包含其他生物）疾病的重要原因。</p><p>简单来说，snp 就是一个碱基发生了改变。snp 导致基因的转录、翻译受到影响，蛋白质序列、结构的变化使其无法实行原来特定的功能，人因此患上了某一种疾病。那么 snp 有哪些种类？是否所有的 snp 都能够造成基因的变异呢？</p><h2 id="snp-的种类"><a href="#snp-的种类" class="headerlink" title="snp 的种类"></a>snp 的种类</h2><ul><li>非同义编码 SNP（non-synonymous coding SNPs，nscSNPs） </li><li>同义编码 SNP（synonymous coding SNPs，scSNPs） </li><li>内含子区 SNP </li><li>基因调控区域 SNP </li></ul><p><img src="/2018/10/30/The-effect-of-snp-on-genes/Gene_structure.png" alt=""></p><h2 id="不同snp对基因的影响"><a href="#不同snp对基因的影响" class="headerlink" title="不同snp对基因的影响"></a>不同snp对基因的影响</h2><p>非同义编码 SNP，顾名思义就是碱基的改变导致翻译出的蛋白质和原来不同，他会直接改变基因编码蛋白的氨基酸组成，其功能影响取决于变异氨基酸位点是否对蛋白结构或功能起到至关重要的作用。 </p><p>同义编码 SNP，本身并不改变蛋白质序列，但由于蛋白质翻译存在密码子偏好性，从常用的密码子转到发生多态性之后的不常用密码子，这个过程会导致核糖体通过 SNP 周围 mRNA 片段时速度发生改变，而细胞内的蛋白质折叠过程一般被认为是与翻译过程同步进行的，因此这些 scSNP 会影响 P-gp 折叠和其转移到细胞膜的时间，因此会改变底物和抑制物的作用位点的结构  。</p><p>内含子区 SNP，内含子在真核生物基因组中占有很大比重，因此分布在内含子区域的 SNP 也很多， 但分析表明内含子区域的 SNP 的致病风险明显低于编码区和基因调控区，但位于第一个内含子的 SNP 比其他内含子中 SNP 有更大的致病风险 。与内含子相关的大多数引起疾病的突变集中在内含子—外显子连接处（GU或AG）。每个外显子和内含子连接区具有高度保守和一致的序列，即大多数内含子5’末端以GT开始，大多数内含子3’末端与AG开始，称为GT-AG规则。</p><p>基因调控区域 SNP ，基因的调控区域主要包括启动子、5’UTR 和 3’UTR，这些区域有很多基因表达调控序列元件，如转录因子结合位点（Transcription factor binding site, TFBS）、 miRNA 结合位点等。这些序列元件与调控因子（转录因子、miRNA 等）的结合都需要特定的序列组成，这些位点发生的 SNP 可能会导致调控因子的结合能力发生改变，从 而影响正常的基因表达调控事件。 </p><p><img src="/2018/10/30/The-effect-of-snp-on-genes/snp.png" alt=""></p><h2 id="深入基因调控区域的snp"><a href="#深入基因调控区域的snp" class="headerlink" title="深入基因调控区域的snp"></a>深入基因调控区域的snp</h2><p>在 GWAS 研究中会发现绝大多数的 snp 位点都定位到了非编码区。编码区的snp位点很好理解：哪个基因编码发生改变，那对应的蛋白也不会行使正常的功能。而基因调控区的snp位点要明白到底如何影响基因功能需要花上不少精力。</p><p>上面已经说过，基因调控区域 SNP会影响转录因子结合位点、miRNA 结合位点等。基因表达模式主要是靠各种启动子和增强子来决定的，这些调控元件将各种信号因子和转录因子信息整合起来对基因表达进行调控。 转录因子通过结合在DNA的增强子或启动子区域上调节相应基因，提高或降低基因的转录水平。，如果基因上游调控区发生变异就可能影响基因的转录激活。 </p><p>为了得到确切的结果，我们可以将 snp 集进行注释，注释工具主流的有 snpEFF，Annovar。最终会得到每一个 snp 的变异类型和影响区域。</p><p>如果一个 snp 对基因的表达产生了影响，那么这个 snp 可称为 eQTL位点（expression Quantitative Trait Loci,eQTL ）。可以提取样本的 RNA 进行 qRT-PCR 得到某几个候选基因的表达量作为表型，snp 集作为基因型进行 GWAS 分析。最终得到显著 snp 位点，如果显著 snp 位点恰好在候选基因周围的调控区域，那么这个 snp 位点就是一个 cis-eQTL （顺式eQTL），不在候选基因周围的调控区域，就要进一步研究是否对候选基因有作用，如果成立，那这个 snp 位点就是一个 trans-eQTL （反式eQTL）。研究发现顺式 eQTL 的数量要远多于反式 eQTL。</p><p><img src="/2018/10/30/The-effect-of-snp-on-genes/eqtl.png" alt=""></p><p>现在对于非编码区的碱基效应研究还没有编码区那么明了，但是以后一定会将整个基因组研究透彻。总之，一个碱基或者多个碱基的改变会从不同层面，不同量级去影响基因的表达。就像是蝴蝶效应：一个小小的改变终将会影响这个世界，条件只是时间在时间轴的运行的时间。</p><p>参考文献</p><p>[1] 许超. SNP对基因表达影响的生物信息学模型[D]. 苏州大学, 2012. </p><p>[2] 卢坤, 曲存民, 李莎,等. 甘蓝型油菜BnTT3基因的表达与eQTL定位分析[J]. 作物学报, 2015, 41(11):1758-1766. </p><p>[3] Chen R, Davydov E V, Sirota M, et al. Non-Synonymous and Synonymous Coding SNPs Show Similar Likelihood and Effect Size of Human Disease Association[J]. Plos One, 2010, 5(10):e13574. </p><p>[4] Westra H J, Franke L. From genome to function by studying eQTLs.[J]. BBA - Molecular Basis of Disease, 2014, 1842(10):1896-1902. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;snp 是 single-nucleotide polymorphism 的简称，中文为单核苷酸多态性。snp 是如今遗传研究中最热门的一个研究对象，第一是因为他在生物中大量存在，分布广泛。第二他是引起人类（也包含其他生物）疾病的重要原因。&lt;/p&gt;
&lt;p&gt;简单来说，snp 
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
  <entry>
    <title>R 字符串处理</title>
    <link href="http://yoursite.com/2018/10/18/R-stringr/"/>
    <id>http://yoursite.com/2018/10/18/R-stringr/</id>
    <published>2018-10-18T07:51:58.000Z</published>
    <updated>2018-10-19T01:58:40.460Z</updated>
    
    <content type="html"><![CDATA[<p>使用R包stringr进行R语言的字符串处理。</p><h3 id="str-count"><a href="#str-count" class="headerlink" title="str_count()"></a>str_count()</h3><p>计算字符串中字符个数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(stringr)</span><br><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pineapple"</span>)</span><br><span class="line">&gt; str_count(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] 1 3 1 1</span></span><br></pre></td></tr></table></figure><h3 id="str-detect"><a href="#str-detect" class="headerlink" title="str_detect()"></a>str_detect()</h3><p>检查字符是否在字符串中。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pinapple"</span>)</span><br><span class="line">&gt; str_detect(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] TRUE TRUE TRUE TRUE</span></span><br><span class="line">&gt; str_detect(fruit, <span class="string">"^a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1]  TRUE FALSE FALSE FALSE</span></span><br></pre></td></tr></table></figure><h3 id="str-extract"><a href="#str-extract" class="headerlink" title="str_extract()"></a>str_extract()</h3><p>模式匹配。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; shopping_list &lt;- c(<span class="string">"apples x4"</span>, <span class="string">"bag of flour"</span>, <span class="string">"bag of sugar"</span>, <span class="string">"milk x2"</span>)</span><br><span class="line">&gt; str_extract_all(shopping_list, <span class="string">"[a-z]+\\b"</span>, simplify = <span class="literal">TRUE</span>)  <span class="comment">#simplify = TRUE 以矩阵的方式展示结果</span></span><br><span class="line"><span class="comment">#&gt;      [,1]     [,2] [,3]   </span></span><br><span class="line"><span class="comment">#&gt; [1,] "apples" ""   ""     </span></span><br><span class="line"><span class="comment">#&gt; [2,] "bag"    "of" "flour"</span></span><br><span class="line"><span class="comment">#&gt; [3,] "bag"    "of" "sugar"</span></span><br><span class="line"><span class="comment">#&gt; [4,] "milk"   ""   ""     </span></span><br><span class="line">&gt; str_extract(shopping_list, <span class="string">"[a-z]+\\b"</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"apples"</span> <span class="string">"bag"</span>    <span class="string">"bag"</span>    <span class="string">"milk"</span></span><br></pre></td></tr></table></figure><h3 id="str-match"><a href="#str-match" class="headerlink" title="str_match ()"></a>str_match ()</h3><p>模式匹配，进行分组匹配。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple12345679!123"</span>)</span><br><span class="line">&gt; str_match_all(fruit,<span class="string">"([a-z]+).*?(!)"</span>)   <span class="comment">#分2个组，结果第一个为全部匹配的结果</span></span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">     [,<span class="number">1</span>]             [,<span class="number">2</span>]    [,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,] <span class="string">"apple12345679!"</span> <span class="string">"apple"</span> <span class="string">"!"</span></span><br></pre></td></tr></table></figure><h3 id="str-locate"><a href="#str-locate" class="headerlink" title="str_locate()"></a>str_locate()</h3><p>模式匹配位置。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pineapple"</span>) </span><br><span class="line">&gt; str_locate(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt;      start end</span></span><br><span class="line"><span class="comment">#&gt; [1,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [2,]     2   2</span></span><br><span class="line"><span class="comment">#&gt; [3,]     3   3</span></span><br><span class="line"><span class="comment">#&gt; [4,]     5   5</span></span><br><span class="line">&gt; str_locate(fruit, c(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"p"</span>, <span class="string">"p"</span>))</span><br><span class="line"><span class="comment">#&gt;      start end</span></span><br><span class="line"><span class="comment">#&gt; [1,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [2,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [3,]     1   1</span></span><br><span class="line"><span class="comment">#&gt; [4,]     1   1</span></span><br><span class="line">&gt; str_locate_all(fruit, <span class="string">"a"</span>)</span><br><span class="line">[[<span class="number">1</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">2</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">2</span>   <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>,]     <span class="number">4</span>   <span class="number">4</span></span><br><span class="line">[<span class="number">3</span>,]     <span class="number">6</span>   <span class="number">6</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">3</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">3</span>   <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">4</span>]]</span><br><span class="line">     start end</span><br><span class="line">[<span class="number">1</span>,]     <span class="number">5</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="str-subset"><a href="#str-subset" class="headerlink" title="str_subset()"></a>str_subset()</h3><p>功能如 linux下grep。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruit &lt;- c(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"pear"</span>, <span class="string">"pinapple"</span>)</span><br><span class="line">&gt; str_subset(fruit, <span class="string">"a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"    "banana"   "pear"     "pinapple"</span></span><br><span class="line">&gt; str_subset(fruit, <span class="string">"^a"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"</span></span><br><span class="line">&gt; str_subset(fruit, <span class="string">"[aeiou]"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "apple"    "banana"   "pear"     "pinapple"</span></span><br></pre></td></tr></table></figure><h3 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace()"></a>str_replace()</h3><p>替换字符。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruits &lt;- c(<span class="string">"one apple"</span>, <span class="string">"two pears"</span>, <span class="string">"three bananas"</span>)</span><br><span class="line">&gt; str_replace(fruits, <span class="string">"[aeiou]"</span>, <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "-ne apple"     "tw- pears"     "thr-e bananas"</span></span><br><span class="line">&gt; str_replace_all(fruits, <span class="string">"[aeiou]"</span>, <span class="string">"-"</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "-n- -ppl-"     "tw- p--rs"     "thr-- b-n-n-s"</span></span><br></pre></td></tr></table></figure><h3 id="str-split"><a href="#str-split" class="headerlink" title="str_split()"></a>str_split()</h3><p>分割字符串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; fruits &lt;- c(</span><br><span class="line">  <span class="string">"apples and oranges and pears and bananas"</span>,</span><br><span class="line">  <span class="string">"pineapples and mangos and guavas"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>)</span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "apples"  "oranges" "pears"   "bananas" </span></span><br><span class="line"><span class="comment">#&gt; [[2]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "pineapples" "mangos"     "guavas"    </span></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>, simplify = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#&gt;      [,1]         [,2]      [,3]     [,4]     </span></span><br><span class="line"><span class="comment">#&gt; [1,] "apples"     "oranges" "pears"  "bananas"</span></span><br><span class="line"><span class="comment">#&gt; [2,] "pineapples" "mangos"  "guavas" ""     </span></span><br><span class="line">&gt; str_split(fruits, <span class="string">" and "</span>, n = <span class="number">3</span>)</span><br><span class="line"><span class="comment">#&gt; [[1]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "apples"            "oranges"           "pears and bananas" </span></span><br><span class="line"><span class="comment">#&gt; [[2]]</span></span><br><span class="line"><span class="comment">#&gt; [1] "pineapples" "mangos"     "guavas"</span></span><br></pre></td></tr></table></figure><h3 id="str-sort"><a href="#str-sort" class="headerlink" title="str_sort()"></a>str_sort()</h3><p>字符串排序。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; letter&lt;-c(<span class="string">'an apple'</span>,<span class="string">'two oranges'</span>,<span class="string">'three bananas'</span>,<span class="string">'four tomatoes'</span>)</span><br><span class="line">&gt; str_sort(letter)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"an apple"</span>      <span class="string">"four tomatoes"</span> <span class="string">"three bananas"</span> <span class="string">"two oranges"</span></span><br><span class="line">&gt; str_sort(letter,decreasing = <span class="literal">TRUE</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"two oranges"</span>   <span class="string">"three bananas"</span> <span class="string">"four tomatoes"</span> <span class="string">"an apple"</span></span><br><span class="line">x &lt;- c(<span class="string">"100a10"</span>, <span class="string">"100a5"</span>, <span class="string">"2b"</span>, <span class="string">"2a"</span>)</span><br><span class="line">str_sort(x)</span><br><span class="line"><span class="comment">#&gt; [1] "100a10" "100a5"  "2a"     "2b"    </span></span><br><span class="line">str_sort(x, numeric = <span class="literal">TRUE</span>)</span><br><span class="line"><span class="comment">#&gt; [1] "2a"     "2b"     "100a5"  "100a10"</span></span><br></pre></td></tr></table></figure><h3 id="str-to-upper-str-to-lower-str-to-title"><a href="#str-to-upper-str-to-lower-str-to-title" class="headerlink" title="str_to_upper()    str_to_lower()     str_to_title()"></a>str_to_upper()    str_to_lower()     str_to_title()</h3><p>改变字符大小写。</p><h3 id="str-length"><a href="#str-length" class="headerlink" title="str_length()"></a>str_length()</h3><p>字符串长度。</p><h3 id="str-c"><a href="#str-c" class="headerlink" title="str_c()"></a>str_c()</h3><p>拼接字符串。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str_c(<span class="string">'I have'</span>,letter,sep = <span class="string">' '</span>)  <span class="comment">#单字符串加字符</span></span><br><span class="line">[<span class="number">1</span>] <span class="string">"I have an apple"</span>      <span class="string">"I have two oranges"</span>   <span class="string">"I have three bananas"</span> <span class="string">"I have four tomatoes"</span></span><br><span class="line">&gt; str_c(letter,collapse = <span class="string">','</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"an apple,two oranges,three bananas,four tomatoes"</span>  <span class="comment">#拼接所有字符串</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用R包stringr进行R语言的字符串处理。&lt;/p&gt;
&lt;h3 id=&quot;str-count&quot;&gt;&lt;a href=&quot;#str-count&quot; class=&quot;headerlink&quot; title=&quot;str_count()&quot;&gt;&lt;/a&gt;str_count()&lt;/h3&gt;&lt;p&gt;计算字符串中字
      
    
    </summary>
    
      <category term="R" scheme="http://yoursite.com/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R 数据处理</title>
    <link href="http://yoursite.com/2018/10/02/R-data-progress/"/>
    <id>http://yoursite.com/2018/10/02/R-data-progress/</id>
    <published>2018-10-02T03:17:40.000Z</published>
    <updated>2018-10-02T05:49:16.347Z</updated>
    
    <content type="html"><![CDATA[<p>本节函数都来自于dplyr包，都可以和<code>group_by</code>函数联合起来处理复杂的数据。</p><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p><code>filter()</code>函数用来根据列的具体数据选择行。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(dplyr)</span><br><span class="line">&gt; names(mpg)</span><br><span class="line">  <span class="string">"manufacturer"</span> <span class="string">"model"</span> <span class="string">"displ"</span> <span class="string">"year"</span> <span class="string">"cyl"</span> <span class="string">"trans"</span> <span class="string">"drv"</span> <span class="string">"cty"</span> <span class="string">"hwy"</span> <span class="string">"fl"</span> <span class="string">"class"</span></span><br><span class="line">&gt; filter(mpg,year==<span class="number">1999</span>)  <span class="comment">#选择year==1999的数据</span></span><br><span class="line"><span class="comment"># A tibble: 117 x 11</span></span><br><span class="line">   manufacturer model              displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> audi         a4                  <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact</span><br><span class="line"> <span class="number">2</span> audi         a4                  <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact</span><br><span class="line"> <span class="number">3</span> audi         a4                  <span class="number">2.80</span>  <span class="number">1999</span>     <span class="number">6</span> auto(l5)   f        <span class="number">16</span>    <span class="number">26</span> p     compact</span><br><span class="line">&gt; filter(mpg,year==<span class="number">1999</span>,displ&gt;<span class="number">5</span>)  <span class="comment">#选择year==1999且displ&gt;5的数据</span></span><br><span class="line"><span class="comment"># A tibble: 16 x 11</span></span><br><span class="line">   manufacturer model               displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;               &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> chevrolet    c1500 suburban 2wd   <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   r        <span class="number">13</span>    <span class="number">17</span> r     suv    </span><br><span class="line"> <span class="number">2</span> chevrolet    corvette             <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> manual(m6) r        <span class="number">16</span>    <span class="number">26</span> p     2seater</span><br><span class="line"> <span class="number">3</span> chevrolet    corvette             <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   r        <span class="number">15</span>    <span class="number">23</span> p     2seater</span><br><span class="line"> <span class="number">4</span> chevrolet    k1500 tahoe 4wd      <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv    </span><br><span class="line"> <span class="number">5</span> chevrolet    k1500 tahoe 4wd      <span class="number">6.50</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4)   <span class="number">4</span>        <span class="number">14</span>    <span class="number">17</span> d     suv</span><br></pre></td></tr></table></figure><h2 id="arrange"><a href="#arrange" class="headerlink" title="arrange"></a>arrange</h2><p><code>arrange()</code>函数用来排列行的顺序。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; arrange(mpg,year,cty, hwy)  <span class="comment">#根据year,cty, hwy进行行排序</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 11</span></span><br><span class="line">   manufacturer model                  displ  year   cyl trans    drv     cty   hwy fl    class </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;                  &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; </span><br><span class="line"> <span class="number">1</span> chevrolet    k1500 tahoe 4wd         <span class="number">5.70</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv   </span><br><span class="line"> <span class="number">2</span> dodge        dakota pickup 4wd       <span class="number">5.20</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     pickup</span><br><span class="line"> <span class="number">3</span> dodge        durango 4wd             <span class="number">5.90</span>  <span class="number">1999</span>     <span class="number">8</span> auto(l4) <span class="number">4</span>        <span class="number">11</span>    <span class="number">15</span> r     suv </span><br><span class="line">&gt; arrange(mpg,year,cty, hwy)  <span class="comment">#根据year,cty, hwy进行行排序</span></span><br><span class="line">&gt; arrange(mpg,desc(year))   <span class="comment">#根据year进行行降序排序</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 11</span></span><br><span class="line">   manufacturer model              displ  year   cyl trans      drv     cty   hwy fl    class  </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;              &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  </span><br><span class="line"> <span class="number">1</span> audi         a4                  <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact</span><br><span class="line"> <span class="number">2</span> audi         a4                  <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> auto(av)   f        <span class="number">21</span>    <span class="number">30</span> p     compact</span><br><span class="line"> <span class="number">3</span> audi         a4                  <span class="number">3.10</span>  <span class="number">2008</span>     <span class="number">6</span> auto(av)   f        <span class="number">18</span>    <span class="number">27</span> p     compact</span><br><span class="line"> <span class="number">4</span> audi         a4 quattro          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) <span class="number">4</span>        <span class="number">20</span>    <span class="number">28</span> p     compact</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p><code>select()</code>函数用来选择列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; select(mpg,year,cty, hwy)  <span class="comment">#只显示year,cty, hwy三列</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 3</span></span><br><span class="line">    year   cty   hwy</span><br><span class="line">   &lt;int&gt; &lt;int&gt; &lt;int&gt;</span><br><span class="line"> <span class="number">1</span>  <span class="number">1999</span>    <span class="number">18</span>    <span class="number">29</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1999</span>    <span class="number">21</span>    <span class="number">29</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">2008</span>    <span class="number">20</span>    <span class="number">31</span></span><br></pre></td></tr></table></figure><p><code>select()</code>函数的辅助函数：</p><ul><li><code>start_with(&quot;abc&quot;)</code> ：匹配以 “abc” 开头的变量名。</li><li><code>ends_with(&quot;xyz&quot;)</code> ：以 “xyz” 结尾。</li><li><code>contains(&quot;ijk&quot;)</code> ：包含 “ijk”。</li><li><code>match(&quot;(.)\\\1&quot;)</code> ：正则匹配重复字符。</li><li><code>num_range(&quot;x&quot;,1:3)</code> ：匹配x1，x2和x3。</li></ul><h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p><code>rename()</code>用来改变变量名。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; rename(mpg,YEAR=year)  <span class="comment">#将year重命名YEAR</span></span><br></pre></td></tr></table></figure><h2 id="mutate"><a href="#mutate" class="headerlink" title="mutate"></a>mutate</h2><p><code>mutate()</code>函数用来对数据进行增加新列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; mutate(mpg,cty2=cty*<span class="number">2</span>)  <span class="comment">#数值型</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 12</span></span><br><span class="line">   manufacturer model      displ  year   cyl trans      drv     cty   hwy fl    class    cty2</span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt;</span><br><span class="line"> <span class="number">1</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact   <span class="number">36.</span></span><br><span class="line"> <span class="number">2</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact   <span class="number">42.</span></span><br><span class="line"> <span class="number">3</span> audi         a4          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact   <span class="number">40.</span></span><br><span class="line">&gt; mutate(mpg,cty2=paste(drv,cty,sep = <span class="string">""</span>))  <span class="comment">#字符型</span></span><br><span class="line"><span class="comment"># A tibble: 234 x 12</span></span><br><span class="line">   manufacturer model      displ  year   cyl trans      drv     cty   hwy fl    class   cty2 </span><br><span class="line">   &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;      &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;</span><br><span class="line"> <span class="number">1</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> auto(l5)   f        <span class="number">18</span>    <span class="number">29</span> p     compact f18  </span><br><span class="line"> <span class="number">2</span> audi         a4          <span class="number">1.80</span>  <span class="number">1999</span>     <span class="number">4</span> manual(m5) f        <span class="number">21</span>    <span class="number">29</span> p     compact f21  </span><br><span class="line"> <span class="number">3</span> audi         a4          <span class="number">2.00</span>  <span class="number">2008</span>     <span class="number">4</span> manual(m6) f        <span class="number">20</span>    <span class="number">31</span> p     compact f20</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本节函数都来自于dplyr包，都可以和&lt;code&gt;group_by&lt;/code&gt;函数联合起来处理复杂的数据。&lt;/p&gt;
&lt;h2 id=&quot;filter&quot;&gt;&lt;a href=&quot;#filter&quot; class=&quot;headerlink&quot; title=&quot;filter&quot;&gt;&lt;/a&gt;filter
      
    
    </summary>
    
      <category term="R" scheme="http://yoursite.com/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R 分面</title>
    <link href="http://yoursite.com/2018/10/02/R-facet/"/>
    <id>http://yoursite.com/2018/10/02/R-facet/</id>
    <published>2018-10-02T02:35:43.000Z</published>
    <updated>2018-10-02T02:48:02.079Z</updated>
    
    <content type="html"><![CDATA[<p>有时候会有需求需要把一个数据框的数据作图，再按照不同的分类将图形分开绘制。或者，只是需要把2个或者多个图简单地放在一个画布上，R图的分面将会作用与此。</p><h2 id="facet-grid"><a href="#facet-grid" class="headerlink" title="facet_grid"></a>facet_grid</h2><p>ggplot2的<code>facet_grid()</code>函数按分类条件将图形在行或者列上分面绘图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mpg, aes(displ, cty)) + geom_point()</span><br><span class="line">&gt; p + facet_grid(rows = vars(drv))  <span class="comment">#按行分面</span></span><br><span class="line">&gt; p + facet_grid(cols = vars(cyl))  <span class="comment">#按列分面</span></span><br><span class="line">&gt; p + facet_grid(vars(drv), vars(cyl))  <span class="comment">#使用2个变量同时在行列分面</span></span><br><span class="line"></span><br><span class="line">&gt; mt &lt;- ggplot(mtcars, aes(mpg, wt, colour = factor(cyl))) +geom_point()  <span class="comment">#按cyl填充颜色</span></span><br><span class="line">&gt; mt + facet_grid(cols = vars(cyl), scales = <span class="string">"free"</span>)  <span class="comment">#scales = "free"刻度在在分面上可自适应</span></span><br></pre></td></tr></table></figure><h2 id="facet-wrap"><a href="#facet-wrap" class="headerlink" title="facet_wrap"></a>facet_wrap</h2><p>ggplot2的<code>facet_wrap()</code>函数按分类条件将图形2d(默认n x n)形式的铺在画布上。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; p &lt;- ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p + facet_wrap(vars(class))  <span class="comment">#按class分面</span></span><br><span class="line">&gt; p + facet_wrap(vars(class), nrow = <span class="number">4</span>)  <span class="comment">#强制分为4行</span></span><br><span class="line">&gt; p + facet_wrap(vars(class), ncol = <span class="number">4</span>)  <span class="comment">#强制分为4列</span></span><br><span class="line">&gt; p + facet_wrap(vars(cyl, drv))  <span class="comment">#使用2个变量进行分类</span></span><br><span class="line">&gt; p + facet_wrap(c(<span class="string">"cyl"</span>, <span class="string">"drv"</span>), labeller = <span class="string">"label_both"</span>)  <span class="comment">#友好的显示分类变量名</span></span><br></pre></td></tr></table></figure><h2 id="grid-arrange"><a href="#grid-arrange" class="headerlink" title="grid.arrange"></a>grid.arrange</h2><p><code>grid.arrange()</code>是gridExtra包的一个函数，可以将多个图放入一个画布中。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">"gridExtra"</span>)</span><br><span class="line">&gt; <span class="keyword">library</span>(gridExtra)</span><br><span class="line">&gt; p1&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p2&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; p3&lt;-ggplot(mpg, aes(displ, hwy)) + geom_point()</span><br><span class="line">&gt; grid.arrange(p1,p2,p3, nrow=<span class="number">2</span>)  <span class="comment">#设定为2行图形</span></span><br><span class="line">&gt; grid.arrange(p1,p2,p3, nrow=<span class="number">2</span>,top = textGrob(<span class="string">"xxx"</span>,gp=gpar(col=<span class="string">"red"</span>,fontsize=<span class="number">20</span>，font=<span class="number">2</span>)))</span><br><span class="line">  <span class="comment">#设置总标题，并修改颜色大小，字体</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候会有需求需要把一个数据框的数据作图，再按照不同的分类将图形分开绘制。或者，只是需要把2个或者多个图简单地放在一个画布上，R图的分面将会作用与此。&lt;/p&gt;
&lt;h2 id=&quot;facet-grid&quot;&gt;&lt;a href=&quot;#facet-grid&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="R" scheme="http://yoursite.com/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R 回归分析</title>
    <link href="http://yoursite.com/2018/09/29/R-regression-analysis/"/>
    <id>http://yoursite.com/2018/09/29/R-regression-analysis/</id>
    <published>2018-09-29T09:21:36.000Z</published>
    <updated>2018-09-30T03:23:37.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h2><p>逐步回归分析是以AIC信息统计量为准则，通过选择最小的AIC信息统计量，来达到删除或增加变量的目的。</p><p>AIC : 赤池信息准则(Akaike Information Criterion) ,k是模型中估计参数的数量。L是模型的似然函数的最大值。</p><p><img src="/2018/09/29/R-regression-analysis/AIC.svg" alt=""></p><p>AICc：当样本量很小时，AIC很可能会选择具有太多参数的模型，即AIC会过度拟合。为了解决这种潜在的过度拟合问题，AICc可以对小样本进行校正。其中<em>n</em>表示样本大小，<em>k</em>表示参数的数量。 </p><p><img src="/2018/09/29/R-regression-analysis/Akaike Information Criterion.svg" alt=""></p><h3 id="向前逐步回归"><a href="#向前逐步回归" class="headerlink" title="向前逐步回归"></a>向前逐步回归</h3><p>首先模型中只有一个单独解释因变量变异最大的自变量，之后尝试将加入另一自变量，看加入后整个模型所能解释的因变量变异是否显著增加（这里需要进行检验，可以用 F-test， t-test 等等）。这一过程反复迭代，直到没有自变量再符合加入模型的条件。 </p><p>MASS包中的<code>stepAIC()</code>函数给予AIC准则实现了逐步回归模型（向前、向后和双向）。 </p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"forward"</span>)</span><br></pre></td></tr></table></figure><h3 id="向后逐步回归"><a href="#向后逐步回归" class="headerlink" title="向后逐步回归"></a>向后逐步回归</h3><p>向后逐步回归与向前逐步回归相反，此时，所有变量均放入模型，之后尝试将其中一个自变量从模型中剔除，看整个模型解释因变量的变异是否有显著变化，之后将使解释量减少最少的变量剔除；此过程不断迭代，直到没有自变量符合剔除的条件。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"backward"</span>)</span><br></pre></td></tr></table></figure><h3 id="向前向后逐步回归"><a href="#向前向后逐步回归" class="headerlink" title="向前向后逐步回归"></a>向前向后逐步回归</h3><p>向前向后逐步回归，这种方法相当于将前两种结合起来。可以想象，如果采用第一种方法，每加入一个自变量，可能会使已存在于模型中的变量单独对因变量的解释度减小，当其的作用很小（不显著）时，则可将其从模型中剔除。而第三种方法就做了这么一件事，不是一味的增加变量，而是增加一个后，对整个模型中的所有变量进行检验，剔除作用不显著的变量。最终尽可能得到一个最优的变量组合。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(MASS)</span><br><span class="line">&gt; fit &lt;- lm(xx ~ x+y+z,data=datas)</span><br><span class="line">&gt; stepAIC(fit, direction=<span class="string">"both"</span>)</span><br></pre></td></tr></table></figure><p>Forward、Backward、Stepwise的侧重点有所不同，三种方法的选择取决于你的研究目的，如果是进行预测，在预测效果差不多的情况下，一般选择自变量最少的方法。当自变量间不存在多重共线性时，三种方法的计算结果基本一致。当自变量间存在多重共线性时，Forward侧重于引入单独作用较强的变量，Backward侧重于引入联合作用较强的变量，Stepwise介于两者之间。</p><h2 id="全子集回归"><a href="#全子集回归" class="headerlink" title="全子集回归"></a>全子集回归</h2><p>全子集回归克服了逐步回归的缺点，即所有可能的模型都会被检验，评判准则可以是R平方、修正R平方、BIC或者Mallows Cp统计量。 </p><p>R平方：</p><p><img src="/2018/09/29/R-regression-analysis/r2.svg" alt=""></p><p>修正R平方 : </p><p>我们知道在其他变量不变的情况下，引入新的变量，总能提高模型的R2。修正R2就是相当于给变量的个数加惩罚项。换句话说，如果两个模型，样本数一样，R2一样，那么从修正R2的角度看，使用变量个数少的那个模型更优。其中n是样本数量，p是模型中变量的个数。 当p/n值很小时，如小于0.05，修正R平方将失去修正作用。</p><p><img src="/2018/09/29/R-regression-analysis/adjr2.svg" alt=""></p><p>BIC：贝叶斯信息准则 ，BIC的惩罚项比AIC的大，考虑了样本数量，样本数量过多时，可有效防止模型精度过高造成的模型复杂度过高。 </p><p><img src="/2018/09/29/R-regression-analysis/BIC" alt=""></p><p>Mallows Cp：马洛斯的Cp值 与AIC等效。</p><p>以下为R中<code>ISLR</code>包的<code>Hitters</code>数据集为例，构建棒球运动员的多元线性模型 。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(ISLR)</span><br><span class="line">&gt; <span class="keyword">library</span>(leaps)  <span class="comment">#使用leaps做全子集回归</span></span><br><span class="line">&gt; Hitters &lt;- na.omit(Hitters)</span><br><span class="line">&gt; dim(Hitters)  <span class="comment">#除去Salary做为因变量，还剩下19个特征</span></span><br><span class="line">[<span class="number">1</span>] <span class="number">263</span>  <span class="number">20</span></span><br><span class="line">&gt; regfit.full = regsubsets(Salary~.,Hitters,nvmax = <span class="number">19</span>)  <span class="comment">#选择最大19个特征的全子集选择模型</span></span><br><span class="line">&gt; reg.summary = summary(regfit.full) <span class="comment"># 可看到不同数量下的特征选择</span></span><br><span class="line">&gt; plot(reg.summary$adjr2,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"Adjusted R2"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.max(reg.summary$adjr2),reg.summary$adjr2[<span class="number">11</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>)  <span class="comment">#11个特征时，Adjusted R2最大</span></span><br><span class="line"></span><br><span class="line">&gt; plot(reg.summary$cp,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"Cp"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.min(reg.summary$cp),reg.summary$cp[<span class="number">10</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>) <span class="comment"># 10个特征时，Cp最小</span></span><br><span class="line"></span><br><span class="line">&gt; plot(reg.summary$bic,xlab=<span class="string">"Number of Variables"</span>,ylab=<span class="string">"BIC"</span>,type = <span class="string">"l"</span>)</span><br><span class="line">&gt; points(which.min(reg.summary$bic),reg.summary$bic[<span class="number">6</span>],col=<span class="string">"red"</span>,cex=<span class="number">2</span>,pch=<span class="number">20</span>) <span class="comment"># 6个特征时，BIC最小</span></span><br><span class="line"></span><br><span class="line">&gt; plot(regfit.full,scale = <span class="string">"r2"</span>) <span class="comment">#特征越多，R2越大，这不意外，默认scale是bic。</span></span><br><span class="line">&gt; plot(regfit.full,scale = <span class="string">"adjr2"</span>)  <span class="comment">#下图</span></span><br><span class="line">&gt; coef(regfit.full,<span class="number">11</span>)  <span class="comment">#查看模型的系数</span></span><br><span class="line"> (Intercept)        AtBat         Hits        Walks       CAtBat </span><br><span class="line"> <span class="number">135.7512195</span>   -<span class="number">2.1277482</span>    <span class="number">6.9236994</span>    <span class="number">5.6202755</span>   -<span class="number">0.1389914</span> </span><br><span class="line">       CRuns         CRBI       CWalks      LeagueN    DivisionW </span><br><span class="line">   <span class="number">1.4553310</span>    <span class="number">0.7852528</span>   -<span class="number">0.8228559</span>   <span class="number">43.1116152</span> -<span class="number">111.1460252</span> </span><br><span class="line">     PutOuts      Assists </span><br><span class="line">   <span class="number">0.2894087</span>    <span class="number">0.2688277</span></span><br></pre></td></tr></table></figure><p><img src="/2018/09/29/R-regression-analysis/adjr2_plot2.png" alt=""></p><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><p>交叉验证是在机器学习建立模型和验证模型参数时常用的办法，一般被用于评估一个机器学习模型的表现。更多的情况下，也用交叉验证来进行模型选择(model selection)。 </p><p>k重交叉验证中，样本被分为k个子样本，轮流将k-1个子样本组合作为训练集，另外1个子样本作为测试集，这样会获得k个预测方程，记录k个测试样本的预测表现结果，然后求其平均值。测试集的目的简单来说就相当于一个游戏的内测，内部评估。进行交叉验证后得到了分数来评估你建模的准确率是高是低。最后的目的是为了哪天来了新的数据，你也可以用你的模型去预测他，相当于游戏公测。 </p><p>bootstrap包中的<code>crossval()</code> 函数可实现k重交叉验证 ：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; install.packages(<span class="string">"bootstrap"</span>)  </span><br><span class="line">&gt; <span class="keyword">library</span>(bootstrap)  </span><br><span class="line">&gt; shrinkage&lt;-<span class="keyword">function</span>(fit,k=<span class="number">10</span>)&#123;  </span><br><span class="line">  <span class="keyword">require</span>(bootstrap)  </span><br><span class="line">  theta.fit&lt;-<span class="keyword">function</span>(x,y)&#123;lsfit(x,y)&#125;  </span><br><span class="line">  theta.predict&lt;-<span class="keyword">function</span>(fit,x)&#123;cbind(<span class="number">1</span>,x)%*%fit$coef&#125;  </span><br><span class="line">  x&lt;-fit$model[,<span class="number">2</span>:ncol(fit$model)]  </span><br><span class="line">  y&lt;-fit$model[,<span class="number">1</span>]  </span><br><span class="line">  results&lt;-crossval(x,y,theta.fit,theta.predict,ngroup=k)  </span><br><span class="line">  r2&lt;-cor(y,fit$fitted.values)^<span class="number">2</span>  </span><br><span class="line">  r2cv&lt;-cor(y,results$cv.fit)^<span class="number">2</span>  </span><br><span class="line">  cat(<span class="string">"Original R-square="</span>,r2,<span class="string">"n"</span>)  </span><br><span class="line">  cat(k,<span class="string">"Fold Cross-Validated R-square="</span>,r2cv,<span class="string">"n"</span>)  </span><br><span class="line">  cat(<span class="string">"Change="</span>,r2-r2cv,<span class="string">"n"</span>)  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">&gt; fit&lt;-lm(Murder ~ Population+Income+Illiteracy+Frost,data=states)  </span><br><span class="line">&gt; shrinkage(fit)  </span><br><span class="line">&gt; fit2&lt;-lm(Murder ~ Population+Illiteracy,data=states)  </span><br><span class="line">&gt; shrinkage(fit2)  </span><br><span class="line">Original R-square=<span class="number">0.5668327</span></span><br><span class="line"><span class="number">10</span> Fold Cross-Validated R-square=<span class="number">0.5193801</span></span><br><span class="line">Change=<span class="number">0.04745256</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逐步回归&quot;&gt;&lt;a href=&quot;#逐步回归&quot; class=&quot;headerlink&quot; title=&quot;逐步回归&quot;&gt;&lt;/a&gt;逐步回归&lt;/h2&gt;&lt;p&gt;逐步回归分析是以AIC信息统计量为准则，通过选择最小的AIC信息统计量，来达到删除或增加变量的目的。&lt;/p&gt;
&lt;p&gt;AIC 
      
    
    </summary>
    
      <category term="R" scheme="http://yoursite.com/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>R 数据预处理</title>
    <link href="http://yoursite.com/2018/09/28/deal-with-r-data/"/>
    <id>http://yoursite.com/2018/09/28/deal-with-r-data/</id>
    <published>2018-09-28T08:34:57.000Z</published>
    <updated>2018-10-16T07:44:22.531Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将若干向量组合为数据框"><a href="#将若干向量组合为数据框" class="headerlink" title="将若干向量组合为数据框"></a>将若干向量组合为数据框</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; g &lt;- c(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>)</span><br><span class="line">&gt; x &lt;- <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">&gt; data &lt;- data.frame(g,x)</span><br><span class="line">&gt; data</span><br><span class="line">  g x</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="从数据框中提取摘要信息"><a href="#从数据框中提取摘要信息" class="headerlink" title="从数据框中提取摘要信息"></a>从数据框中提取摘要信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str(data)</span><br><span class="line"><span class="string">'data.frame'</span>:<span class="number">3</span> obs. of  <span class="number">2</span> variables:</span><br><span class="line"> $ g: Factor w/ <span class="number">3</span> levels <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"> $ x: int  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="向数据框添加列"><a href="#向数据框添加列" class="headerlink" title="向数据框添加列"></a>向数据框添加列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data$new &lt;- data$x * <span class="number">2</span></span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="从数据框删除列"><a href="#从数据框删除列" class="headerlink" title="从数据框删除列"></a>从数据框删除列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data &lt;- subset(data,select = c(-x,-new))</span><br><span class="line">  g</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure><h3 id="重排序列"><a href="#重排序列" class="headerlink" title="重排序列"></a>重排序列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data2 &lt;-data[c(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)]</span><br><span class="line">  g new x</span><br><span class="line"><span class="number">1</span> a   <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b   <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c   <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="选取某几列"><a href="#选取某几列" class="headerlink" title="选取某几列"></a>选取某几列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data3 &lt;-data[c(<span class="string">"x"</span>,<span class="string">"new"</span>)]</span><br><span class="line">  x new</span><br><span class="line"><span class="number">1</span> <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="选取某几行"><a href="#选取某几行" class="headerlink" title="选取某几行"></a>选取某几行</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; data3 &lt;-data[c(<span class="number">1</span>,<span class="number">2</span>),]</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>  unite <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="连续变量转换为分类变量"><a href="#连续变量转换为分类变量" class="headerlink" title="连续变量转换为分类变量"></a>连续变量转换为分类变量</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; data$class &lt;- cut(data$new,breaks=c(<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="literal">Inf</span>))</span><br><span class="line">  g x new class</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span> (<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span> (<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span> (<span class="number">4</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="宽数据《-》长数据"><a href="#宽数据《-》长数据" class="headerlink" title="宽数据《=》长数据"></a>宽数据《=》长数据</h3><p>长数据有一列数据是变量的类型，有一列是变量的值，但不一定只有两列。<code>ggplot2</code>需要长类型的数据，<code>dplyr</code>也需要长类型的数据，大多数的模型(比如<code>lm()</code>, <code>glm()</code>以及<code>gam()</code>)也需要长数据。 </p><p>使用<code>tidyr</code> 包的<code>gather()</code>函数转换到长数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">library</span>(tidyr)</span><br><span class="line">&gt; data</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">&gt; data2&lt;-gather(data,key=<span class="string">'new_one'</span>,value =<span class="string">'count'</span>,x,new,-g)</span><br><span class="line">&gt; data2</span><br><span class="line">  g new_one count</span><br><span class="line"><span class="number">1</span> a       x     <span class="number">1</span></span><br><span class="line"><span class="number">2</span> b       x     <span class="number">2</span></span><br><span class="line"><span class="number">3</span> c       x     <span class="number">3</span></span><br><span class="line"><span class="number">4</span> a     new     <span class="number">2</span></span><br><span class="line"><span class="number">5</span> b     new     <span class="number">4</span></span><br><span class="line"><span class="number">6</span> c     new     <span class="number">6</span></span><br></pre></td></tr></table></figure><p>使用<code>tidyr</code> 包的<code>spread()</code>函数转换到宽数据：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; spread(data2,key=<span class="string">'new_one'</span>,value=<span class="string">'count'</span>)</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="多列《-》一列"><a href="#多列《-》一列" class="headerlink" title="多列《=》一列"></a>多列《=》一列</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; data</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br><span class="line">&gt; data3&lt;-unite(data,x_new,x,new,sep = <span class="string">'_'</span>)</span><br><span class="line">&gt; data3</span><br><span class="line">  g x_new</span><br><span class="line"><span class="number">1</span> a   1_<span class="number">2</span></span><br><span class="line"><span class="number">2</span> b   2_<span class="number">4</span></span><br><span class="line"><span class="number">3</span> c   3_<span class="number">6</span></span><br><span class="line"></span><br><span class="line">&gt; data4&lt;- separate(data3,x_new,c(<span class="string">'x'</span>,<span class="string">'new'</span>),sep = <span class="string">'_'</span>)</span><br><span class="line">&gt; data4</span><br><span class="line">  g x new</span><br><span class="line"><span class="number">1</span> a <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">2</span> b <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"><span class="number">3</span> c <span class="number">3</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;将若干向量组合为数据框&quot;&gt;&lt;a href=&quot;#将若干向量组合为数据框&quot; class=&quot;headerlink&quot; title=&quot;将若干向量组合为数据框&quot;&gt;&lt;/a&gt;将若干向量组合为数据框&lt;/h3&gt;&lt;figure class=&quot;highlight r&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="R" scheme="http://yoursite.com/categories/R/"/>
    
    
  </entry>
  
  <entry>
    <title>python Type Hint</title>
    <link href="http://yoursite.com/2018/09/19/python-Type-Hint/"/>
    <id>http://yoursite.com/2018/09/19/python-Type-Hint/</id>
    <published>2018-09-19T07:23:50.000Z</published>
    <updated>2018-09-19T08:53:39.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    在C语言中每使用一个变量前要先将其声明，如 <code>int a =1</code>,<code>float b =3.14</code>。这么做的好处有2个，一是在之后代码中无需“猜测”变量到底是什么类型，声明是什么就是什么，这就是静态变量。二是少了“猜测”这一步，代码执行效率会有所提升。python默认所有的变量都是动态的，所以你无需提前声明类型，写出了一个变量a，赋值给他一个常数、列表、字典等等都可以。当然动态所带来的问题就是，在代码执行的时候需要去“猜测”变量的类型，从而降低了运行效率。</p><p>​    在python3.5及之后版本，python加入了模块typing，它允许在你命名变量的时候设定它的类型，抽象出来它长这个样子：<code>variable : type</code>，在设定一个变量类型为常量（int）之后并不会影响你给他赋值为字符串（str），这种类型设定如名字一样是类型暗示（Type Hint），而不是决定。</p><p>​    有一个名为mypy的包可以显式的帮你找出你在类型上的问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install mypy</span><br><span class="line">$ mypy program.py</span><br></pre></td></tr></table></figure><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可供使用的类型：</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>int</code></td><td>integer</td></tr><tr><td><code>float</code></td><td>floating point number</td></tr><tr><td><code>bool</code></td><td>boolean value</td></tr><tr><td><code>str</code></td><td>string (unicode)</td></tr><tr><td><code>bytes</code></td><td>8-bit string</td></tr><tr><td><code>object</code></td><td>an arbitrary object (<code>object</code> is the common base class)</td></tr><tr><td><code>List[str]</code></td><td>list of <code>str</code> objects</td></tr><tr><td><code>Tuple[int, int]</code></td><td>tuple of two <code>int</code> objects (<code>Tuple[()]</code> is the empty tuple)</td></tr><tr><td><code>Tuple[int, ...]</code></td><td>tuple of an arbitrary number of <code>int</code> objects</td></tr><tr><td><code>Dict[str, int]</code></td><td>dictionary from <code>str</code> keys to <code>int</code> values</td></tr><tr><td><code>Iterable[int]</code></td><td>iterable object containing ints</td></tr><tr><td><code>Sequence[bool]</code></td><td>sequence of booleans (read-only)</td></tr><tr><td><code>Mapping[str, int]</code></td><td>mapping from <code>str</code> keys to <code>int</code> values (read-only)</td></tr><tr><td><code>Any</code></td><td>dynamically typed value with an arbitrary type</td></tr><tr><td><code>Union[T1, ..., Tn]</code></td><td><code>Union[int, str]</code>both integers and strings are valid argument values.</td></tr></tbody></table><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Set, Dict, Tuple, Optional, Union, Any</span><br><span class="line">x: int = <span class="number">1</span></span><br><span class="line">x: float = <span class="number">1.0</span></span><br><span class="line">x: bool = <span class="keyword">True</span></span><br><span class="line">x: str = <span class="string">"test"</span></span><br><span class="line">x: bytes = <span class="string">b"test"</span></span><br><span class="line">x: List[int] = [<span class="number">1</span>]</span><br><span class="line">x: Set[int] = &#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">x: Dict[str, float] = &#123;<span class="string">'field'</span>: <span class="number">2.0</span>&#125;</span><br><span class="line">x: Tuple[int, str, float] = (<span class="number">3</span>, <span class="string">"yes"</span>, <span class="number">7.5</span>)</span><br><span class="line">x: List[Union[int, str]] = [<span class="number">3</span>, <span class="number">5</span>, <span class="string">"test"</span>, <span class="string">"fun"</span>]</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(num1: int, num2: float)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">return</span> num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: Union[int, str])</span> -&gt; Any:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(x, int):</span><br><span class="line">        <span class="comment"># Here type of x is int.</span></span><br><span class="line">        <span class="keyword">return</span> (x + <span class="number">1</span>)      <span class="comment"># OK</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># Here type of x is str.</span></span><br><span class="line">       <span class="keyword">return</span> (x + <span class="string">'a'</span>)    <span class="comment"># OK</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list)</span>:</span> <span class="comment">#定义一个方法，不做类型设定</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join(<span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'h, e, l, l, o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join([<span class="string">'hello'</span>,<span class="string">'world'</span>])</span><br><span class="line"><span class="string">'hello, world'</span></span><br></pre></td></tr></table></figure><p>对于这个函数，期望的结果就是会把[‘hello’, ‘world’]变成’hello, world’。 但是如果不小心没有传list而是传了一个字符串’hello’，这段代码也不会报错，只是会返回’h, e, l, l, o’这个并不期望的结果。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"><span class="comment">#string_list 局部变量名， List[str] 局部变量类型， str 返回结果类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join(<span class="string">'hello'</span>)<span class="comment">#虽然不期待，但是仍可以运行</span></span><br><span class="line"><span class="string">'h, e, l, l, o'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join([<span class="string">'hello'</span>,<span class="string">'world'</span>])</span><br><span class="line"><span class="string">'hello, world'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>join.__annotations__</span><br><span class="line">&#123;<span class="string">'string_list'</span>: typing.List[str], <span class="string">'return'</span>: &lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>这样声明函数有一个好处，就是不需要在注释里面说明变量类型，更加直观。Python把这种类型的声明看成是一种对函数的注解(annotation)，而注解本身并不具有任何的意义，也不影响运行的过程。与没有注解的版本差别就是多了一个<strong>annotations</strong>的字段 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(string_list: List[str])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">', '</span>.join(string_list)</span><br><span class="line"></span><br><span class="line">print(join(<span class="string">'hello'</span>))</span><br></pre></td></tr></table></figure><p>运行以及使用mypy检查，代码可以运行，mypy也可以给出提示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 test_mypy.py</span><br><span class="line">h, e, l, l, o</span><br><span class="line">$ mypy test_mypy.py</span><br><span class="line">test_mypy.py:<span class="number">6</span>: error: Argument <span class="number">1</span> to <span class="string">"join"</span> has incompatible type <span class="string">"str"</span>; expected List[str]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;​    在C语言中每使用一个变量前要先将其声明，如 &lt;code&gt;int a =1&lt;/code&gt;,&lt;code&gt;float b =3.14&lt;/
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>pandas和R中的groupby</title>
    <link href="http://yoursite.com/2018/09/18/groupby-in-Python-and-R/"/>
    <id>http://yoursite.com/2018/09/18/groupby-in-Python-and-R/</id>
    <published>2018-09-18T07:16:29.000Z</published>
    <updated>2018-09-19T08:56:06.035Z</updated>
    
    <content type="html"><![CDATA[<p>groupby 可以根据一个数据框的部分数据，将整个数据框进行分组，简称：聚合。聚合之后，可以按组进行对数据进行统计分析。</p><h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: df = pd.DataFrame(&#123;<span class="string">'key1'</span> : [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>],</span><br><span class="line">   ....:                    <span class="string">'key2'</span> : [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>],</span><br><span class="line">   ....:                    <span class="string">'data1'</span> : np.random.randn(<span class="number">5</span>),</span><br><span class="line">   ....:                    <span class="string">'data2'</span> : np.random.randn(<span class="number">5</span>)&#125;)</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: df  <span class="comment">#建立一个Dataframe数据框</span></span><br><span class="line">Out[<span class="number">11</span>]: </span><br><span class="line">      data1     data2 key1 key2</span><br><span class="line"><span class="number">0</span> <span class="number">-0.204708</span>  <span class="number">1.393406</span>    a  one</span><br><span class="line"><span class="number">1</span>  <span class="number">0.478943</span>  <span class="number">0.092908</span>    a  two</span><br><span class="line"><span class="number">2</span> <span class="number">-0.519439</span>  <span class="number">0.281746</span>    b  one</span><br><span class="line"><span class="number">3</span> <span class="number">-0.555730</span>  <span class="number">0.769023</span>    b  two</span><br><span class="line"><span class="number">4</span>  <span class="number">1.965781</span>  <span class="number">1.246435</span>    a  one</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: grouped = df.groupby(<span class="string">'key1'</span>)  <span class="comment">#按key1进行分组</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: grouped  <span class="comment">#得到的grouped一个简单处理的可迭代对象（GroupBy），实际上还没有进行任何计算</span></span><br><span class="line">Out[<span class="number">13</span>]: &lt;pandas.core.groupby.DataframeGroupBy object at <span class="number">0x0000000000FF07EB8</span>&gt;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">14</span>]: grouped.mean()  <span class="comment">#调用GroupBy的mean方法来计算分组平均值：</span></span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.114474</span>  <span class="number">0.714913</span></span><br><span class="line">b     <span class="number">0.300820</span> <span class="number">-1.160967</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: means = df.groupby([<span class="string">'key1'</span>, <span class="string">'key2'</span>]).mean()[<span class="string">'data1'</span>]  <span class="comment">#按key1和key2分组，选出data1数据</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: means</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">key1  key2</span><br><span class="line">a     one     <span class="number">0.880536</span></span><br><span class="line">      two     <span class="number">0.478943</span></span><br><span class="line">b     one    <span class="number">-0.519439</span></span><br><span class="line">      two    <span class="number">-0.555730</span></span><br><span class="line">Name: data1, dtype: float64</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: people = pd.DataFrame(np.random.randn(<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">   ....:                       columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>],</span><br><span class="line">   ....:                       index=[<span class="string">'Joe'</span>, <span class="string">'Steve'</span>, <span class="string">'Wes'</span>, <span class="string">'Jim'</span>, <span class="string">'Travis'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: people.iloc[<span class="number">2</span>:<span class="number">3</span>, [<span class="number">1</span>, <span class="number">2</span>]] = np.nan <span class="comment"># Add a few NA values</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: people  <span class="comment">#另建一个数据框，拥有index名</span></span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">               a         b         c         d         e</span><br><span class="line">Joe     <span class="number">1.007189</span> <span class="number">-1.296221</span>  <span class="number">0.274992</span>  <span class="number">0.228913</span>  <span class="number">1.352917</span></span><br><span class="line">Steve   <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span></span><br><span class="line">Wes    <span class="number">-0.539741</span> <span class="number">-2.001001</span> <span class="number">-2.001002</span> <span class="number">-1.021228</span> <span class="number">-0.577087</span></span><br><span class="line">Jim     <span class="number">0.124121</span>  <span class="number">0.302614</span>  <span class="number">0.523772</span>  <span class="number">0.000940</span>  <span class="number">1.343810</span></span><br><span class="line">Travis <span class="number">-0.713544</span> <span class="number">-0.831154</span> <span class="number">-2.370232</span> <span class="number">-1.860761</span> <span class="number">-0.860757</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: people.groupby(len).sum() <span class="comment">#用python函数分组将使用index</span></span><br><span class="line">Out[<span class="number">44</span>]: </span><br><span class="line">          a         b         c         d         e</span><br><span class="line"><span class="number">3</span>  <span class="number">0.591569</span> <span class="number">-0.993608</span>  <span class="number">0.798764</span> <span class="number">-0.791374</span>  <span class="number">2.119639</span></span><br><span class="line"><span class="number">5</span>  <span class="number">0.886429</span> <span class="number">-2.001637</span> <span class="number">-0.371843</span>  <span class="number">1.669025</span> <span class="number">-0.438570</span></span><br><span class="line"><span class="number">6</span> <span class="number">-0.713544</span> <span class="number">-0.831154</span> <span class="number">-2.370232</span> <span class="number">-1.860761</span> <span class="number">-0.860757</span></span><br></pre></td></tr></table></figure><h3 id="聚合运算方法"><a href="#聚合运算方法" class="headerlink" title="聚合运算方法"></a>聚合运算方法</h3><p><img src="/2018/09/18/groupby-in-Python-and-R/pandas-groupby.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: <span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></span><br><span class="line">   ....:     <span class="keyword">return</span> arr.max() - arr.min()</span><br><span class="line">In [<span class="number">55</span>]: grouped.agg(peak_to_peak)  <span class="comment">#使用自己的聚合函数，将其传入aggregate或agg方法</span></span><br><span class="line">Out[<span class="number">55</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1                    </span><br><span class="line">a     <span class="number">2.170488</span>  <span class="number">1.300498</span></span><br><span class="line">b     <span class="number">0.036292</span>  <span class="number">0.487276</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">69</span>]: grouped.agg([<span class="string">'mean'</span>,<span class="string">'size'</span>]) <span class="comment">#使用多个统计方法</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">69</span>]: ftuples = [(<span class="string">'fuc1'</span>, <span class="string">'mean'</span>),(<span class="string">'fuc2'</span>, np.var)]  <span class="comment">#使用自定义的名字</span></span><br><span class="line">In [<span class="number">70</span>]: grouped.agg(ftuples)</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: grouped.agg(&#123;<span class="string">'data1'</span> : [<span class="string">'min'</span>, <span class="string">'max'</span>, <span class="string">'mean'</span>, <span class="string">'std'</span>],  <span class="comment">#不同列可以指定不同的统计方法</span></span><br><span class="line">   ....:              <span class="string">'data2'</span> : [<span class="string">'sum'</span>]&#125;)</span><br></pre></td></tr></table></figure><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(dplyr)  <span class="comment">#group_by和summarise都在dplyr包中</span></span><br><span class="line">data &lt;- data.frame(year = rep(<span class="number">2016</span>:<span class="number">2017</span>,<span class="number">6</span>),month = seq(<span class="number">1</span>:<span class="number">12</span>),sales=rep(c(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>),<span class="number">3</span>))</span><br><span class="line">   year month sales</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>     <span class="number">1</span>    <span class="number">10</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>     <span class="number">2</span>    <span class="number">20</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2016</span>     <span class="number">3</span>    <span class="number">30</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2017</span>     <span class="number">4</span>    <span class="number">40</span></span><br><span class="line"><span class="number">5</span>  <span class="number">2016</span>     <span class="number">5</span>    <span class="number">10</span></span><br><span class="line"><span class="number">6</span>  <span class="number">2017</span>     <span class="number">6</span>    <span class="number">20</span></span><br><span class="line"><span class="number">7</span>  <span class="number">2016</span>     <span class="number">7</span>    <span class="number">30</span></span><br><span class="line"><span class="number">8</span>  <span class="number">2017</span>     <span class="number">8</span>    <span class="number">40</span></span><br><span class="line"><span class="number">9</span>  <span class="number">2016</span>     <span class="number">9</span>    <span class="number">10</span></span><br><span class="line"><span class="number">10</span> <span class="number">2017</span>    <span class="number">10</span>    <span class="number">20</span></span><br><span class="line"><span class="number">11</span> <span class="number">2016</span>    <span class="number">11</span>    <span class="number">30</span></span><br><span class="line"><span class="number">12</span> <span class="number">2017</span>    <span class="number">12</span>    <span class="number">40</span></span><br><span class="line">planes &lt;- group_by(data, year)  <span class="comment">#按年分组</span></span><br><span class="line">delay &lt;- summarise(planes,</span><br><span class="line">                   count = n(),                <span class="comment">#个数</span></span><br><span class="line">                   max_mon = max(month),       <span class="comment">#最大值</span></span><br><span class="line">                   min_mon = min(month),       <span class="comment">#最小值</span></span><br><span class="line">                   avg_sales = mean(sales),    <span class="comment">#平均值</span></span><br><span class="line">                   sum_sales = sum(sales))     <span class="comment">#求和</span></span><br><span class="line"><span class="comment"># A tibble: 2 x 6</span></span><br><span class="line">   year count max_mon min_mon avg_sales sum_sales</span><br><span class="line">  &lt;int&gt; &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>     <span class="number">6</span>      <span class="number">11</span>       <span class="number">1</span>        <span class="number">20</span>       <span class="number">120</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>     <span class="number">6</span>      <span class="number">12</span>       <span class="number">2</span>        <span class="number">30</span>       <span class="number">180</span></span><br></pre></td></tr></table></figure><h3 id="常用的摘要函数"><a href="#常用的摘要函数" class="headerlink" title="常用的摘要函数"></a>常用的摘要函数</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean()sd()min()max()first()last()n()sum()</span><br><span class="line">median()<span class="comment">#中位数</span></span><br><span class="line">quantile()<span class="comment">#分位数，quantile(x，0.25)将会找出x从小到大排列，在25%时的数</span></span><br></pre></td></tr></table></figure><h3 id="聚合函数和逻辑筛选结合"><a href="#聚合函数和逻辑筛选结合" class="headerlink" title="聚合函数和逻辑筛选结合"></a>聚合函数和逻辑筛选结合</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delay &lt;- summarise(planes,</span><br><span class="line">                   avg_sales_1 = mean(sales,na.rm=<span class="literal">TRUE</span>),</span><br><span class="line">                   <span class="comment">#na.rm=TRUE,遇到NA值时不处理，因为统计时R默认NA值会传播，python不会</span></span><br><span class="line">                   avg_sales_2 = mean(sales[sales&gt;<span class="number">10</span>],na.rm=<span class="literal">TRUE</span>)<span class="comment">#加入逻辑判断</span></span><br><span class="line">planes &lt;- group_by(data, year)  <span class="comment">#按年分组</span></span><br><span class="line"><span class="comment"># A tibble: 2 x 3</span></span><br><span class="line">   year avg_sales_1 avg_sales_2</span><br><span class="line">  &lt;int&gt;       &lt;dbl&gt;       &lt;dbl&gt;</span><br><span class="line"><span class="number">1</span>  <span class="number">2016</span>         <span class="number">20.</span>         <span class="number">30.</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2017</span>         <span class="number">30.</span>         <span class="number">30.</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In[<span class="number">53</span>]: grouped = df[df.data1&gt;<span class="number">0</span>].groupby(<span class="string">'key1'</span>)  <span class="comment">#逻辑筛选后按key1进行分组</span></span><br><span class="line">Out[<span class="number">53</span>]: </span><br><span class="line">         data1     data2</span><br><span class="line">key1</span><br><span class="line">a     <span class="number">0.679126</span>  <span class="number">1.013678</span></span><br><span class="line">b     <span class="number">0.300820</span> <span class="number">-1.160967</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;groupby 可以根据一个数据框的部分数据，将整个数据框进行分组，简称：聚合。聚合之后，可以按组进行对数据进行统计分析。&lt;/p&gt;
&lt;h2 id=&quot;pandas&quot;&gt;&lt;a href=&quot;#pandas&quot; class=&quot;headerlink&quot; title=&quot;pandas&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>python标准库学习（二）</title>
    <link href="http://yoursite.com/2018/09/18/python-standard-library-2/"/>
    <id>http://yoursite.com/2018/09/18/python-standard-library-2/</id>
    <published>2018-09-18T02:24:06.000Z</published>
    <updated>2018-09-19T08:54:16.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可迭代对象与迭代器"><a href="#可迭代对象与迭代器" class="headerlink" title="可迭代对象与迭代器"></a>可迭代对象与迭代器</h2><p>可迭代对象与迭代器概念不同。可迭代对象在内部实现了<code>__iter__</code>，所以可以进行迭代，迭代器在内部实现了<code>__iter__</code>和<code>__next__</code>,所以是个迭代器也可以进行迭代。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"> <span class="comment">#mylist是个列表，可以进行迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = （x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)） <span class="comment">#生成器表达式，结果同iter(mylist)</span></span><br><span class="line"><span class="comment">#现在mylist是个迭代器，可以使用.next()方法</span></span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器本质就是一个迭代器，自带了<code>iter</code>方法和<code>next</code>方法。迭代器是用来迭代可迭代对象的，而生成器是用来迭代方法的。调用函数的之后函数不执行，返回一个生成器每次调用<code>next</code>方法的时候会取到一个值直到取完最后一个，再执行next会报错。</p><p>生成器表达式类似于列表推导，但是，生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表。</p><p>比较：</p><ul><li>列表表达式在生成后可以按序列取值，排序，切片等，但是占用内存大。</li><li>生成器表达式只是产生一个可迭代对象，需要时再迭代取值，占用内存小，但是不可进行列表的操作，迭代完后对象清空。</li></ul><hr><h2 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h2><h3 id="itertools-product"><a href="#itertools-product" class="headerlink" title="itertools.product"></a>itertools.product</h3><p>产生多个列表和迭代器的笛卡尔积，可以用product来改写深度嵌套的列表推导操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.product(<span class="string">'ABC'</span>, range(<span class="number">3</span>))</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="number">0</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'A'</span>, <span class="number">2</span>), (<span class="string">'B'</span>, <span class="number">0</span>), (<span class="string">'B'</span>, <span class="number">1</span>), (<span class="string">'B'</span>, <span class="number">2</span>), (<span class="string">'C'</span>, <span class="number">0</span>), (<span class="string">'C'</span>, <span class="number">1</span>), (<span class="string">'C'</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-accumulate"><a href="#itertools-accumulate" class="headerlink" title="itertools.accumulate"></a>itertools.accumulate</h3><p>简单来说就是累加。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.accumulate(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">45</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-chain"><a href="#itertools-chain" class="headerlink" title="itertools.chain"></a>itertools.chain</h3><p>连接多个列表或者迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.chain(range(<span class="number">3</span>), range(<span class="number">4</span>), [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-combinations"><a href="#itertools-combinations" class="headerlink" title="itertools.combinations"></a>itertools.combinations</h3><p>求列表或生成器中指定数目的元素不重复的所有组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.combinations(range(<span class="number">4</span>), <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-combinations-with-replacement"><a href="#itertools-combinations-with-replacement" class="headerlink" title="itertools.combinations_with_replacement"></a>itertools.combinations_with_replacement</h3><p>允许重复元素的组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.combinations_with_replacement(<span class="string">'ABC'</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="string">'A'</span>, <span class="string">'A'</span>), (<span class="string">'A'</span>, <span class="string">'B'</span>), (<span class="string">'A'</span>, <span class="string">'C'</span>), (<span class="string">'B'</span>, <span class="string">'B'</span>), (<span class="string">'B'</span>, <span class="string">'C'</span>), (<span class="string">'C'</span>, <span class="string">'C'</span>)]</span><br></pre></td></tr></table></figure><h3 id="itertools-count"><a href="#itertools-count" class="headerlink" title="itertools.count"></a>itertools.count</h3><p>就是一个计数器,可以指定起始位置和步长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.count(start=<span class="number">20</span>, step=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.islice(x, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>)))</span><br><span class="line">[<span class="number">20</span>, <span class="number">19</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">11</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-cycle"><a href="#itertools-cycle" class="headerlink" title="itertools.cycle"></a>itertools.cycle</h3><p>循环指定的列表和迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.cycle(<span class="string">'ABC'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(itertools.islice(x, <span class="number">0</span>, <span class="number">10</span>, <span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-dropwhile"><a href="#itertools-dropwhile" class="headerlink" title="itertools.dropwhile"></a>itertools.dropwhile</h3><p>按照真值函数丢弃掉列表和迭代器前面的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.dropwhile(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-takewhile"><a href="#itertools-takewhile" class="headerlink" title="itertools.takewhile"></a>itertools.takewhile</h3><p>与dropwhile相反，保留元素直至真值函数值为假。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.takewhile(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-filterfalse"><a href="#itertools-filterfalse" class="headerlink" title="itertools.filterfalse"></a>itertools.filterfalse</h3><p>保留对应真值为False的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.filterfalse(<span class="keyword">lambda</span> e: e &lt; <span class="number">5</span>, (<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-groupby"><a href="#itertools-groupby" class="headerlink" title="itertools.groupby"></a>itertools.groupby</h3><p>按照分组函数的值对元素进行分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.groupby(range(<span class="number">10</span>), <span class="keyword">lambda</span> x: x &lt; <span class="number">5</span> <span class="keyword">or</span> x &gt; <span class="number">8</span>)                                                                                                 </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> condition, numbers <span class="keyword">in</span> x:                                                  </span><br><span class="line"><span class="meta">... </span>    print(condition, list(numbers))                                                                                                        </span><br><span class="line"><span class="keyword">True</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]                                                              </span><br><span class="line"><span class="keyword">False</span> [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]                                                                </span><br><span class="line"><span class="keyword">True</span> [<span class="number">9</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-islice"><a href="#itertools-islice" class="headerlink" title="itertools.islice"></a>itertools.islice</h3><p>上文使用过的函数，对迭代器进行切片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.islice(range(<span class="number">10</span>), <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-repeat"><a href="#itertools-repeat" class="headerlink" title="itertools.repeat"></a>itertools.repeat</h3><p>简单的生成一个拥有指定数目元素的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.repeat(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="itertools-zip-longest"><a href="#itertools-zip-longest" class="headerlink" title="itertools.zip_longest"></a>itertools.zip_longest</h3><p>类似于zip，不过已较长的列表和迭代器的长度为准</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = itertools.zip_longest(range(<span class="number">3</span>), range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = zip(range(<span class="number">3</span>), range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(x))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>), (<span class="keyword">None</span>, <span class="number">3</span>), (<span class="keyword">None</span>, <span class="number">4</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(list(y))</span><br><span class="line">[(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可迭代对象与迭代器&quot;&gt;&lt;a href=&quot;#可迭代对象与迭代器&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象与迭代器&quot;&gt;&lt;/a&gt;可迭代对象与迭代器&lt;/h2&gt;&lt;p&gt;可迭代对象与迭代器概念不同。可迭代对象在内部实现了&lt;code&gt;__iter__&lt;/c
      
    
    </summary>
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
  </entry>
  
  <entry>
    <title>seqkit 使用说明</title>
    <link href="http://yoursite.com/2018/09/13/seqkit-usage/"/>
    <id>http://yoursite.com/2018/09/13/seqkit-usage/</id>
    <published>2018-09-13T01:37:50.000Z</published>
    <updated>2018-11-30T07:44:09.946Z</updated>
    
    <content type="html"><![CDATA[<p>seqkit 是 Wei Shen 使用 go 语言编写处理 fa 和 fq 文件的一把利器，当前介绍版本为0.9.1。这里不详细介绍各个函数的参数，官方给出的文档已经足够。</p><p>软件地址：<a href="https://github.com/shenwei356/seqkit" target="_blank" rel="noopener">https://github.com/shenwei356/seqkit</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Available Commands:</span><br><span class="line">  common          find common sequences of multiple files by id/name/sequence</span><br><span class="line">  concat          concatenate sequences with same ID from multiple files</span><br><span class="line">  convert         convert FASTQ quality encoding between Sanger, Solexa and Illumina</span><br><span class="line">  duplicate       duplicate sequences N times</span><br><span class="line">  faidx           create FASTA index file and extract subsequence</span><br><span class="line">  fq2fa           convert FASTQ to FASTA</span><br><span class="line">  fx2tab          convert FASTA/Q to tabular format (with length/GC content/GC skew)</span><br><span class="line">  genautocomplete generate shell autocompletion script</span><br><span class="line">  grep            search sequences by ID/name/sequence/sequence motifs, mismatch allowed</span><br><span class="line">  head            print first N FASTA/Q records</span><br><span class="line">  help            Help about any command</span><br><span class="line">  locate          locate subsequences/motifs, mismatch allowed</span><br><span class="line">  range           print FASTA/Q records in a range (start:end)</span><br><span class="line">  rename          rename duplicated IDs</span><br><span class="line">  replace         replace name/sequence by regular expression</span><br><span class="line">  restart         reset start position for circular genome</span><br><span class="line">  rmdup           remove duplicated sequences by id/name/sequence</span><br><span class="line">  sample          sample sequences by number or proportion</span><br><span class="line">  seq             transform sequences (revserse, complement, extract ID...)</span><br><span class="line">  shuffle         shuffle sequences</span><br><span class="line">  sliding         sliding sequences, circular genome supported</span><br><span class="line">  sort            sort sequences by id/name/sequence/length</span><br><span class="line">  split           split sequences into files by id/seq region/size/parts (mainly for FASTA)</span><br><span class="line">  split2          split sequences into files by size/parts (FASTA, PE/SE FASTQ)</span><br><span class="line">  stats           simple statistics of FASTA/Q files</span><br><span class="line">  subseq          get subsequences by region/gtf/bed, including flanking sequences</span><br><span class="line">  tab2fx          convert tabular format to FASTA/Q format</span><br><span class="line">  translate       translate DNA/RNA to protein sequence</span><br><span class="line">  version         print version information and check for update</span><br></pre></td></tr></table></figure><h2 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz  <span class="comment">#展示fa文件</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cel-let-7 MI0000001 Caenorhabditis elegans <span class="built_in">let</span>-7 stem-loop</span></span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAAC</span><br><span class="line">UAUGCAAUUUUCUACCUUACCGGAGACAGAACUCUUCGA</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq read_1.fq.gz  <span class="comment">#展示fq文件</span></span></span><br><span class="line">@HWI-D00523:240:HF3WGBCXX:1:1101:2574:2226 1:N:0:CTGTAG</span><br><span class="line">TGAGGAATATTGGTCAATGGGCGCGAGCCTGAACCAGCCAAGTAGCGTGAAGGATGACTGCCCTACGGG</span><br><span class="line">+</span><br><span class="line">HIHIIIIIHIIHGHHIHHIIIIIIIIIIIIIIIHHIIIIIHHIHIIIIIGIHIIIIHHHHHHGHIHIII</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -n  <span class="comment">#展示序列全名</span></span></span><br><span class="line">cel-let-7 MI0000001 Caenorhabditis elegans let-7 stem-loop</span><br><span class="line">cel-lin-4 MI0000002 Caenorhabditis elegans lin-4 stem-loop</span><br><span class="line">cel-mir-1 MI0000003 Caenorhabditis elegans miR-1 stem-loop</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -n -i  <span class="comment">#展示序列ID</span></span></span><br><span class="line">cel-let-7</span><br><span class="line">cel-lin-4</span><br><span class="line">cel-mir-1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -n -i --id-regexp <span class="string">"^[^\s]+\s([^\s]+)\s"</span>  <span class="comment">#使用正则匹配序列名</span></span></span><br><span class="line">MI0000001</span><br><span class="line">MI0000002</span><br><span class="line">MI0000003</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -s -w 0  <span class="comment">#只展示序列 并设置每行碱基数为默认</span></span></span><br><span class="line">UACACUGUGGAUCCGGUGAGGUAGUAGGUUGUAUAGUUUGGAAUAUUACCACCGGUGAACUAUGCAAUUUUCUACCUUACCG</span><br><span class="line">GAGACAGAACUCUUCGA</span><br><span class="line">AUGCUUCCGGCCUGUUCCCUGAGACCUCAAGUGUGAGUGUACUAUUGAUGCUUCACACCUGGGCUCUCCGGGUACCAGGACG</span><br><span class="line">GUUUGAGCAGAU</span><br><span class="line">AAAGUGACCGUACCGAGCUGCAUACUUCCUUACAUGCCCAUACUAUAUCAUAAAUGGAUAUGGAAUGUAAAGAAGUAUGUAG</span><br><span class="line">AACGGGGUGGUAGU</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -m 50 -M 150   <span class="comment">#过滤fq文件，使序列长度在50-150bp之间。</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit seq hairpin.fa.gz -r -p  <span class="comment">#反转录序列</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">cel-let-7 MI0000001 Caenorhabditis elegans <span class="built_in">let</span>-7 stem-loop</span></span><br><span class="line">UCGAAGAGUUCUGUCUCCGGUAAGGUAGAAAAUUGCAUAGUUCACCGGUGGUAAUAUUCC</span><br><span class="line">AAACUAUACAACCUACUACCUCACCGGAUCCACAGUGUA</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq\nACGT-actgc-ACC"</span> | seqkit seq -g -u  <span class="comment">#去除序列gap 并大写碱基</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq</span></span><br><span class="line">ACGTACTGCACC</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq\nUCAUAUGCUUGUCUCAAAGAUUA"</span> | seqkit seq --rna2dna <span class="comment">#DNA转RNA,--dna2rna亦可</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq</span></span><br><span class="line">TCATATGCTTGTCTCAAAGATTA</span><br></pre></td></tr></table></figure><h2 id="subseq"><a href="#subseq" class="headerlink" title="subseq"></a>subseq</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit subseq -r 1:12  <span class="comment">#展示序列前12个碱基</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit subseq -r -12:-1 <span class="comment">#后12个</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat t.fa</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq</span></span><br><span class="line">actgACTGactgn</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat t.gtf  <span class="comment">#注意gtf文件格式，必须以\t分割。</span></span></span><br><span class="line">seqtestCDS58...gene_id "A"; transcript_id "";</span><br><span class="line">seqtestCDS58.-.gene_id "B"; transcript_id "";</span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit subseq --gtf t.gtf t.fa  <span class="comment">#使用gtf位置信息，挑选fa序列</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:. A</span></span><br><span class="line">ACTG</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:- B</span></span><br><span class="line">CAGT</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit subseq --gtf Homo_sapiens.GRCh38.84.gtf.gz --chr 1 --feature cds hsa.fa</span></span><br><span class="line"><span class="meta"> &gt;</span><span class="bash"> chr1.gtf.cds.fa  <span class="comment">#指定染色体和特征</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit subseq --gtf t.gtf t.fa -u 3  <span class="comment">#另加3bp上游序列</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:._us:3 A</span></span><br><span class="line">ctgACTG</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:-_us:3 B</span></span><br><span class="line">agtCAGT</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit subseq --gtf t.gtf t.fa -u 3 -f  <span class="comment">#只取上游3bp序列</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:._usf:3 A</span></span><br><span class="line">ctg</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq_5:8:-_usf:3 B</span></span><br><span class="line">agt</span><br></pre></td></tr></table></figure><p>gff3 文件第九列格式为ID=XXXXX; gtf 文件第九列格式为 gene_id “A”; transcript_id “”;</p><h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit stats *.f&#123;a,q&#125;.gz  <span class="comment">#统计序列信息</span></span></span><br><span class="line">file format type num_seqs sum_len min_len avg_len max_len</span><br><span class="line">hairpin.fa.gz  FASTA RNA  28,645  2,949,871  39  103 2,354</span><br><span class="line">mature.fa.gz  FASTA  RNA  35,828  781,222  15  21.8 34</span><br><span class="line">reads_1.fq.gz  FASTQ  DNA  2,500  567,516  226 227 229</span><br><span class="line">reads_2.fq.gz  FASTQ  DNA  2,500  560,002  223  224 225</span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit stats *.f&#123;a,q&#125;.gz  -a  <span class="comment">#列出所有统计结果</span></span></span><br><span class="line">file               format  type  num_seqs    sum_len  min_len  avg_len  max_len   Q1   Q2   Q3  sum_gap  N50  Q20(%)  Q30(%)</span><br><span class="line">hairpin.fa.gz      FASTA   RNA     28,645  2,949,871       39      103    2,354   76   91  111        0  101       0       0</span><br><span class="line">mature.fa.gz       FASTA   RNA     35,828    781,222       15     21.8       34   21   22   22        0   22       0       0</span><br><span class="line">Illimina1.8.fq.gz  FASTQ   DNA     10,000  1,500,000      150      150      150  150  150  150        0  150   96.16   89.71</span><br><span class="line">reads_1.fq.gz      FASTQ   DNA      2,500    567,516      226      227      229  227  227  227        0  227   91.24   86.62</span><br><span class="line">reads_2.fq.gz      FASTQ   DNA      2,500    560,002      223      224      225  224  224  224        0  224   91.06   87.66</span><br></pre></td></tr></table></figure><h2 id="faidx"><a href="#faidx" class="headerlink" title="faidx"></a>faidx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit faidx hairpin.fa  <span class="comment">#建立序列索引</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hsa-let-7a-1</span></span><br><span class="line">UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU</span><br><span class="line">ACAAUCUACUGUCUUUCCUA</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hsa-let-7a-2</span></span><br><span class="line">AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU</span><br><span class="line">CCUAGCUUUCCU</span><br></pre></td></tr></table></figure><h2 id="fq2fa"><a href="#fq2fa" class="headerlink" title="fq2fa"></a>fq2fa</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit fq2fa reads_1.fq.gz -o reads1_.fa.gz  <span class="comment">#fq转fa</span></span></span><br></pre></td></tr></table></figure><h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit head -n 1 tests/Illimina1.8.fq.gz</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash">AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJ</span></span><br><span class="line">JJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit convert tests/Illimina1.8.fq.gz | seqkit head -n 1  <span class="comment">#默认转换fq文件质量值到1.8+</span></span></span><br><span class="line">[INFO] possible quality encodings: [Illumina-1.8+]</span><br><span class="line">[INFO] guessed quality encoding: Illumina-1.8+</span><br><span class="line">[INFO] converting Illumina-1.8+ -&gt; Sanger</span><br><span class="line">[WARN] source and target quality encoding match.</span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash">AAAFAAJFFFJJJ&lt;JJJJJFFFJFJJJJJFJJAJJJFJJFJFJJJJFAFJ&lt;JA&lt;FFJ7FJJFJJAAJJJJ&lt;JJJJJJJFJJJAJJJ</span></span><br><span class="line">JJFJJ77&lt;JJJJ-F7A-FJFFJJJJJJ&lt;FFJ-&lt;7FJJJFJJ)A7)7AA&lt;7--)&lt;-7F-A7FA&lt;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit convert tests/Illimina1.8.fq.gz --to Illumina-1.5+ | seqkit head -n 1</span></span><br><span class="line">[INFO] possible quality encodings: [Illumina-1.8+] </span><br><span class="line">[INFO] guessed quality encoding: Illumina-1.8+</span><br><span class="line">[INFO] converting Illumina-1.8+ -&gt; Illumina-1.5+  #转换 Illumina1.8+ -&gt; Illumina1.5+</span><br><span class="line">...</span><br><span class="line">B```e``ieeeiii[iiiiieeeieiiiiieii`iiieiieieiiiie`ei[i`[eeiVeiieii``iiii[iiiiiiieiii`iii</span><br><span class="line">iieiiVV[iiiiLeV`Leieeiiiiii[eeiL[VeiiieiiH`VHV``[VLLH[LVeL`Ve`[</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit grep -r -p ^hsa  <span class="comment">#正则匹配序列名</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hsa-let-7a-1 MI0000060 Homo sapiens <span class="built_in">let</span>-7a-1 stem-loop</span></span><br><span class="line">UGGGAUGAGGUAGUAGGUUGUAUAGUUUUAGGGUCACACCCACCACUGGGAGAUAACUAU</span><br><span class="line">ACAAUCUACUGUCUUUCCUA</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">hsa-let-7a-2 MI0000061 Homo sapiens <span class="built_in">let</span>-7a-2 stem-loop</span></span><br><span class="line">AGGUUGAGGUAGUAGGUUGUAUAGUUUAGAAUUACAUCAAGGGAGAUAACUGUACAGCCU</span><br><span class="line">CCUAGCUUUCCU</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit grep -r -p ^hsa -p ^mmu -v  <span class="comment">#2个条件并取反</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit grep -f list &gt; new.fa  <span class="comment">#将需要提取的序列名放在list中</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit grep -s -r -i -p ^aggcg  <span class="comment">#正则匹配序列碱基，-i 忽略大小写</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit grep -s -R 1:30 -i -r -p GCTGG  <span class="comment">#-R 在前30个碱基中正则匹配</span></span></span><br></pre></td></tr></table></figure><h2 id="rmdup"><a href="#rmdup" class="headerlink" title="rmdup"></a>rmdup</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit rmdup -s -o clean.fa.gz <span class="comment">#去除重复的序列</span></span></span><br><span class="line">[INFO] 2226 duplicated records removed</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> zcat hairpin.fa.gz | seqkit rmdup -s -i -m -o clean.fa.gz -d duplicated.fa.gz -D</span></span><br><span class="line"> duplicated.detail.txt #-d输出重复序列，-D统计重复序列</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat duplicated.detail.txt <span class="comment"># here is not the entire list</span></span></span><br><span class="line">3 hsa-mir-424, mml-mir-424, ppy-mir-424</span><br><span class="line">3 hsa-mir-342, mml-mir-342, ppy-mir-342</span><br><span class="line">2 ngi-mir-932, nlo-mir-932</span><br><span class="line">2 ssc-mir-9784-1, ssc-mir-9784-2</span><br></pre></td></tr></table></figure><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit common file*.fa -o common.fasta  <span class="comment">#通过ID寻找共同序列</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit common file*.fa -n -o common.fasta  <span class="comment">#通过全名</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit common file*.fa -s -i -o common.fasta  <span class="comment">#通过序列</span></span></span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit split hairpin.fa.gz -s 10000  <span class="comment">#按序列数分割文件</span></span></span><br><span class="line">[INFO] split into 10000 seqs per file</span><br><span class="line">[INFO] write 10000 sequences to file: hairpin.fa.part_001.gz</span><br><span class="line">[INFO] write 10000 sequences to file: hairpin.fa.part_002.gz</span><br><span class="line">[INFO] write 8645 sequences to file: hairpin.fa.part_003.gz </span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit split hairpin.fa.gz -p 4  <span class="comment">#按文件个数分割文件</span></span></span><br><span class="line">[INFO] split into 4 parts</span><br><span class="line">[INFO] read sequences ...</span><br><span class="line">[INFO] read 28645 sequences</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_001.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_002.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.fa.part_003.gz</span><br><span class="line">[INFO] write 7159 sequences to file: hairpin.fa.part_004.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit split hairpin.fa.gz -p 4 -2  <span class="comment">#-2减少内存使用</span></span></span><br><span class="line">[INFO] split into 4 parts</span><br><span class="line">[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] create and read FASTA index ...</span><br><span class="line">[INFO] read sequence IDs from FASTA index ...</span><br><span class="line">[INFO] 28645 sequences loaded</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_001.fa.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_002.fa.gz</span><br><span class="line">[INFO] write 7162 sequences to file: hairpin.part_003.fa.gz</span><br><span class="line">[INFO] write 7159 sequences to file: hairpin.part_004.fa.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit split hairpin.fa.gz -i --id-regexp <span class="string">"^([\w]+)\-"</span> -2  <span class="comment">#按ID</span></span></span><br><span class="line">[INFO] split by ID. idRegexp: ^([\w]+)\-</span><br><span class="line">[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] create and read FASTA index ...</span><br><span class="line">[INFO] create FASTA index for hairpin.fa.gz.fa</span><br><span class="line">[INFO] read sequence IDs from FASTA index ...</span><br><span class="line">[INFO] 28645 sequences loaded</span><br><span class="line">[INFO] write 48 sequences to file: hairpin.id_cca.fa.gz</span><br><span class="line">[INFO] write 3 sequences to file: hairpin.id_hci.fa.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit split hairpin.fa.gz -r 1:3 -2  <span class="comment">#按前3个碱基</span></span></span><br><span class="line">[INFO] split by region: 1:3</span><br><span class="line">[INFO] read and write sequences to tempory file: hairpin.fa.gz.fa ...</span><br><span class="line">[INFO] read sequence IDs and sequence region from FASTA file ...</span><br><span class="line">[INFO] create and read FASTA index ...</span><br><span class="line">[INFO] write 463 sequences to file: hairpin.region_1:3_AUG.fa.gz</span><br><span class="line">[INFO] write 349 sequences to file: hairpin.region_1:3_ACU.fa.gz</span><br><span class="line">[INFO] write 311 sequences to file: hairpin.region_1:3_CGG.fa.gz</span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat hairpin.fa | seqkit range -r 101:150  <span class="comment">#输出范围内的序列（1:12 如同 head -n 12）</span></span></span><br></pre></td></tr></table></figure><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet  <span class="comment">#按ID排序，--quiet不输出提示信息</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">SEQ2</span></span><br><span class="line">acgtnAAAA</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq1</span></span><br><span class="line">ACGTNcccc</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet -i  <span class="comment">#不区分大小写</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq1</span></span><br><span class="line">ACGTNcccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">SEQ2</span></span><br><span class="line">acgtnAAAA</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAA"</span> | seqkit sort --quiet -i -r <span class="comment">#不区分大小写，反转结果</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">SEQ2</span></span><br><span class="line">acgtnAAAA</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq1</span></span><br><span class="line">ACGTNcccc</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"&gt;seq1\nACGTNcccc\n&gt;SEQ2\nacgtnAAAAnnn\n&gt;seq3\nacgt"</span> | seqkit sort --quiet -l  <span class="comment">#按序列长度</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq3</span></span><br><span class="line">acgt</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">seq1</span></span><br><span class="line">ACGTNcccc</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">SEQ2</span></span><br><span class="line">acgtnAAAAnnn</span><br></pre></td></tr></table></figure><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seqkit translate tests/mouse-p53-cds.fna  <span class="comment">#将DNA/RNA 翻译为蛋白序列</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]</span></span><br><span class="line">MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA</span><br><span class="line">LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM</span><br><span class="line">CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS</span><br><span class="line">DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM</span><br><span class="line">GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS</span><br><span class="line">AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR</span><br><span class="line">AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD*</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> seqkit translate tests/mouse-p53-cds.fna --trim  <span class="comment">#去掉 */X（终止密码子）</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">lcl|AB021961.1_cds_BAA82344.1_1 [gene=p53] [protein=P53] [protein_id=BAA82344.1] [location=101..1273] [gbkey=CDS]</span></span><br><span class="line">MTAMEESQSDISLELPLSQETFSGLWKLLPPEDILPSPHCMDDLLLPQDVEEFFEGPSEA</span><br><span class="line">LRVSGAPAAQDPVTETPGPVAPAPATPWPLSSFVPSQKTYQGNYGFHLGFLQSGTAKSVM</span><br><span class="line">CTYSPPLNKLFCQLAKTCPVQLWVSATPPAGSRVRAMAIYKKSQHMTEVVRRCPHHERCS</span><br><span class="line">DGDGLAPPQHRIRVEGNLYPEYLEDRQTFRHSVVVPYEPPEAGSEYTTIHYKYMCNSSCM</span><br><span class="line">GGMNRRPILTIITLEDSSGNLLGRDSFEVRVCACPGRDRRTEEENFRKKEVLCPELPPGS</span><br><span class="line">AKRALPTCTSASPPQKKKPLDGEYFTLKIRGRKRFEMFRELNEALELKDAHATEESGDSR</span><br><span class="line">AHSSYLKTKKGQSTSRHKKTMVKKVGPDSD</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;seqkit 是 Wei Shen 使用 go 语言编写处理 fa 和 fq 文件的一把利器，当前介绍版本为0.9.1。这里不详细介绍各个函数的参数，官方给出的文档已经足够。&lt;/p&gt;
&lt;p&gt;软件地址：&lt;a href=&quot;https://github.com/shenwei35
      
    
    </summary>
    
      <category term="bioinfo" scheme="http://yoursite.com/categories/bioinfo/"/>
    
    
  </entry>
  
</feed>
